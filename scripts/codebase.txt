===== File: lib/expression.ts =====
Type: .ts
----- Content Start -----
export interface WorkflowContext {
  variables: Record<string, unknown>;
  nodeOutputs: Record<string, unknown>;
}

function getNestedValue(obj: unknown, path: string): unknown {
  return path
    .split(".")
    .reduce(
      (acc, key) =>
        acc && typeof acc === "object" && key in acc
          ? (acc as Record<string, unknown>)[key]
          : undefined,
      obj
    );
}

/**
 * Interpolate {{ ‚Ä¶ }} placeholders.
 *   ‚Ä¢ quoteStrings = false  ‚Üí bare values (for Slack, e-mail, etc.)
 *   ‚Ä¢ quoteStrings = true   ‚Üí strings are JSON-quoted (for eval)
 */
export function parseExpression(
  str: unknown,
  ctx: WorkflowContext,
  quoteStrings = false
): unknown {
  if (typeof str !== "string") return str;

  return str.replace(/\{\{([^}]+)\}\}/g, (match, expr) => {
    const trimmed = expr.trim();

    // Debug logging
    console.log(`üîç Parsing expression: ${trimmed}`);

    // ---------------- $node ----------------
    if (trimmed.startsWith("$node.")) {
      const [, nodeId, ...rest] = trimmed.split(".");
      const nodeOutput = ctx.nodeOutputs[nodeId];
      console.log(`üìä Node ${nodeId} output:`, nodeOutput);

      if (!nodeOutput) {
        console.warn(`‚ö†Ô∏è Node output not found for: ${nodeId}`);
        return match; // Return original if not found
      }

      const value = getNestedValue(nodeOutput, rest.join("."));
      console.log(`‚úÖ Resolved value:`, value);
      return serialise(value, quoteStrings);
    }

    // ---------------- $vars ----------------
    if (trimmed.startsWith("$vars.")) {
      const [, varName, ...rest] = trimmed.split(".");
      const base = ctx.variables[varName];
      console.log(`üìù Variable ${varName}:`, base);

      if (base === undefined) {
        console.warn(`‚ö†Ô∏è Variable not found: ${varName}`);
        return match;
      }

      const value =
        rest.length === 0 ? base : getNestedValue(base, rest.join("."));
      return serialise(value, quoteStrings);
    }

    console.warn(`‚ùå Unknown expression pattern: ${trimmed}`);
    return match; // leave untouched
  });
}

function serialise(v: unknown, quoteStrings: boolean): string {
  if (v === undefined || v === null) return "";
  if (typeof v === "string") {
    // When quoteStrings === true we want a JS string literal
    //   high  ‚Üí  'high'
    //   foo's ‚Üí  'foo\'s'
    return quoteStrings ? `'${String(v).replace(/'/g, "\\'")}'` : v;
  }
  if (typeof v === "number" || typeof v === "boolean") return String(v);
  return JSON.stringify(v); // objects / arrays
}

----- Content End -----

===== File: lib/execution-engine.ts =====
Type: .ts
----- Content Start -----
import {
  getExecutionWithWorkflow,
  updateExecutionToRunning,
  updateExecutionToCompleted,
  updateExecutionToFailed,
  createExecutionStep,
  updateExecutionStepToRunning,
  updateExecutionStepToCompleted,
  updateExecutionStepToFailed,
  getNextPendingExecution,
} from "./db";
import { integrationRegistry } from "./integrations/registry";
import type { WorkflowContext } from "./integrations/types";

interface WorkflowNode {
  id: string;
  type: string;
  data: {
    label: string;
    subtype?: string;
    config?: Record<string, unknown>;
  };
}

interface WorkflowEdge {
  id: string;
  source: string;
  target: string;
  sourceHandle?: string; // Add this to identify which output handle (true/false)
}

export class ExecutionEngine {
  private branchDecisions: Map<string, boolean> = new Map(); // Track branch decisions

  async executeWorkflow(executionId: string) {
    try {
      // Get execution and workflow data
      const execution = await getExecutionWithWorkflow(executionId);
      if (!execution) {
        const error = new Error("Execution not found");
        throw error;
      }

      const nodes: WorkflowNode[] =
        execution.nodes as unknown as WorkflowNode[];
      const edges: WorkflowEdge[] =
        execution.edges as unknown as WorkflowEdge[];

      // Update status to running
      await updateExecutionToRunning(executionId);

      const context: WorkflowContext = {
        variables: {},
        nodeOutputs: {},
        executionId,
      };

      // Reset branch decisions for each execution
      this.branchDecisions.clear();

      // Get execution order (topological sort)
      const executionOrder = this.getExecutionOrder(nodes, edges);

      // Execute nodes in order with conditional path support
      for (const nodeId of executionOrder) {
        const node = nodes.find((n) => n.id === nodeId);
        if (!node) {
          continue;
        }

        // Check if this node should be skipped based on branch conditions
        if (this.shouldSkipNode(nodeId, nodes, edges)) {
          console.log(`Skipping node ${nodeId} due to branch condition`);
          continue;
        }

        await this.executeNode(node, context, executionId);
      }

      // Mark as completed
      await updateExecutionToCompleted(executionId);
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : "Unknown error";

      // Mark as failed
      await updateExecutionToFailed(executionId, errorMessage);
      throw error;
    }
  }

  private shouldSkipNode(
    nodeId: string,
    nodes: WorkflowNode[],
    edges: WorkflowEdge[]
  ): boolean {
    // Find all edges leading to this node
    const incomingEdges = edges.filter((e) => e.target === nodeId);

    for (const edge of incomingEdges) {
      const sourceNode = nodes.find((n) => n.id === edge.source);
      if (!sourceNode) continue;

      // Check if source is a branch node
      if (sourceNode.data.subtype === "branch_condition") {
        const branchResult = this.branchDecisions.get(sourceNode.id);
        if (branchResult === undefined) continue; // Branch not yet executed

        // Check if this edge matches the branch result
        const isTrue =
          edge.sourceHandle === "true" || edge.id.includes("-true-");
        const isFalse =
          edge.sourceHandle === "false" || edge.id.includes("-false-");

        if ((isTrue && !branchResult) || (isFalse && branchResult)) {
          return true; // Skip this node
        }
      }
    }

    return false;
  }

  private async executeNode(
    node: WorkflowNode,
    context: WorkflowContext,
    executionId: string
  ) {
    const nodeId = node.id;

    // Create execution step record
    const stepId = await createExecutionStep(executionId, nodeId);

    // Set to running BEFORE execution
    await updateExecutionStepToRunning(stepId);

    try {
      // Execute the node
      const result = await this.simulateNodeExecution(node, context);

      // Store branch decisions
      if (
        node.data.subtype === "branch_condition" &&
        "data" in result &&
        result.data
      ) {
        const branchData = result.data as Record<string, unknown>;
        if (branchData.result !== undefined) {
          this.branchDecisions.set(node.id, branchData.result as boolean);
        }
      }

      // Store result in context
      context.nodeOutputs[nodeId] = result;

      // Update step as completed
      await updateExecutionStepToCompleted(stepId, result);
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : "Unknown error";

      // Update step as failed
      await updateExecutionStepToFailed(stepId, errorMessage);
      throw error;
    }
  }

  private async simulateNodeExecution(
    node: WorkflowNode,
    context: WorkflowContext
  ) {
    const config = node.data.config || {};
    const integrationId = node.data.subtype;

    if (!integrationId) {
      return {
        success: false,
        error: "No integration subtype specified for node",
        metadata: { nodeType: "unknown" },
      };
    }

    try {
      // Use the integration registry to execute the node
      const result = await integrationRegistry.executeIntegration(
        integrationId,
        config,
        context
      );

      return result;
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
        metadata: { nodeType: integrationId },
      };
    }
  }

  private getExecutionOrder(
    nodes: WorkflowNode[],
    edges: WorkflowEdge[]
  ): string[] {
    const adjacencyList: Record<string, string[]> = {};
    const inDegree: Record<string, number> = {};

    // Initialize
    nodes.forEach((node) => {
      adjacencyList[node.id] = [];
      inDegree[node.id] = 0;
    });

    // Build graph
    edges.forEach((edge) => {
      adjacencyList[edge.source].push(edge.target);
      inDegree[edge.target]++;
    });

    // Topological sort
    const queue: string[] = [];
    const result: string[] = [];

    Object.keys(inDegree).forEach((nodeId) => {
      if (inDegree[nodeId] === 0) {
        queue.push(nodeId);
      }
    });

    while (queue.length > 0) {
      const nodeId = queue.shift()!;
      result.push(nodeId);

      adjacencyList[nodeId].forEach((neighbor) => {
        inDegree[neighbor]--;
        if (inDegree[neighbor] === 0) {
          queue.push(neighbor);
        }
      });
    }

    if (result.length !== nodes.length) {
      throw new Error("Workflow contains cycles");
    }

    return result;
  }
}

export class QueueProcessor {
  private isProcessing = false;
  private engine = new ExecutionEngine();
  private processingCount = 0;

  async start() {
    if (this.isProcessing) return;
    this.isProcessing = true;

    while (this.isProcessing) {
      try {
        await this.processNextExecution();
        await new Promise((resolve) => setTimeout(resolve, 1000)); // Wait 1 second
      } catch (error) {
        console.error("Queue processing error:", error);
        await new Promise((resolve) => setTimeout(resolve, 5000)); // Wait 5 seconds on error
      }
    }
  }

  stop() {
    this.isProcessing = false;
  }

  private async processNextExecution() {
    const executionId = await getNextPendingExecution();

    if (executionId) {
      this.processingCount++;
      await this.engine.executeWorkflow(executionId);
      this.processingCount--;
    }
  }
}

----- Content End -----

===== File: lib/db.ts =====
Type: .ts
----- Content Start -----
import { Pool } from "pg";

if (!process.env.DATABASE_URL) {
  throw new Error("DATABASE_URL environment variable is not set");
}

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: { rejectUnauthorized: false },
  max: 10,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 10000,
});

// Test the connection
pool.on("connect", () => {
  console.log("‚úÖ Connected to PostgreSQL database");
});

pool.on("error", (err) => {
  console.error("‚ùå PostgreSQL connection error:", err);
});

// SQL table creation script
const createTablesSQL = `
CREATE TABLE IF NOT EXISTS automations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  nodes JSONB NOT NULL,
  edges JSONB NOT NULL,
  status VARCHAR(20) DEFAULT 'active',
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS automation_executions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  automation_id UUID REFERENCES automations(id) ON DELETE CASCADE,
  status VARCHAR(20) DEFAULT 'pending',
  started_at TIMESTAMP DEFAULT NOW(),
  completed_at TIMESTAMP,
  context JSONB DEFAULT '{}',
  error_message TEXT,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS execution_steps (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  execution_id UUID REFERENCES automation_executions(id) ON DELETE CASCADE,
  node_id VARCHAR(255) NOT NULL,
  status VARCHAR(20) DEFAULT 'pending',
  result JSONB,
  started_at TIMESTAMP,
  completed_at TIMESTAMP,
  error_message TEXT,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS scheduled_automations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  automation_id UUID REFERENCES automations(id) ON DELETE CASCADE,
  cron_expression VARCHAR(100) NOT NULL,
  timezone VARCHAR(50) DEFAULT 'UTC',
  last_run TIMESTAMP,
  next_run TIMESTAMP NOT NULL,
  active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_automation_executions_automation_id ON automation_executions(automation_id);
CREATE INDEX IF NOT EXISTS idx_automation_executions_status ON automation_executions(status);
CREATE INDEX IF NOT EXISTS idx_execution_steps_execution_id ON execution_steps(execution_id);
CREATE INDEX IF NOT EXISTS idx_scheduled_automations_next_run ON scheduled_automations(next_run, active);
`;

/**
 * Initialize database schema
 * Creates all necessary tables and indexes if they don't exist
 */
export async function initializeDatabase() {
  try {
    await pool.query(createTablesSQL);
    console.log("‚úÖ Database tables created/verified");
    return true;
  } catch (error) {
    console.error("‚ùå Failed to initialize database:", error);
    throw error;
  }
}

// ============================================
// AUTOMATION DATABASE OPERATIONS
// ============================================

export interface Automation {
  id: string;
  name: string;
  nodes: Record<string, unknown>[];
  edges: Record<string, unknown>[];
  status: string;
  created_at: string;
  updated_at: string;
}

/**
 * Get all automations ordered by most recently updated
 */
export async function getAllAutomations(): Promise<Automation[]> {
  try {
    const result = await pool.query(
      "SELECT * FROM automations ORDER BY updated_at DESC"
    );
    return result.rows;
  } catch (error) {
    console.error("Failed to fetch automations:", error);
    throw new Error("Failed to fetch automations");
  }
}

/**
 * Create a new automation
 */
export async function createAutomation(
  name: string,
  nodes: Record<string, unknown>[],
  edges: Record<string, unknown>[]
): Promise<Automation> {
  try {
    const result = await pool.query(
      "INSERT INTO automations (name, nodes, edges) VALUES ($1, $2, $3) RETURNING *",
      [name, JSON.stringify(nodes), JSON.stringify(edges)]
    );
    return result.rows[0];
  } catch (error) {
    console.error("Failed to create automation:", error);
    throw new Error("Failed to create automation");
  }
}

/**
 * Update an existing automation
 */
export async function updateAutomation(
  id: string,
  name: string,
  nodes: Record<string, unknown>[],
  edges: Record<string, unknown>[]
): Promise<Automation> {
  try {
    const result = await pool.query(
      "UPDATE automations SET name = $1, nodes = $2, edges = $3, updated_at = NOW() WHERE id = $4 RETURNING *",
      [name, JSON.stringify(nodes), JSON.stringify(edges), id]
    );

    if (result.rows.length === 0) {
      throw new Error("Automation not found");
    }

    return result.rows[0];
  } catch (error) {
    console.error("Failed to update automation:", error);
    throw error;
  }
}

/**
 * Update automation status
 */
export async function updateAutomationStatus(
  id: string,
  status: string
): Promise<Automation> {
  try {
    const result = await pool.query(
      "UPDATE automations SET status = $1, updated_at = NOW() WHERE id = $2 RETURNING *",
      [status, id]
    );

    if (result.rows.length === 0) {
      throw new Error("Automation not found");
    }

    return result.rows[0];
  } catch (error) {
    console.error("Failed to update automation status:", error);
    throw error;
  }
}

/**
 * Delete an automation
 */
export async function deleteAutomation(id: string): Promise<void> {
  try {
    const result = await pool.query(
      "DELETE FROM automations WHERE id = $1 RETURNING *",
      [id]
    );

    if (result.rows.length === 0) {
      throw new Error("Automation not found");
    }
  } catch (error) {
    console.error("Failed to delete automation:", error);
    throw error;
  }
}

// ============================================
// EXECUTION DATABASE OPERATIONS
// ============================================

export interface ExecutionStep {
  id: string | null;
  node_id: string;
  status: string;
  result: string | number | boolean | object | null;
  started_at: string | null;
  completed_at: string | null;
  error_message: string | null;
}

export interface Execution {
  id: string;
  automation_id: string;
  status: string;
  started_at: string;
  completed_at: string | null;
  context: Record<string, unknown>;
  error_message: string | null;
  created_at: string;
  steps?: ExecutionStep[];
}

/**
 * Create a new execution record
 */
export async function createExecution(
  automationId: string
): Promise<Execution> {
  try {
    const result = await pool.query(
      "INSERT INTO automation_executions (automation_id, status) VALUES ($1, $2) RETURNING *",
      [automationId, "pending"]
    );
    return result.rows[0];
  } catch (error) {
    console.error("Failed to create execution:", error);
    throw new Error("Failed to create execution");
  }
}

/**
 * Get execution with steps by execution ID
 */
export async function getExecutionWithSteps(
  executionId: string
): Promise<Execution | null> {
  try {
    const executionQuery = `
      SELECT 
        we.*,
        json_agg(
          json_build_object(
            'id', es.id,
            'node_id', es.node_id,
            'status', es.status,
            'result', es.result,
            'started_at', es.started_at,
            'completed_at', es.completed_at,
            'error_message', es.error_message
          ) ORDER BY es.created_at
        ) as steps
      FROM automation_executions we
      LEFT JOIN execution_steps es ON we.id = es.execution_id
      WHERE we.id = $1
      GROUP BY we.id
    `;

    const result = await pool.query(executionQuery, [executionId]);

    if (result.rows.length === 0) {
      return null;
    }

    const execution = result.rows[0];

    // Filter out null steps
    const validSteps = execution.steps.filter(
      (step: ExecutionStep) => step.id !== null
    );

    return {
      ...execution,
      steps: validSteps,
    };
  } catch (error) {
    console.error("Failed to get execution with steps:", error);
    throw new Error("Failed to get execution");
  }
}

/**
 * Get latest execution for an automation
 */
export async function getLatestExecution(
  automationId: string
): Promise<Execution | null> {
  try {
    const result = await pool.query(
      `SELECT id, status, started_at, completed_at, created_at 
       FROM automation_executions 
       WHERE automation_id = $1 
       ORDER BY created_at DESC 
       LIMIT 1`,
      [automationId]
    );

    if (result.rows.length === 0) {
      return null;
    }

    return result.rows[0];
  } catch (error) {
    console.error("Failed to get latest execution:", error);
    throw new Error("Failed to get latest execution");
  }
}

export { pool };

// ============================================
// EXECUTION ENGINE DATABASE OPERATIONS
// ============================================

export interface WorkflowExecution {
  id: string;
  workflow_id: string;
  status: string;
  started_at: string | null;
  completed_at: string | null;
  error_message: string | null;
  created_at: string;
  nodes: Record<string, unknown>[];
  edges: Record<string, unknown>[];
  workflow_name: string;
}

/**
 * Get execution with workflow data by execution ID
 */
export async function getExecutionWithWorkflow(
  executionId: string
): Promise<WorkflowExecution | null> {
  try {
    const executionQuery = `
      SELECT we.*, w.nodes, w.edges, w.id as workflow_id, w.name as workflow_name
      FROM automation_executions we 
      JOIN automations w ON we.automation_id = w.id 
      WHERE we.id = $1
    `;
    const result = await pool.query(executionQuery, [executionId]);

    if (result.rows.length === 0) {
      return null;
    }

    return result.rows[0];
  } catch (error) {
    console.error("Failed to get execution with workflow:", error);
    throw new Error("Failed to get execution with workflow");
  }
}

/**
 * Update execution status to running
 */
export async function updateExecutionToRunning(
  executionId: string
): Promise<void> {
  try {
    await pool.query(
      "UPDATE automation_executions SET status = $1, started_at = NOW() WHERE id = $2",
      ["running", executionId]
    );
  } catch (error) {
    console.error("Failed to update execution to running:", error);
    throw new Error("Failed to update execution status");
  }
}

/**
 * Update execution status to completed
 */
export async function updateExecutionToCompleted(
  executionId: string
): Promise<void> {
  try {
    await pool.query(
      "UPDATE automation_executions SET status = $1, completed_at = NOW() WHERE id = $2",
      ["completed", executionId]
    );
  } catch (error) {
    console.error("Failed to update execution to completed:", error);
    throw new Error("Failed to update execution status");
  }
}

/**
 * Update execution status to failed
 */
export async function updateExecutionToFailed(
  executionId: string,
  errorMessage: string
): Promise<void> {
  try {
    await pool.query(
      "UPDATE automation_executions SET status = $1, completed_at = NOW(), error_message = $2 WHERE id = $3",
      ["failed", errorMessage, executionId]
    );
  } catch (error) {
    console.error("Failed to update execution to failed:", error);
    throw new Error("Failed to update execution status");
  }
}

/**
 * Create execution step record
 */
export async function createExecutionStep(
  executionId: string,
  nodeId: string
): Promise<string> {
  try {
    const stepResult = await pool.query(
      "INSERT INTO execution_steps (execution_id, node_id, status) VALUES ($1, $2, $3) RETURNING *",
      [executionId, nodeId, "pending"]
    );
    return stepResult.rows[0].id;
  } catch (error) {
    console.error("Failed to create execution step:", error);
    throw new Error("Failed to create execution step");
  }
}

/**
 * Update execution step to running
 */
export async function updateExecutionStepToRunning(
  stepId: string
): Promise<void> {
  try {
    await pool.query(
      "UPDATE execution_steps SET status = $1, started_at = NOW() WHERE id = $2",
      ["running", stepId]
    );
  } catch (error) {
    console.error("Failed to update execution step to running:", error);
    throw new Error("Failed to update execution step");
  }
}

/**
 * Update execution step to completed
 */
export async function updateExecutionStepToCompleted(
  stepId: string,
  result: unknown
): Promise<void> {
  try {
    await pool.query(
      "UPDATE execution_steps SET status = $1, completed_at = NOW(), result = $2 WHERE id = $3",
      ["completed", JSON.stringify(result), stepId]
    );
  } catch (error) {
    console.error("Failed to update execution step to completed:", error);
    throw new Error("Failed to update execution step");
  }
}

/**
 * Update execution step to failed
 */
export async function updateExecutionStepToFailed(
  stepId: string,
  errorMessage: string
): Promise<void> {
  try {
    await pool.query(
      "UPDATE execution_steps SET status = $1, completed_at = NOW(), error_message = $2 WHERE id = $3",
      ["failed", errorMessage, stepId]
    );
  } catch (error) {
    console.error("Failed to update execution step to failed:", error);
    throw new Error("Failed to update execution step");
  }
}

/**
 * Get next pending execution for processing
 */
export async function getNextPendingExecution(): Promise<string | null> {
  try {
    const result = await pool.query(
      "SELECT id FROM automation_executions WHERE status = 'pending' ORDER BY created_at ASC LIMIT 1"
    );

    if (result.rows.length === 0) {
      return null;
    }

    return result.rows[0].id;
  } catch (error) {
    console.error("Failed to get next pending execution:", error);
    throw new Error("Failed to get next pending execution");
  }
}

----- Content End -----

===== File: lib/integrations/utils.ts =====
Type: .ts
----- Content Start -----
// ============================================
// INTEGRATION FACTORY FUNCTION
// ============================================

import type { Integration, IntegrationSchema, SchemaField } from "./types";

export const createIntegration = (
  config: Omit<
    Integration,
    "colorClass" | "borderClass" | "selectedBorderClass"
  >
): Integration => {
  const categoryStyles = getCategoryStyles(config.category);

  return {
    ...config,
    ...categoryStyles,
  };
};

export const createCustomIntegration = (
  config: Omit<Integration, "version"> & { version?: string }
): Integration => {
  const categoryStyles = getCategoryStyles(config.category);

  return {
    version: "1.0.0",
    ...config,
    ...categoryStyles,
  };
};

export const createIntegrationSchema = (
  fields: SchemaField[],
  required: string[] = [],
  dependencies?: Record<string, string[]>
): IntegrationSchema => ({
  fields,
  required,
  dependencies,
});

export const createSchemaField = (config: SchemaField): SchemaField => config;

// ============================================
// CATEGORY-BASED STYLING
// ============================================

export const getCategoryStyles = (category: "trigger" | "action" | "logic") => {
  const styles = {
    trigger: {
      colorClass: "text-amber-600 dark:text-amber-400",
      borderClass:
        "border-amber-200 dark:border-amber-800 hover:border-amber-300 dark:hover:border-amber-700",
      selectedBorderClass:
        "border-amber-600 dark:border-amber-400 shadow-lg ring-1 ring-amber-500/20 dark:ring-amber-400/20",
    },
    action: {
      colorClass: "text-sky-600 dark:text-sky-400",
      borderClass:
        "border-sky-200 dark:border-sky-800 hover:border-sky-300 dark:hover:border-sky-700",
      selectedBorderClass:
        "border-sky-600 dark:border-sky-400 shadow-lg ring-1 ring-sky-500/20 dark:ring-sky-400/20",
    },
    logic: {
      colorClass: "text-violet-600 dark:text-violet-400",
      borderClass:
        "border-violet-200 dark:border-violet-800 hover:border-violet-300 dark:hover:border-violet-700",
      selectedBorderClass:
        "border-violet-600 dark:border-violet-400 shadow-lg ring-1 ring-violet-500/20 dark:ring-violet-400/20",
    },
  };

  return styles[category];
};

// ============================================
// RUNTIME VALIDATION HELPER
// ============================================

export function validateIntegrationOutput(
  integrationId: string,
  result: { success: boolean; data?: Record<string, unknown> }
): boolean {
  if (!result.success) return true; // Don't validate failed executions

  const data = result.data;
  if (!data) return false;

  // Basic validation - ensure timestamp exists
  if (!data.timestamp || typeof data.timestamp !== "string") {
    console.warn(
      `Integration ${integrationId} missing required timestamp field`
    );
    return false;
  }

  return true;
}

----- Content End -----

===== File: lib/integrations/templates.ts =====
Type: .ts
----- Content Start -----
export interface WorkflowTemplate {
  id: string;
  name: string;
  description: string;
  icon: string;
  nodes: Array<{
    id: string;
    type: string;
    position: { x: number; y: number };
    data: {
      label: string;
      subtype: string;
      icon: string;
      description: string;
      config?: Record<string, unknown>;
      colorClass?: string;
      borderClass?: string;
      selectedBorderClass?: string;
    };
  }>;
  edges: Array<{
    id: string;
    source: string;
    target: string;
    sourceHandle?: string;
  }>;
}

export const workflowTemplates: WorkflowTemplate[] = [
  {
    id: "manual-slack-notification",
    name: "Manual ‚Üí Slack",
    description: "Manually trigger and send Slack notification",
    icon: "play",
    nodes: [
      {
        id: "manual-1",
        type: "trigger",
        position: { x: 100, y: 100 },
        data: {
          label: "Manual Trigger",
          subtype: "manual_trigger",
          icon: "play",
          description: "Trigger workflow manually",
          colorClass: "text-amber-600 dark:text-amber-400",
          borderClass: "border-amber-200 dark:border-amber-800",
          selectedBorderClass: "border-amber-600 dark:border-amber-400",
        },
      },
      {
        id: "slack-1",
        type: "action",
        position: { x: 400, y: 100 },
        data: {
          label: "Send Slack Message",
          subtype: "slack_send_message",
          icon: "message-square",
          description: "Send a message to a Slack channel",
          config: {
            channel: "general",
            message:
              "Manual trigger activated! Workflow executed successfully.",
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },
    ],
    edges: [
      {
        id: "e1",
        source: "manual-1",
        target: "slack-1",
      },
    ],
  },
  {
    id: "schedule-email-reminder",
    name: "Daily Email Reminder",
    description: "Send scheduled email reminders",
    icon: "calendar",
    nodes: [
      {
        id: "schedule-1",
        type: "trigger",
        position: { x: 100, y: 100 },
        data: {
          label: "Schedule",
          subtype: "schedule_trigger",
          icon: "clock",
          description: "Run on a schedule",
          config: {
            schedule: "0 9 * * *", // 9 AM daily
            timezone: "UTC",
          },
          colorClass: "text-amber-600 dark:text-amber-400",
          borderClass: "border-amber-200 dark:border-amber-800",
          selectedBorderClass: "border-amber-600 dark:border-amber-400",
        },
      },
      {
        id: "email-1",
        type: "action",
        position: { x: 400, y: 100 },
        data: {
          label: "Send Email",
          subtype: "email_send",
          icon: "mail",
          description: "Send an email message",
          config: {
            to: "team@company.com",
            subject: "Daily Reminder",
            body: "Don't forget to check your tasks for today!",
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },
    ],
    edges: [
      {
        id: "e1",
        source: "schedule-1",
        target: "email-1",
      },
    ],
  },
  {
    id: "webhook-filter-slack",
    name: "Webhook ‚Üí Filter ‚Üí Slack",
    description: "Filter webhook data before sending to Slack",
    icon: "workflow",
    nodes: [
      {
        id: "webhook-1",
        type: "trigger",
        position: { x: 50, y: 100 },
        data: {
          label: "Webhook",
          subtype: "webhook_trigger",
          icon: "link",
          description: "Receive HTTP requests",
          colorClass: "text-amber-600 dark:text-amber-400",
          borderClass: "border-amber-200 dark:border-amber-800",
          selectedBorderClass: "border-amber-600 dark:border-amber-400",
        },
      },
      {
        id: "filter-1",
        type: "logic",
        position: { x: 300, y: 100 },
        data: {
          label: "Filter",
          subtype: "filter_condition",
          icon: "search",
          description: "Filter data conditionally",
          config: {
            field: "{{$node.webhook-1.data.body.status}}",
            operator: "equals",
            value: "active",
          },
          colorClass: "text-violet-600 dark:text-violet-400",
          borderClass: "border-violet-200 dark:border-violet-800",
          selectedBorderClass: "border-violet-600 dark:border-violet-400",
        },
      },
      {
        id: "slack-1",
        type: "action",
        position: { x: 550, y: 100 },
        data: {
          label: "Send Slack Message",
          subtype: "slack_send_message",
          icon: "message-square",
          description: "Send a message to a Slack channel",
          config: {
            channel: "alerts",
            message:
              "Active status detected: {{$node.webhook-1.data.body.message}}",
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },
    ],
    edges: [
      {
        id: "e1",
        source: "webhook-1",
        target: "filter-1",
      },
      {
        id: "e2",
        source: "filter-1",
        target: "slack-1",
      },
    ],
  },
  {
    id: "complex-data-processing",
    name: "Data Processing Pipeline",
    description:
      "Manual trigger ‚Üí Variable storage ‚Üí Data transformation ‚Üí AI processing ‚Üí Conditional branching ‚Üí Multiple notifications",
    icon: "workflow",
    nodes: [
      // Manual Trigger
      {
        id: "trigger-1",
        type: "trigger",
        position: { x: 50, y: 200 },
        data: {
          label: "Manual Trigger",
          subtype: "manual_trigger",
          icon: "hand",
          description: "Start the data processing pipeline",
          config: {
            triggerName: "Data Processing Pipeline",
          },
          colorClass: "text-amber-600 dark:text-amber-400",
          borderClass: "border-amber-200 dark:border-amber-800",
          selectedBorderClass: "border-amber-600 dark:border-amber-400",
        },
      },

      // Set Variable - Store initial data
      {
        id: "var-1",
        type: "action",
        position: { x: 300, y: 200 },
        data: {
          label: "Store User Data",
          subtype: "set_variable",
          icon: "database",
          description: "Store user information in variable",
          config: {
            variableName: "userData",
            value: {
              userId: 12345,
              name: "John Doe",
              email: "john.doe@example.com",
              department: "Engineering",
              priority: "high",
            },
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },

      // API Request - Fetch additional data
      {
        id: "api-1",
        type: "action",
        position: { x: 550, y: 200 },
        data: {
          label: "Fetch User Profile",
          subtype: "api_request",
          icon: "globe",
          description: "Get detailed user profile from API",
          config: {
            url: "https://jsonplaceholder.typicode.com/users/1",
            method: "GET",
            headers: '{"Authorization": "Bearer token123"}',
            body: '{"user_id": "{{$vars.userData}}"}',
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },

      // Transform Data - Process the API response
      {
        id: "transform-1",
        type: "logic",
        position: { x: 800, y: 200 },
        data: {
          label: "Process Profile Data",
          subtype: "transform_data",
          icon: "brain",
          description: "Transform and format user profile data",
          config: {
            inputData: "{{$node.api-1.data.response}}",
            transformation: "format_json",
            fieldPath: "email",
          },
          colorClass: "text-violet-600 dark:text-violet-400",
          borderClass: "border-violet-200 dark:border-violet-800",
          selectedBorderClass: "border-violet-600 dark:border-violet-400",
        },
      },

      // Set Variable - Store processed data
      {
        id: "var-2",
        type: "action",
        position: { x: 1050, y: 200 },
        data: {
          label: "Store Processed Data",
          subtype: "set_variable",
          icon: "database",
          description: "Save processed user profile",
          config: {
            variableName: "processedProfile",
            value: "{{$node.transform-1.data.result}}",
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },

      // AI Processing - Generate summary
      {
        id: "ai-1",
        type: "action",
        position: { x: 1300, y: 200 },
        data: {
          label: "Generate AI Summary",
          subtype: "ai",
          icon: "brain",
          description: "Create AI-generated user summary",
          config: {
            ai_mode: "llm",
            model: "gpt-4",
            prompt:
              "Create a professional summary for user: {{$vars.processedProfile}}. Focus on their role and key attributes.",
            max_tokens: 200,
            temperature: 0.7,
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },

      // Branch Condition - Check priority level
      {
        id: "branch-1",
        type: "logic",
        position: { x: 1550, y: 200 },
        data: {
          label: "Check Priority",
          subtype: "branch_condition",
          icon: "diamond",
          description: "Branch based on user priority level",
          config: {
            condition: "{{$vars.userData.priority}} === 'high'",
            trueLabel: "High Priority Path",
            falseLabel: "Standard Priority Path",
          },
          colorClass: "text-violet-600 dark:text-violet-400",
          borderClass: "border-violet-200 dark:border-violet-800",
          selectedBorderClass: "border-violet-600 dark:border-violet-400",
        },
      },

      // High Priority Path - Immediate Slack notification
      {
        id: "slack-high",
        type: "action",
        position: { x: 1400, y: 50 },
        data: {
          label: "Urgent Slack Alert",
          subtype: "slack_send_message",
          icon: "message-square",
          description: "Send urgent notification to Slack",
          config: {
            channel: "urgent-alerts",
            message:
              "üö® HIGH PRIORITY USER PROCESSED üö®\n\nUser: {{$vars.userData.name}}\nDepartment: {{$vars.userData.department}}\n\nAI Summary:\n{{$node.ai-1.data.text}}\n\nProcessed at: {{$node.trigger-1.data.timestamp}}",
            username: "UrgentBot",
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },

      // Standard Priority Path - Regular email
      {
        id: "email-standard",
        type: "action",
        position: { x: 1700, y: 350 },
        data: {
          label: "Standard Email Report",
          subtype: "email_send",
          icon: "mail",
          description: "Send standard email report",
          config: {
            to: "admin@company.com",
            subject: "User Profile Processed - {{$vars.userData.name}}",
            body: "Hello Admin,\n\nA user profile has been processed:\n\nUser Details:\n- Name: {{$vars.userData.name}}\n- Email: {{$vars.userData.email}}\n- Department: {{$vars.userData.department}}\n\nAI Generated Summary:\n{{$node.ai-1.data.text}}\n\nProcessed Data:\n{{$vars.processedProfile}}\n\nBest regards,\nAutomation System",
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },

      // Delay before final notification
      {
        id: "delay-1",
        type: "action",
        position: { x: 1800, y: 200 },
        data: {
          label: "Wait 30 seconds",
          subtype: "delay",
          icon: "clock",
          description: "Brief delay before final notification",
          config: {
            amount: 30,
            unit: "seconds",
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },

      // Final API request - Log completion
      {
        id: "api-final",
        type: "action",
        position: { x: 2050, y: 200 },
        data: {
          label: "Log Completion",
          subtype: "api_request",
          icon: "globe",
          description: "Log pipeline completion to external system",
          config: {
            url: "https://api.example.com/logs",
            method: "POST",
            headers:
              '{"Content-Type": "application/json", "Authorization": "Bearer {{$vars.apiToken}}"}',
            body: JSON.stringify({
              event: "pipeline_completed",
              user_id: "{{$vars.userData.userId}}",
              user_name: "{{$vars.userData.name}}",
              priority: "{{$vars.userData.priority}}",
              ai_summary: "{{$node.ai-1.data.text}}",
              completion_time: "{{$node.delay-1.data.timestamp}}",
              notifications_sent: {
                slack: "{{$node.slack-high.data.messageId}}",
                email: "{{$node.email-standard.data.messageId}}",
              },
            }),
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },
    ],
    edges: [
      // Main flow
      { id: "e1", source: "trigger-1", target: "var-1" },
      { id: "e2", source: "var-1", target: "api-1" },
      { id: "e3", source: "api-1", target: "transform-1" },
      { id: "e4", source: "transform-1", target: "var-2" },
      { id: "e5", source: "var-2", target: "ai-1" },
      { id: "e6", source: "ai-1", target: "branch-1" },

      // Branch paths with conditional handles
      {
        id: "e7",
        source: "branch-1",
        sourceHandle: "true",
        target: "slack-high",
      },
      {
        id: "e8",
        source: "branch-1",
        sourceHandle: "false",
        target: "email-standard",
      },

      // Convergence to delay (both paths lead here)
      { id: "e9", source: "slack-high", target: "delay-1" },
      { id: "e10", source: "email-standard", target: "delay-1" },

      // Final step
      { id: "e11", source: "delay-1", target: "api-final" },
    ],
  },
];

----- Content End -----

===== File: lib/integrations/types.ts =====
Type: .ts
----- Content Start -----
// ============================================
// TYPE DEFINITIONS
// ============================================

export interface WorkflowContext {
  variables: Record<string, unknown>;
  nodeOutputs: Record<string, unknown>;
  executionId: string;
  userId?: string;
}

export interface IntegrationSchema {
  fields: SchemaField[];
  required: string[];
  dependencies?: Record<string, string[]>;
}

export interface SchemaField {
  key: string;
  type: "text" | "textarea" | "select" | "number" | "boolean" | "email" | "url";
  label: string;
  placeholder?: string;
  required?: boolean;
  supportExpressions?: boolean;
  options?:
    | Array<{ label: string; value: string }>
    | (() => Promise<Array<{ label: string; value: string }>>);
  validation?: (value: unknown) => string | null;
  dependsOn?: string;
}

export interface IntegrationExecutor {
  execute: (
    config: Record<string, unknown>,
    context: WorkflowContext
  ) => Promise<ExecutionResult>;
  validate?: (config: Record<string, unknown>) => ValidationResult;
}

export interface ExecutionResult extends Record<string, unknown> {
  success: boolean;
  data?: Record<string, unknown>;
  error?: string;
  metadata?: {
    nodeType: string;
    subtype: string;
    executionTime?: number;
    [key: string]: unknown;
  };
}

export interface ValidationResult {
  valid: boolean;
  errors: Record<string, string>;
}

export interface Integration {
  id: string;
  name: string;
  category: "trigger" | "action" | "logic";
  description: string;
  icon: string;
  version: string;

  // Visual styling (auto-generated based on category)
  colorClass?: string;
  borderClass?: string;
  selectedBorderClass?: string;

  // Integration logic
  schema: IntegrationSchema;
  executor: IntegrationExecutor;

  // Optional features
  auth?: {
    type: "oauth2" | "api_key" | "basic" | "none";
    required: boolean;
  };

  // For triggers only
  hasInputHandle?: boolean;
}

----- Content End -----

===== File: lib/integrations/registry.ts =====
Type: .ts
----- Content Start -----
import type {
  Integration,
  WorkflowContext,
  ExecutionResult,
  ValidationResult,
} from "./types";
import { validateIntegrationOutput } from "./utils";
import { parseExpression } from "../expression";

// Import all integrations
import { manualTrigger } from "./triggers/manual-trigger";
import { webhookTrigger } from "./triggers/webhook-trigger";
import { scheduleTrigger } from "./triggers/schedule-trigger";

// New Triggers
import { emailTrigger } from "./triggers/email-trigger";
import { formTrigger } from "./triggers/form-trigger";
import { databaseTrigger } from "./triggers/database-trigger";
import { fileWatcherTrigger } from "./triggers/file-watcher-trigger";
import { slackSendMessage } from "./actions/slack-send-message";
import { setVariable } from "./actions/set-variable";
import { emailSend } from "./actions/email-send";
import { apiRequest } from "./actions/api-request";
import { delay } from "./actions/delay";
import { aiIntegration } from "./actions/ai";
import { filterCondition } from "./logic/filter-condition";
import { branchCondition } from "./logic/branch-condition";
import { transformData } from "./logic/transform-data";

// New Logic Nodes
import { iteratorLoop } from "./logic/iterator-loop";
import { switchCase } from "./logic/switch-case";
import { dataValidator } from "./logic/data-validator";
import { aggregator } from "./logic/aggregator";
import { router } from "./logic/router";

// Communication & Messaging
import { discordSendMessage } from "./actions/discord-send-message";
import { teamsSendMessage } from "./actions/teams-send-message";
import { telegramSendMessage } from "./actions/telegram-send-message";

// Databases & Storage
import { postgresInsert } from "./actions/postgres-insert";
import { sheetsAppendRow } from "./actions/sheets-append-row";
import { airtableCreateRecord } from "./actions/airtable-create-record";
import { googleSheetsAppend } from "./actions/google-sheets-append";
import { databaseInsert } from "./actions/database-insert";
import { databaseSelect } from "./actions/database-select";

// Payments & Finance
import { stripeCreatePayment } from "./actions/stripe-create-payment";
import { paypalSendPayment } from "./actions/paypal-send-payment";

// CRM & Sales
import { hubspotCreateContact } from "./actions/hubspot-create-contact";
import { salesforceCreateLead } from "./actions/salesforce-create-lead";

// Project Management
import { asanaCreateTask } from "./actions/asana-create-task";
import { trelloCreateCard } from "./actions/trello-create-card";

// Cloud Storage
import { s3UploadFile } from "./actions/s3-upload-file";
import { driveUploadFile } from "./actions/drive-upload-file";

// Email Marketing
import { mailchimpAddSubscriber } from "./actions/mailchimp-add-subscriber";
import { sendgridSendEmail } from "./actions/sendgrid-send-email";

// Social Media
import { twitterPostTweet } from "./actions/twitter-post-tweet";
import { linkedinCreatePost } from "./actions/linkedin-create-post";

// Development Tools
import { githubCreateIssue } from "./actions/github-create-issue";
import { jiraCreateIssue } from "./actions/jira-create-issue";

// Business Tools
import { zoomCreateMeeting } from "./actions/zoom-create-meeting";
import { notionCreatePage } from "./actions/notion-create-page";

// Additional Integrations
import { smsSend } from "./actions/sms-send";
import { redisSet } from "./actions/redis-set";
import { cloudinaryUploadImage } from "./actions/cloudinary-upload-image";

// ============================================
// INTEGRATION REGISTRY CLASS
// ============================================

class IntegrationRegistry {
  private integrations = new Map<string, Integration>();

  constructor() {
    // Register all integrations
    this.registerIntegrations([
      // Triggers
      manualTrigger,
      webhookTrigger,
      scheduleTrigger,
      emailTrigger,
      formTrigger,
      databaseTrigger,
      fileWatcherTrigger,

      // Actions
      slackSendMessage,
      setVariable,
      emailSend,
      apiRequest,
      delay,
      aiIntegration,

      // Communication & Messaging
      discordSendMessage,
      teamsSendMessage,
      telegramSendMessage,

      // Databases & Storage
      postgresInsert,
      sheetsAppendRow,
      airtableCreateRecord,
      googleSheetsAppend,
      databaseInsert,
      databaseSelect,

      // Payments & Finance
      stripeCreatePayment,
      paypalSendPayment,

      // CRM & Sales
      hubspotCreateContact,
      salesforceCreateLead,

      // Project Management
      asanaCreateTask,
      trelloCreateCard,

      // Cloud Storage
      s3UploadFile,
      driveUploadFile,

      // Email Marketing
      mailchimpAddSubscriber,
      sendgridSendEmail,

      // Social Media
      twitterPostTweet,
      linkedinCreatePost,

      // Development Tools
      githubCreateIssue,
      jiraCreateIssue,

      // Business Tools
      zoomCreateMeeting,
      notionCreatePage,

      // Additional Integrations
      smsSend,
      redisSet,
      cloudinaryUploadImage,

      // Logic
      filterCondition,
      branchCondition,
      transformData,
      iteratorLoop,
      switchCase,
      dataValidator,
      aggregator,
      router,
    ]);
  }

  private registerIntegrations(integrations: Integration[]) {
    integrations.forEach((integration) => {
      this.integrations.set(integration.id, integration);
    });
  }

  register(integration: Integration) {
    this.integrations.set(integration.id, integration);
  }

  unregister(id: string) {
    return this.integrations.delete(id);
  }

  get(id: string): Integration | undefined {
    return this.integrations.get(id);
  }

  getByCategory(category: "trigger" | "action" | "logic"): Integration[] {
    return Array.from(this.integrations.values()).filter(
      (integration) => integration.category === category
    );
  }

  getAll(): Integration[] {
    return Array.from(this.integrations.values());
  }

  getTriggers(): Integration[] {
    return this.getByCategory("trigger");
  }

  getActions(): Integration[] {
    return this.getByCategory("action");
  }

  getLogic(): Integration[] {
    return this.getByCategory("logic");
  }

  // Search integrations by name, description, or category
  search(query: string): Integration[] {
    const lowercaseQuery = query.toLowerCase();
    return Array.from(this.integrations.values()).filter(
      (integration) =>
        integration.name.toLowerCase().includes(lowercaseQuery) ||
        integration.description.toLowerCase().includes(lowercaseQuery) ||
        integration.category.toLowerCase().includes(lowercaseQuery)
    );
  }

  // Get integrations with auth requirements
  getAuthRequired(): Integration[] {
    return Array.from(this.integrations.values()).filter(
      (integration) => integration.auth?.required
    );
  }

  // Get integrations by version
  getByVersion(version: string): Integration[] {
    return Array.from(this.integrations.values()).filter(
      (integration) => integration.version === version
    );
  }

  // Validate integration configuration
  validateConfig(
    integrationId: string,
    config: Record<string, unknown>
  ): ValidationResult {
    const integration = this.get(integrationId);
    if (!integration) {
      return {
        valid: false,
        errors: { integration: "Integration not found" },
      };
    }

    if (integration.executor.validate) {
      return integration.executor.validate(config);
    }

    // Basic validation based on schema
    const errors: Record<string, string> = {};
    integration.schema.required.forEach((field) => {
      if (!config[field]) {
        errors[field] = `${field} is required`;
      }
    });

    // Field-level validation
    integration.schema.fields.forEach((field) => {
      const value = config[field.key];
      if (field.validation && value !== undefined) {
        const validationError = field.validation(value);
        if (validationError) {
          errors[field.key] = validationError;
        }
      }
    });

    return {
      valid: Object.keys(errors).length === 0,
      errors,
    };
  }

  // Execute an integration
  async executeIntegration(
    integrationId: string,
    config: Record<string, unknown>,
    context: WorkflowContext
  ): Promise<ExecutionResult> {
    const integration = this.get(integrationId);
    if (!integration) {
      return {
        success: false,
        error: `Integration '${integrationId}' not found`,
        metadata: {
          nodeType: "unknown",
          subtype: integrationId,
        },
      };
    }

    // ----  NEW: interpolate expressions inside config (repeat until stable) ----
    const hydrate = (value: unknown): unknown => {
      const seen = new Set<string>();
      let out: unknown = value;
      while (typeof out === "string" && !seen.has(out)) {
        seen.add(out);
        // Branch-condition needs strings to be quoted _inside_ the JS expression
        const quote = integration.id === "branch_condition";
        out = parseExpression(out, context, quote);
      }
      if (Array.isArray(out)) return out.map(hydrate);
      if (out && typeof out === "object" && out !== null)
        return Object.fromEntries(
          Object.entries(out as Record<string, unknown>).map(([k, v]) => [
            k,
            hydrate(v),
          ])
        );
      return out;
    };
    const interpolatedConfig = hydrate(config) as Record<string, unknown>;

    try {
      const startTime = Date.now();
      const result = await integration.executor.execute(
        interpolatedConfig,
        context
      );
      const executionTime = Date.now() - startTime;

      // Add execution time to metadata
      if (result.metadata) {
        result.metadata.executionTime = executionTime;
      }

      // Validate output schema
      if (!validateIntegrationOutput(integrationId, result)) {
        console.warn(
          `Integration ${integrationId} returned invalid output schema`
        );
      }

      return result;
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
        metadata: {
          nodeType: integration.category,
          subtype: integrationId,
        },
      };
    }
  }

  // Get integration statistics
  getStats() {
    const integrations = this.getAll();
    return {
      total: integrations.length,
      triggers: this.getTriggers().length,
      actions: this.getActions().length,
      logic: this.getLogic().length,
      withAuth: this.getAuthRequired().length,
    };
  }
}

// Create and export the global registry instance
export const integrationRegistry = new IntegrationRegistry();

// Export the registry class for advanced usage
export { IntegrationRegistry };

----- Content End -----

===== File: lib/integrations/triggers/schedule-trigger.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from '../utils';
import type { Integration } from '../types';

export const scheduleTrigger: Integration = createIntegration({
  id: "schedule_trigger",
  name: "Schedule",
  category: "trigger",
  description: "Run on a schedule",
  icon: "clock",
  version: "1.0.0",

  hasInputHandle: false,

  schema: {
    fields: [
      {
        key: "schedule",
        type: "select",
        label: "Schedule",
        required: true,
        options: [
          { label: "Every minute", value: "* * * * *" },
          { label: "Every hour", value: "0 * * * *" },
          { label: "Every day", value: "0 0 * * *" },
          { label: "Every week", value: "0 0 * * 0" },
        ],
      },
      {
        key: "timezone",
        type: "select",
        label: "Timezone",
        required: false,
        options: [
          { label: "UTC", value: "UTC" },
          { label: "America/New_York", value: "America/New_York" },
          { label: "America/Los_Angeles", value: "America/Los_Angeles" },
        ],
      },
    ],
    required: ["schedule"],
  },

  executor: {
    async execute(config) {
      const timestamp = new Date().toISOString();
      return {
        success: true,
        data: {
          schedule: config.schedule as string,
          timezone: (config.timezone as string) || "UTC",
          timestamp,
        },
        metadata: { nodeType: "trigger", subtype: "schedule_trigger" },
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/triggers/file-watcher-trigger.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const fileWatcherTrigger: Integration = createIntegration({
  id: "file_watcher_trigger",
  name: "File Watcher",
  category: "trigger",
  description: "Trigger when files are created, modified, or deleted",
  icon: "file-search",
  version: "1.0.0",
  
  hasInputHandle: false,
  
  schema: {
    fields: [
      {
        key: "path",
        type: "text",
        label: "Directory Path",
        placeholder: "/uploads/ or C:\\uploads\\",
        required: true,
      },
      {
        key: "events",
        type: "select",
        label: "Watch Events",
        required: true,
        options: [
          { label: "Created", value: "created" },
          { label: "Modified", value: "modified" },
          { label: "Deleted", value: "deleted" },
          { label: "All Events", value: "all" },
        ],
      },
      {
        key: "file_pattern",
        type: "text",
        label: "File Pattern (regex)",
        placeholder: ".*\\.csv$ or .*\\.(jpg|png|gif)$",
        required: false,
      },
      {
        key: "recursive",
        type: "boolean",
        label: "Watch Subdirectories",
        required: false,
      },
      {
        key: "include_file_info",
        type: "boolean",
        label: "Include File Information",
        required: false,
      },
      {
        key: "max_file_size",
        type: "number",
        label: "Max File Size (MB)",
        placeholder: "100",
        required: false,
      },
      {
        key: "ignore_patterns",
        type: "textarea",
        label: "Ignore Patterns (JSON array)",
        placeholder: '["*.tmp", "*.log", ".DS_Store"]',
        required: false,
        validation: (value: unknown) => {
          if (!value) return null;
          if (typeof value !== "string") {
            return "Ignore patterns must be a JSON string";
          }
          try {
            const parsed = JSON.parse(value);
            if (!Array.isArray(parsed)) {
              return "Ignore patterns must be a JSON array";
            }
            return null;
          } catch (e) {
            return "Invalid JSON format";
          }
        },
      },
    ],
    required: ["path", "events"],
  },

  executor: {
    async execute(config) {
      // Simulate file watching delay
      await new Promise((resolve) => setTimeout(resolve, 600));
      
      const path = config.path as string;
      const events = config.events as string;
      const filePattern = config.file_pattern as string;
      const recursive = config.recursive as boolean || false;
      const includeFileInfo = config.include_file_info as boolean || false;
      const maxFileSize = (config.max_file_size as number) || 100;
      
      let ignorePatterns: string[] = [];
      if (config.ignore_patterns) {
        try {
          ignorePatterns = JSON.parse(config.ignore_patterns as string);
        } catch (e) {
          return {
            success: false,
            error: "Invalid ignore patterns JSON format",
            data: {
              timestamp: new Date().toISOString(),
            },
            metadata: { nodeType: "trigger", subtype: "file_watcher_trigger" },
          };
        }
      }

      // Mock file events
      const mockFileEvents = [
        {
          event_type: "created",
          file_path: path + "data_2024_01_15.csv",
          file_name: "data_2024_01_15.csv",
          file_size: 1024000, // 1MB
          file_extension: ".csv",
          modified_time: new Date().toISOString(),
          created_time: new Date().toISOString(),
          is_directory: false,
          relative_path: "data_2024_01_15.csv",
          absolute_path: path + "data_2024_01_15.csv",
          file_info: includeFileInfo ? {
            permissions: "rw-r--r--",
            owner: "user",
            group: "users",
            inode: 12345,
            device: 1,
            hard_links: 1,
            access_time: new Date().toISOString(),
            change_time: new Date().toISOString(),
          } : null,
        },
        {
          event_type: "modified",
          file_path: path + "config.json",
          file_name: "config.json",
          file_size: 2048,
          file_extension: ".json",
          modified_time: new Date().toISOString(),
          created_time: new Date(Date.now() - 86400000).toISOString(), // 1 day ago
          is_directory: false,
          relative_path: "config.json",
          absolute_path: path + "config.json",
          file_info: includeFileInfo ? {
            permissions: "rw-r--r--",
            owner: "user",
            group: "users",
            inode: 12346,
            device: 1,
            hard_links: 1,
            access_time: new Date().toISOString(),
            change_time: new Date().toISOString(),
          } : null,
        },
        {
          event_type: "created",
          file_path: path + "images/logo.png",
          file_name: "logo.png",
          file_size: 512000, // 512KB
          file_extension: ".png",
          modified_time: new Date().toISOString(),
          created_time: new Date().toISOString(),
          is_directory: false,
          relative_path: "images/logo.png",
          absolute_path: path + "images/logo.png",
          file_info: includeFileInfo ? {
            permissions: "rw-r--r--",
            owner: "user",
            group: "users",
            inode: 12347,
            device: 1,
            hard_links: 1,
            access_time: new Date().toISOString(),
            change_time: new Date().toISOString(),
          } : null,
        }
      ];

      // Filter events based on events setting
      let filteredEvents = mockFileEvents;
      if (events !== "all") {
        filteredEvents = mockFileEvents.filter(event => event.event_type === events);
      }

      // Apply file pattern filter if specified
      if (filePattern) {
        try {
          const regex = new RegExp(filePattern);
          filteredEvents = filteredEvents.filter(event => regex.test(event.file_name));
        } catch (e) {
          return {
            success: false,
            error: "Invalid file pattern regex",
            data: {
              pattern: filePattern,
              timestamp: new Date().toISOString(),
            },
            metadata: { nodeType: "trigger", subtype: "file_watcher_trigger" },
          };
        }
      }

      // Apply ignore patterns
      if (ignorePatterns.length > 0) {
        filteredEvents = filteredEvents.filter(event => {
          return !ignorePatterns.some(pattern => {
            // Simple glob-like pattern matching
            const regexPattern = pattern
              .replace(/\./g, "\\.")
              .replace(/\*/g, ".*")
              .replace(/\?/g, ".");
            const regex = new RegExp(regexPattern);
            return regex.test(event.file_name);
          });
        });
      }

      // Apply max file size filter
      filteredEvents = filteredEvents.filter(event => {
        const fileSizeMB = event.file_size / (1024 * 1024);
        return fileSizeMB <= maxFileSize;
      });

      // Apply recursive filter
      if (!recursive) {
        filteredEvents = filteredEvents.filter(event => {
          return !event.relative_path.includes("/") && !event.relative_path.includes("\\");
        });
      }

      return {
        success: true,
        data: {
          events: filteredEvents,
          total_events: filteredEvents.length,
          path,
          watch_events: events,
          file_pattern: filePattern || null,
          recursive,
          include_file_info: includeFileInfo,
          max_file_size_mb: maxFileSize,
          ignore_patterns: ignorePatterns.length > 0 ? ignorePatterns : null,
          trigger_time: new Date().toISOString(),
        },
        metadata: { nodeType: "trigger", subtype: "file_watcher_trigger" },
      };
    },

    validate(config) {
      const errors: Record<string, string> = {};

      if (!config.path) {
        errors.path = "Directory path is required";
      } else if (typeof config.path !== "string" || config.path.trim().length === 0) {
        errors.path = "Directory path must be a non-empty string";
      }

      if (!config.events) {
        errors.events = "Watch events are required";
      }

      if (config.file_pattern) {
        try {
          new RegExp(config.file_pattern as string);
        } catch (e) {
          errors.file_pattern = "Invalid file pattern regex";
        }
      }

      if (config.max_file_size && 
          (typeof config.max_file_size !== "number" || config.max_file_size <= 0)) {
        errors.max_file_size = "Max file size must be a positive number";
      }

      if (config.ignore_patterns) {
        try {
          const parsed = JSON.parse(config.ignore_patterns as string);
          if (!Array.isArray(parsed)) {
            errors.ignore_patterns = "Ignore patterns must be a JSON array";
          }
        } catch (e) {
          errors.ignore_patterns = "Invalid JSON format for ignore patterns";
        }
      }

      return {
        valid: Object.keys(errors).length === 0,
        errors,
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/triggers/webhook-trigger.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from '../utils';
import type { Integration } from '../types';

export const webhookTrigger: Integration = createIntegration({
  id: "webhook_trigger",
  name: "Webhook",
  category: "trigger",
  description: "Receive HTTP requests",
  icon: "link",
  version: "1.0.0",

  hasInputHandle: false,

  schema: {
    fields: [
      {
        key: "url",
        type: "url",
        label: "Webhook URL",
        placeholder: "https://...",
        required: true,
      },
      {
        key: "method",
        type: "select",
        label: "HTTP Method",
        required: true,
        options: [
          { label: "POST", value: "POST" },
          { label: "GET", value: "GET" },
          { label: "PUT", value: "PUT" },
        ],
      },
    ],
    required: ["url", "method"],
  },

  executor: {
    async execute() {
      const timestamp = new Date().toISOString();
      return {
        success: true,
        data: {
          method: "POST",
          headers: {
            "content-type": "application/json",
            "user-agent": "GitHub-Hookshot/abc123",
          },
          body: {
            event: "push",
            repository: { name: "my-app", owner: "johndoe" },
            commits: [
              { message: "Fix user login bug", author: "Jane Smith" },
            ],
          },
          timestamp,
        },
        metadata: { nodeType: "trigger", subtype: "webhook_trigger" },
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/triggers/email-trigger.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const emailTrigger: Integration = createIntegration({
  id: "email_trigger",
  name: "Email Received",
  category: "trigger",
  description: "Trigger when emails are received",
  icon: "mail",
  version: "1.0.0",
  
  hasInputHandle: false,
  
  schema: {
    fields: [
      {
        key: "email_address",
        type: "email",
        label: "Monitor Email Address",
        placeholder: "automation@company.com",
        required: true,
      },
      {
        key: "subject_filter",
        type: "text",
        label: "Subject Filter (optional)",
        placeholder: "Order # or [URGENT]",
        required: false,
      },
      {
        key: "sender_filter",
        type: "text",
        label: "Sender Filter (optional)",
        placeholder: "@important-domain.com or specific@email.com",
        required: false,
      },
      {
        key: "include_attachments",
        type: "boolean",
        label: "Include Attachment Info",
        required: false,
      },
      {
        key: "max_emails_per_trigger",
        type: "number",
        label: "Max Emails per Trigger",
        placeholder: "10",
        required: false,
      },
      {
        key: "webhook_url",
        type: "url",
        label: "Webhook URL (generated)",
        placeholder: "https://api.yourapp.com/webhooks/email/xyz123",
        required: false,
      },
    ],
    required: ["email_address"],
  },

  executor: {
    async execute(config) {
      // Simulate email monitoring delay
      await new Promise((resolve) => setTimeout(resolve, 500));
      
      const emailAddress = config.email_address as string;
      const subjectFilter = config.subject_filter as string;
      const senderFilter = config.sender_filter as string;
      const includeAttachments = config.include_attachments as boolean || false;
      const maxEmails = (config.max_emails_per_trigger as number) || 1;

      // Mock email data
      const mockEmails = [
        {
          message_id: "<msg123@gmail.com>",
          from: "customer@example.com",
          to: emailAddress,
          subject: "Order #12345 - Urgent Question",
          body: "Hi, I have a question about my recent order. The delivery date seems to be delayed and I need this resolved quickly. Please let me know the status of my order #12345.",
          received_at: new Date().toISOString(),
          attachments: includeAttachments ? [
            {
              filename: "receipt.pdf",
              size: 45000,
              content_type: "application/pdf",
              content_id: "att_001"
            }
          ] : [],
          headers: {
            "message-id": "<msg123@gmail.com>",
            "date": new Date().toISOString(),
            "from": "customer@example.com",
            "to": emailAddress,
            "subject": "Order #12345 - Urgent Question",
            "content-type": "text/plain; charset=UTF-8"
          }
        },
        {
          message_id: "<msg456@gmail.com>",
          from: "support@important-domain.com",
          to: emailAddress,
          subject: "[URGENT] System Alert",
          body: "Critical system alert: Database connection timeout detected. Immediate attention required.",
          received_at: new Date(Date.now() - 300000).toISOString(), // 5 minutes ago
          attachments: [],
          headers: {
            "message-id": "<msg456@gmail.com>",
            "date": new Date(Date.now() - 300000).toISOString(),
            "from": "support@important-domain.com",
            "to": emailAddress,
            "subject": "[URGENT] System Alert",
            "content-type": "text/plain; charset=UTF-8"
          }
        }
      ];

      // Apply filters
      let filteredEmails = mockEmails;
      
      if (subjectFilter) {
        filteredEmails = filteredEmails.filter(email => 
          email.subject.toLowerCase().includes(subjectFilter.toLowerCase())
        );
      }
      
      if (senderFilter) {
        filteredEmails = filteredEmails.filter(email => 
          email.from.toLowerCase().includes(senderFilter.toLowerCase())
        );
      }

      // Limit to max emails
      filteredEmails = filteredEmails.slice(0, maxEmails);

      return {
        success: true,
        data: {
          emails: filteredEmails,
          total_emails: filteredEmails.length,
          email_address: emailAddress,
          subject_filter: subjectFilter || null,
          sender_filter: senderFilter || null,
          include_attachments: includeAttachments,
          max_emails_per_trigger: maxEmails,
          trigger_time: new Date().toISOString(),
          webhook_url: config.webhook_url || null,
        },
        metadata: { nodeType: "trigger", subtype: "email_trigger" },
      };
    },

    validate(config) {
      const errors: Record<string, string> = {};

      if (!config.email_address) {
        errors.email_address = "Email address is required";
      } else {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(config.email_address as string)) {
          errors.email_address = "Invalid email address format";
        }
      }

      if (config.max_emails_per_trigger && 
          (typeof config.max_emails_per_trigger !== "number" || config.max_emails_per_trigger <= 0)) {
        errors.max_emails_per_trigger = "Max emails must be a positive number";
      }

      return {
        valid: Object.keys(errors).length === 0,
        errors,
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/triggers/database-trigger.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

// Helper function
function matchesColumnFilters(
  values: Record<string, unknown>,
  filters: Record<string, unknown>
): boolean {
  for (const [column, filterValue] of Object.entries(filters)) {
    const value = values[column];

    if (typeof filterValue === "object" && filterValue !== null) {
      // Handle operators like {"$in": ["high", "urgent"]}
      for (const [operator, operatorValue] of Object.entries(filterValue)) {
        switch (operator) {
          case "$in":
            if (
              !Array.isArray(operatorValue) ||
              !operatorValue.includes(value)
            ) {
              return false;
            }
            break;
          case "$nin":
            if (Array.isArray(operatorValue) && operatorValue.includes(value)) {
              return false;
            }
            break;
          case "$gt":
            if (typeof value !== "number" || value <= operatorValue) {
              return false;
            }
            break;
          case "$gte":
            if (typeof value !== "number" || value < operatorValue) {
              return false;
            }
            break;
          case "$lt":
            if (typeof value !== "number" || value >= operatorValue) {
              return false;
            }
            break;
          case "$lte":
            if (typeof value !== "number" || value > operatorValue) {
              return false;
            }
            break;
          case "$eq":
            if (value !== operatorValue) {
              return false;
            }
            break;
          case "$ne":
            if (value === operatorValue) {
              return false;
            }
            break;
          case "$like":
            if (
              typeof value !== "string" ||
              !value.includes(operatorValue as string)
            ) {
              return false;
            }
            break;
        }
      }
    } else {
      // Simple equality check
      if (value !== filterValue) {
        return false;
      }
    }
  }

  return true;
}

export const databaseTrigger: Integration = createIntegration({
  id: "database_trigger",
  name: "Database Change",
  category: "trigger",
  description: "Trigger on database INSERT, UPDATE, or DELETE",
  icon: "database",
  version: "1.0.0",

  hasInputHandle: false,

  schema: {
    fields: [
      {
        key: "connection_string",
        type: "text",
        label: "Database Connection",
        placeholder: "postgresql://user:pass@host:5432/db",
        required: true,
      },
      {
        key: "table_name",
        type: "text",
        label: "Table Name",
        placeholder: "users",
        required: true,
      },
      {
        key: "trigger_events",
        type: "select",
        label: "Trigger Events",
        required: true,
        options: [
          { label: "INSERT", value: "insert" },
          { label: "UPDATE", value: "update" },
          { label: "DELETE", value: "delete" },
          { label: "All Events", value: "all" },
        ],
      },
      {
        key: "column_filters",
        type: "textarea",
        label: "Column Filters (JSON)",
        placeholder:
          '{"status": "active", "priority": {"$in": ["high", "urgent"]}}',
        required: false,
        validation: (value: unknown) => {
          if (!value) return null;
          if (typeof value !== "string") {
            return "Column filters must be a JSON string";
          }
          try {
            JSON.parse(value);
            return null;
          } catch {
            return "Invalid JSON format";
          }
        },
      },
      {
        key: "include_old_values",
        type: "boolean",
        label: "Include Old Values (for UPDATE/DELETE)",
        required: false,
      },
      {
        key: "batch_size",
        type: "number",
        label: "Batch Size",
        placeholder: "100",
        required: false,
      },
    ],
    required: ["connection_string", "table_name", "trigger_events"],
  },

  executor: {
    async execute(config) {
      // Simulate database monitoring delay
      await new Promise((resolve) => setTimeout(resolve, 400));

      const connectionString = config.connection_string as string;
      const tableName = config.table_name as string;
      const triggerEvents = config.trigger_events as string;
      const includeOldValues = (config.include_old_values as boolean) || false;
      const batchSize = (config.batch_size as number) || 100;

      let columnFilters = {};
      if (config.column_filters) {
        try {
          columnFilters = JSON.parse(config.column_filters as string);
        } catch {
          return {
            success: false,
            error: "Invalid column filters JSON format",
            data: {
              timestamp: new Date().toISOString(),
            },
            metadata: { nodeType: "trigger", subtype: "database_trigger" },
          };
        }
      }

      // Mock database change events
      const mockEvents = [
        {
          event_type: "insert",
          table_name: tableName,
          record_id: "123e4567-e89b-12d3-a456-426614174000",
          new_values: {
            id: "123e4567-e89b-12d3-a456-426614174000",
            email: "user@example.com",
            name: "John Doe",
            status: "active",
            priority: "high",
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString(),
          },
          old_values: null,
          changed_columns: [
            "id",
            "email",
            "name",
            "status",
            "priority",
            "created_at",
            "updated_at",
          ],
          timestamp: new Date().toISOString(),
        },
        {
          event_type: "update",
          table_name: tableName,
          record_id: "456e7890-e89b-12d3-a456-426614174001",
          new_values: {
            id: "456e7890-e89b-12d3-a456-426614174001",
            email: "jane@example.com",
            name: "Jane Smith",
            status: "inactive",
            priority: "medium",
            updated_at: new Date().toISOString(),
          },
          old_values: includeOldValues
            ? {
                id: "456e7890-e89b-12d3-a456-426614174001",
                email: "jane@example.com",
                name: "Jane Smith",
                status: "active",
                priority: "high",
                updated_at: new Date(Date.now() - 3600000).toISOString(), // 1 hour ago
              }
            : null,
          changed_columns: ["status", "priority", "updated_at"],
          timestamp: new Date().toISOString(),
        },
      ];

      // Filter events based on trigger_events setting
      let filteredEvents = mockEvents;
      if (triggerEvents !== "all") {
        filteredEvents = mockEvents.filter(
          (event) => event.event_type === triggerEvents
        );
      }

      // Apply column filters if specified
      if (Object.keys(columnFilters).length > 0) {
        filteredEvents = filteredEvents.filter((event) => {
          return matchesColumnFilters(event.new_values, columnFilters);
        });
      }

      // Limit to batch size
      filteredEvents = filteredEvents.slice(0, batchSize);

      return {
        success: true,
        data: {
          events: filteredEvents,
          total_events: filteredEvents.length,
          table_name: tableName,
          trigger_events: triggerEvents,
          column_filters:
            Object.keys(columnFilters).length > 0 ? columnFilters : null,
          include_old_values: includeOldValues,
          batch_size: batchSize,
          connection_string: connectionString.replace(/\/\/.*@/, "//***:***@"), // Mask credentials
          trigger_time: new Date().toISOString(),
        },
        metadata: { nodeType: "trigger", subtype: "database_trigger" },
      };
    },

    validate(config) {
      const errors: Record<string, string> = {};

      if (!config.connection_string) {
        errors.connection_string = "Database connection string is required";
      }

      if (!config.table_name) {
        errors.table_name = "Table name is required";
      } else if (
        typeof config.table_name !== "string" ||
        config.table_name.trim().length === 0
      ) {
        errors.table_name = "Table name must be a non-empty string";
      }

      if (!config.trigger_events) {
        errors.trigger_events = "Trigger events are required";
      }

      if (config.column_filters) {
        try {
          const parsed = JSON.parse(config.column_filters as string);
          if (typeof parsed !== "object" || parsed === null) {
            errors.column_filters = "Column filters must be a JSON object";
          }
        } catch {
          errors.column_filters = "Invalid JSON format for column filters";
        }
      }

      if (
        config.batch_size &&
        (typeof config.batch_size !== "number" || config.batch_size <= 0)
      ) {
        errors.batch_size = "Batch size must be a positive number";
      }

      return {
        valid: Object.keys(errors).length === 0,
        errors,
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/triggers/manual-trigger.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from '../utils';
import type { Integration } from '../types';

export const manualTrigger: Integration = createIntegration({
  id: "manual_trigger",
  name: "Manual",
  category: "trigger",
  description: "Trigger manually",
  icon: "hand",
  version: "1.0.0",

  hasInputHandle: false,

  schema: {
    fields: [
      {
        key: "triggerName",
        type: "text",
        label: "Trigger Name",
        placeholder: "My Manual Trigger",
        required: false,
      },
    ],
    required: [],
  },

  executor: {
    async execute(config) {
      const timestamp = new Date().toISOString();
      return {
        success: true,
        data: {
          triggered: true,
          timestamp,
          triggerName: (config.triggerName as string) || "Manual Trigger",
        },
        metadata: { nodeType: "trigger", subtype: "manual_trigger" },
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/triggers/form-trigger.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const formTrigger: Integration = createIntegration({
  id: "form_trigger",
  name: "Form Submission",
  category: "trigger",
  description: "Trigger when forms are submitted",
  icon: "clipboard",
  version: "1.0.0",
  
  hasInputHandle: false,
  
  schema: {
    fields: [
      {
        key: "form_id",
        type: "text",
        label: "Form ID",
        placeholder: "contact-form-2024",
        required: true,
      },
      {
        key: "webhook_url",
        type: "url",
        label: "Webhook URL (generated)",
        placeholder: "https://api.yourapp.com/webhooks/forms/xyz123",
        required: false,
      },
      {
        key: "field_filters",
        type: "textarea",
        label: "Field Filters (JSON)",
        placeholder: '{"email": "required", "name": "required", "priority": "high"}',
        required: false,
        validation: (value: unknown) => {
          if (!value) return null;
          if (typeof value !== "string") {
            return "Field filters must be a JSON string";
          }
          try {
            JSON.parse(value);
            return null;
          } catch (e) {
            return "Invalid JSON format";
          }
        },
      },
      {
        key: "include_metadata",
        type: "boolean",
        label: "Include Submission Metadata",
        required: false,
      },
      {
        key: "validate_fields",
        type: "boolean",
        label: "Validate Required Fields",
        required: false,
      },
    ],
    required: ["form_id"],
  },

  executor: {
    async execute(config) {
      // Simulate form processing delay
      await new Promise((resolve) => setTimeout(resolve, 300));
      
      const formId = config.form_id as string;
      const includeMetadata = config.include_metadata as boolean || false;
      const validateFields = config.validate_fields as boolean || false;
      
      let fieldFilters = {};
      if (config.field_filters) {
        try {
          fieldFilters = JSON.parse(config.field_filters as string);
        } catch (e) {
          return {
            success: false,
            error: "Invalid field filters JSON format",
            data: {
              timestamp: new Date().toISOString(),
            },
            metadata: { nodeType: "trigger", subtype: "form_trigger" },
          };
        }
      }

      // Mock form submission data
      const mockSubmission = {
        form_id: formId,
        submission_id: "sub_" + Date.now(),
        submitted_at: new Date().toISOString(),
        fields: {
          name: "John Doe",
          email: "john@example.com", 
          message: "I'm interested in your product and would like to schedule a demo. Please contact me at your earliest convenience.",
          phone: "+1-555-0123",
          company: "Acme Corporation",
          priority: "high",
          budget: "50000-100000",
          timeline: "3 months"
        },
        metadata: includeMetadata ? {
          user_agent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
          ip_address: "192.168.1.100",
          referrer: "https://google.com/search?q=automation+platform",
          language: "en-US",
          timezone: "America/New_York",
          screen_resolution: "1920x1080",
          form_load_time: "1.2s",
          form_submit_time: "0.8s",
          session_id: "sess_" + Math.random().toString(36).substr(2, 9),
          utm_source: "google",
          utm_medium: "cpc",
          utm_campaign: "automation_2024"
        } : {},
        validation: validateFields ? {
          is_valid: true,
          errors: [],
          warnings: []
        } : null
      };

      // Apply field filters if specified
      if (Object.keys(fieldFilters).length > 0) {
        const filteredFields: Record<string, unknown> = {};
        for (const [fieldName, filterValue] of Object.entries(fieldFilters)) {
          if (fieldName in mockSubmission.fields) {
            filteredFields[fieldName] = mockSubmission.fields[fieldName as keyof typeof mockSubmission.fields];
          }
        }
        mockSubmission.fields = filteredFields as typeof mockSubmission.fields;
      }

      return {
        success: true,
        data: {
          ...mockSubmission,
          webhook_url: config.webhook_url || null,
          field_filters: Object.keys(fieldFilters).length > 0 ? fieldFilters : null,
          include_metadata: includeMetadata,
          validate_fields: validateFields,
          trigger_time: new Date().toISOString(),
        },
        metadata: { nodeType: "trigger", subtype: "form_trigger" },
      };
    },

    validate(config) {
      const errors: Record<string, string> = {};

      if (!config.form_id) {
        errors.form_id = "Form ID is required";
      } else if (typeof config.form_id !== "string" || config.form_id.trim().length === 0) {
        errors.form_id = "Form ID must be a non-empty string";
      }

      if (config.field_filters) {
        try {
          const parsed = JSON.parse(config.field_filters as string);
          if (typeof parsed !== "object" || parsed === null) {
            errors.field_filters = "Field filters must be a JSON object";
          }
        } catch (e) {
          errors.field_filters = "Invalid JSON format for field filters";
        }
      }

      return {
        valid: Object.keys(errors).length === 0,
        errors,
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/logic/iterator-loop.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration, WorkflowContext } from "../types";

export const iteratorLoop: Integration = createIntegration({
  id: "iterator_loop",
  name: "Iterator",
  category: "logic",
  description: "Loop through arrays and process each item",
  icon: "repeat",
  version: "1.0.0",

  schema: {
    fields: [
      {
        key: "array",
        type: "textarea",
        label: "Array to Iterate",
        placeholder: "{{$node.api-1.data.response.items}}",
        required: true,
        supportExpressions: true,
      },
      {
        key: "item_variable",
        type: "text",
        label: "Item Variable Name",
        placeholder: "current_item",
        required: true,
        validation: (value: unknown) => {
          if (
            typeof value !== "string" ||
            !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(value)
          ) {
            return "Variable name must start with letter or underscore and contain only letters, numbers, and underscores";
          }
          return null;
        },
      },
      {
        key: "index_variable",
        type: "text",
        label: "Index Variable Name",
        placeholder: "current_index",
        required: false,
        validation: (value: unknown) => {
          if (
            value &&
            (typeof value !== "string" ||
              !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(value))
          ) {
            return "Variable name must start with letter or underscore and contain only letters, numbers, and underscores";
          }
          return null;
        },
      },
      {
        key: "max_iterations",
        type: "number",
        label: "Max Iterations (safety limit)",
        placeholder: "1000",
        required: false,
      },
    ],
    required: ["array", "item_variable"],
  },

  executor: {
    async execute(config, context: WorkflowContext) {
      const array = config.array as unknown;
      const itemVarName = config.item_variable as string;
      const indexVarName = config.index_variable as string;
      const maxIterations = (config.max_iterations as number) || 1000;

      // Ensure we have an array to iterate
      if (!Array.isArray(array)) {
        return {
          success: false,
          error: "Input is not an array",
          data: {
            input_type: typeof array,
            timestamp: new Date().toISOString(),
          },
          metadata: { nodeType: "logic", subtype: "iterator_loop" },
        };
      }

      const results = [];
      const actualArray = array.slice(0, maxIterations); // Respect max iterations limit

      for (let i = 0; i < actualArray.length; i++) {
        const item = actualArray[i];

        // Set variables in context for this iteration
        context.variables[itemVarName] = item;
        if (indexVarName) {
          context.variables[indexVarName] = i;
        }

        results.push({
          index: i,
          item: item,
          processed_at: new Date().toISOString(),
          variables_set: {
            [itemVarName]: item,
            ...(indexVarName && { [indexVarName]: i }),
          },
        });
      }

      return {
        success: true,
        data: {
          total_items: array.length,
          processed_items: actualArray.length,
          results,
          completed_iterations: actualArray.length,
          max_iterations_limit: maxIterations,
          timestamp: new Date().toISOString(),
        },
        metadata: { nodeType: "logic", subtype: "iterator_loop" },
      };
    },

    validate(config) {
      const errors: Record<string, string> = {};

      if (!config.array) {
        errors.array = "Array to iterate is required";
      }

      if (!config.item_variable) {
        errors.item_variable = "Item variable name is required";
      } else if (
        !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(config.item_variable as string)
      ) {
        errors.item_variable = "Invalid variable name format";
      }

      if (
        config.index_variable &&
        !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(config.index_variable as string)
      ) {
        errors.index_variable = "Invalid variable name format";
      }

      if (
        config.max_iterations &&
        (typeof config.max_iterations !== "number" ||
          config.max_iterations <= 0)
      ) {
        errors.max_iterations = "Max iterations must be a positive number";
      }

      return {
        valid: Object.keys(errors).length === 0,
        errors,
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/logic/transform-data.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import { parseExpression } from "../../expression";
import type { Integration, WorkflowContext } from "../types";

export const transformData: Integration = createIntegration({
  id: "transform_data",
  name: "Transform Data",
  category: "logic",
  description: "Transform and format data",
  icon: "zap",
  version: "1.0.0",

  schema: {
    fields: [
      {
        key: "inputData",
        type: "textarea",
        label: "Input Data",
        placeholder: "{{$node.previous-node.data}}",
        required: true,
        supportExpressions: true,
      },
      {
        key: "transformation",
        type: "select",
        label: "Transformation Type",
        required: true,
        options: [
          { label: "Format JSON", value: "format_json" },
          { label: "Extract Field", value: "extract_field" },
          { label: "Convert to String", value: "to_string" },
          { label: "Convert to Number", value: "to_number" },
        ],
      },
      {
        key: "fieldPath",
        type: "text",
        label: "Field Path (for extraction)",
        placeholder: "{{$node.webhook-1.data.user.email}}",
        required: false,
      },
    ],
    required: ["inputData", "transformation"],
  },

  executor: {
    async execute(config, context: WorkflowContext) {
      // Fix 1: Properly interpolate the inputData expression
      const inputData = parseExpression(config.inputData as string, context);
      const transformation = config.transformation as string;
      const timestamp = new Date().toISOString();

      let result;
      switch (transformation) {
        case "format_json":
          result = JSON.stringify(inputData, null, 2);
          break;
        case "extract_field":
          // Fix 2: Also interpolate field path
          const fieldPath = parseExpression(config.fieldPath as string, context);
          result = `Extracted: ${fieldPath}`;
          break;
        case "to_string":
          result = String(inputData);
          break;
        case "to_number":
          result = Number(inputData) || 0;
          break;
        default:
          result = inputData;
      }

      return {
        success: true,
        data: {
          input: inputData,
          transformation,
          result,
          timestamp,
        },
        metadata: { nodeType: "logic", subtype: "transform_data" },
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/logic/router.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

// Helper functions
function evaluateCondition(data: unknown, condition: string): boolean {
  // This is a simplified condition evaluator
  // In a real implementation, you'd use a proper expression evaluator like expr-eval or similar
  
  // Handle simple equality checks
  if (condition.includes("===")) {
    const [field, value] = condition.split("===").map(s => s.trim().replace(/['"]/g, ""));
    const fieldValue = getFieldValue(data, field);
    return fieldValue === value;
  }
  
  if (condition.includes("==")) {
    const [field, value] = condition.split("==").map(s => s.trim().replace(/['"]/g, ""));
    const fieldValue = getFieldValue(data, field);
    return fieldValue == value; // Loose equality
  }
  
  if (condition.includes("!=")) {
    const [field, value] = condition.split("!=").map(s => s.trim().replace(/['"]/g, ""));
    const fieldValue = getFieldValue(data, field);
    return fieldValue !== value;
  }
  
  // Handle contains checks
  if (condition.includes(".includes(")) {
    const fieldMatch = condition.match(/(\w+)\.includes\(['"]([^'"]+)['"]\)/);
    if (fieldMatch) {
      const [, field, value] = fieldMatch;
      const fieldValue = getFieldValue(data, field);
      return typeof fieldValue === "string" && fieldValue.includes(value);
    }
  }
  
  // Handle boolean checks
  if (condition.includes("=== true") || condition.includes("=== false")) {
    const field = condition.split("===")[0].trim();
    const expectedValue = condition.includes("=== true");
    const fieldValue = getFieldValue(data, field);
    return Boolean(fieldValue) === expectedValue;
  }
  
  // Default to false for unrecognized conditions
  return false;
}

function getFieldValue(data: unknown, fieldPath: string): unknown {
  if (!fieldPath) return data;
  
  const keys = fieldPath.split(".");
  let value: unknown = data;
  
  for (const key of keys) {
    if (value && typeof value === "object" && key in value) {
      value = (value as Record<string, unknown>)[key];
    } else {
      return undefined;
    }
  }
  
  return value;
}

export const router: Integration = createIntegration({
  id: "router",
  name: "Router",
  category: "logic",
  description: "Route data to multiple paths simultaneously", 
  icon: "workflow",
  version: "1.0.0",
  
  schema: {
    fields: [
      {
        key: "input_data",
        type: "textarea",
        label: "Input Data",
        placeholder: "{{$node.webhook-1.data}}",
        required: true,
        supportExpressions: true,
      },
      {
        key: "routes",
        type: "textarea",
        label: "Route Configurations (JSON)",
        placeholder: '{"urgent": {"condition": "priority === \\"high\\""}, "normal": {"condition": "priority === \\"normal\\""}}',
        required: true,
        validation: (value: unknown) => {
          if (typeof value !== "string") {
            return "Routes must be a JSON string";
          }
          try {
            const parsed = JSON.parse(value);
            if (typeof parsed !== "object" || parsed === null) {
              return "Routes must be a JSON object";
            }
            return null;
          } catch (e) {
            return "Invalid JSON format";
          }
        },
      },
      {
        key: "default_route",
        type: "text",
        label: "Default Route",
        placeholder: "fallback",
        required: false,
      },
      {
        key: "route_to_all",
        type: "boolean",
        label: "Route to All Matching Paths",
        required: false,
      },
      {
        key: "include_metadata",
        type: "boolean",
        label: "Include Routing Metadata",
        required: false,
      },
    ],
    required: ["input_data", "routes"],
  },

  executor: {
    async execute(config) {
      const inputData = config.input_data as unknown;
      const routeToAll = config.route_to_all as boolean || false;
      const includeMetadata = config.include_metadata as boolean || false;
      const defaultRoute = config.default_route as string;
      
      let routes = {};
      try {
        routes = JSON.parse(config.routes as string);
      } catch (e) {
        return {
          success: false,
          error: "Invalid routes JSON format",
          data: {
            timestamp: new Date().toISOString(),
          },
          metadata: { nodeType: "logic", subtype: "router" },
        };
      }

      const activeRoutes: string[] = [];
      const routeResults: Record<string, unknown> = {};
      const routingMetadata: Record<string, unknown> = {};

      // Evaluate each route condition
      for (const [routeName, routeConfig] of Object.entries(routes)) {
        const condition = (routeConfig as Record<string, unknown>).condition as string;
        
        if (condition) {
          try {
            // Simple condition evaluation (in a real implementation, you'd use a proper expression evaluator)
            const isMatch = evaluateCondition(inputData, condition);
            
            if (isMatch) {
              activeRoutes.push(routeName);
              routeResults[routeName] = {
                input_data: inputData,
                route_name: routeName,
                condition: condition,
                matched: true,
                timestamp: new Date().toISOString(),
              };
              
              if (includeMetadata) {
                routingMetadata[routeName] = {
                  condition_evaluated: condition,
                  evaluation_result: true,
                  evaluation_time: new Date().toISOString(),
                };
              }
              
              // If not routing to all, stop after first match
              if (!routeToAll) {
                break;
              }
            } else if (includeMetadata) {
              routingMetadata[routeName] = {
                condition_evaluated: condition,
                evaluation_result: false,
                evaluation_time: new Date().toISOString(),
              };
            }
          } catch (error) {
            if (includeMetadata) {
              routingMetadata[routeName] = {
                condition_evaluated: condition,
                evaluation_result: false,
                evaluation_error: String(error),
                evaluation_time: new Date().toISOString(),
              };
            }
          }
        }
      }

      // If no routes matched and default route is specified
      if (activeRoutes.length === 0 && defaultRoute) {
        activeRoutes.push(defaultRoute);
        routeResults[defaultRoute] = {
          input_data: inputData,
          route_name: defaultRoute,
          condition: "default",
          matched: false,
          is_default: true,
          timestamp: new Date().toISOString(),
        };
      }

      return {
        success: true,
        data: {
          input_data: inputData,
          active_routes: activeRoutes,
          route_results: routeResults,
          total_routes: Object.keys(routes).length,
          active_route_count: activeRoutes.length,
          route_to_all: routeToAll,
          default_route: defaultRoute || null,
          routing_metadata: includeMetadata ? routingMetadata : null,
          timestamp: new Date().toISOString(),
        },
        metadata: { nodeType: "logic", subtype: "router" },
      };
    },

    validate(config) {
      const errors: Record<string, string> = {};

      if (!config.input_data) {
        errors.input_data = "Input data is required";
      }

      if (!config.routes) {
        errors.routes = "Routes configuration is required";
      } else {
        try {
          const parsed = JSON.parse(config.routes as string);
          if (typeof parsed !== "object" || parsed === null) {
            errors.routes = "Routes must be a JSON object";
          }
        } catch (e) {
          errors.routes = "Invalid JSON format for routes";
        }
      }

      return {
        valid: Object.keys(errors).length === 0,
        errors,
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/logic/data-validator.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

// Helper function
function validateField(
  fieldName: string,
  value: unknown,
  rule: string,
  customValidators: Record<string, string>
) {
  const result = {
    error: null as string | null,
    warning: null as string | null,
  };

  switch (rule) {
    case "required":
      if (value === undefined || value === null || value === "") {
        result.error = `Field '${fieldName}' is required`;
      }
      break;

    case "email":
      if (value && typeof value === "string") {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(value)) {
          result.error = `Field '${fieldName}' must be a valid email address`;
        }
      }
      break;

    case "number":
      if (value !== undefined && value !== null) {
        if (typeof value !== "number" || isNaN(value)) {
          result.error = `Field '${fieldName}' must be a number`;
        }
      }
      break;

    case "string":
      if (value !== undefined && value !== null && typeof value !== "string") {
        result.error = `Field '${fieldName}' must be a string`;
      }
      break;

    case "boolean":
      if (value !== undefined && value !== null && typeof value !== "boolean") {
        result.error = `Field '${fieldName}' must be a boolean`;
      }
      break;

    case "url":
      if (value && typeof value === "string") {
        try {
          new URL(value);
        } catch {
          result.error = `Field '${fieldName}' must be a valid URL`;
        }
      }
      break;

    default:
      // Check custom validators
      if (customValidators[rule]) {
        const customRule = customValidators[rule];
        if (customRule.startsWith("regex:")) {
          const regexPattern = customRule.substring(6);
          try {
            const regex = new RegExp(regexPattern);
            if (value && typeof value === "string" && !regex.test(value)) {
              result.error = `Field '${fieldName}' failed regex validation: ${regexPattern}`;
            }
          } catch (e) {
            result.warning = `Invalid regex pattern for field '${fieldName}': ${regexPattern}`;
          }
        } else if (customRule.startsWith("range:")) {
          const range = customRule.substring(6);
          const [min, max] = range.split("-").map(Number);
          if (value && typeof value === "number") {
            if (value < min || value > max) {
              result.error = `Field '${fieldName}' must be between ${min} and ${max}`;
            }
          }
        }
      } else {
        result.warning = `Unknown validation rule '${rule}' for field '${fieldName}'`;
      }
  }

  return result;
}

export const dataValidator: Integration = createIntegration({
  id: "data_validator",
  name: "Data Validator",
  category: "logic",
  description: "Validate data against schemas and rules",
  icon: "shield-check",
  version: "1.0.0",

  schema: {
    fields: [
      {
        key: "input_data",
        type: "textarea",
        label: "Data to Validate",
        placeholder: "{{$node.api-1.data.response}}",
        required: true,
        supportExpressions: true,
      },
      {
        key: "validation_rules",
        type: "textarea",
        label: "Validation Rules (JSON)",
        placeholder: '{"email": "email", "age": "number", "name": "required"}',
        required: true,
        validation: (value: unknown) => {
          if (typeof value !== "string") {
            return "Validation rules must be a JSON string";
          }
          try {
            const parsed = JSON.parse(value);
            if (typeof parsed !== "object" || parsed === null) {
              return "Validation rules must be a JSON object";
            }
            return null;
          } catch (e) {
            return "Invalid JSON format";
          }
        },
      },
      {
        key: "stop_on_error",
        type: "boolean",
        label: "Stop Workflow on Validation Error",
        required: false,
      },
      {
        key: "custom_validators",
        type: "textarea",
        label: "Custom Validators (JSON)",
        placeholder:
          '{"phone": "regex:/^\\+?[1-9]\\d{1,14}$/", "age_range": "range:18-65"}',
        required: false,
        validation: (value: unknown) => {
          if (!value) return null;
          if (typeof value !== "string") {
            return "Custom validators must be a JSON string";
          }
          try {
            const parsed = JSON.parse(value);
            if (typeof parsed !== "object" || parsed === null) {
              return "Custom validators must be a JSON object";
            }
            return null;
          } catch (e) {
            return "Invalid JSON format";
          }
        },
      },
    ],
    required: ["input_data", "validation_rules"],
  },

  executor: {
    async execute(config) {
      const inputData = config.input_data as unknown;
      const stopOnError = (config.stop_on_error as boolean) || false;

      let validationRules = {};
      let customValidators = {};

      try {
        validationRules = JSON.parse(config.validation_rules as string);
      } catch (e) {
        return {
          success: false,
          error: "Invalid validation rules JSON format",
          data: {
            timestamp: new Date().toISOString(),
          },
          metadata: { nodeType: "logic", subtype: "data_validator" },
        };
      }

      if (config.custom_validators) {
        try {
          customValidators = JSON.parse(config.custom_validators as string);
        } catch (e) {
          return {
            success: false,
            error: "Invalid custom validators JSON format",
            data: {
              timestamp: new Date().toISOString(),
            },
            metadata: { nodeType: "logic", subtype: "data_validator" },
          };
        }
      }

      const errors: string[] = [];
      const warnings: string[] = [];
      const validatedFields: string[] = [];

      // Validate each field according to rules
      for (const [fieldName, rule] of Object.entries(validationRules)) {
        validatedFields.push(fieldName);
        const fieldValue =
          inputData && typeof inputData === "object" && fieldName in inputData
            ? (inputData as Record<string, unknown>)[fieldName]
            : undefined;

        const validationResult = validateField(
          fieldName,
          fieldValue,
          rule as string,
          customValidators
        );

        if (validationResult.error) {
          errors.push(validationResult.error);
          if (stopOnError) break;
        }

        if (validationResult.warning) {
          warnings.push(validationResult.warning);
        }
      }

      const isValid = errors.length === 0;

      return {
        success: true,
        data: {
          is_valid: isValid,
          errors,
          warnings,
          validated_fields: validatedFields,
          total_fields: validatedFields.length,
          stop_on_error: stopOnError,
          timestamp: new Date().toISOString(),
        },
        metadata: { nodeType: "logic", subtype: "data_validator" },
      };
    },

    validate(config) {
      const errors: Record<string, string> = {};

      if (!config.input_data) {
        errors.input_data = "Input data is required";
      }

      if (!config.validation_rules) {
        errors.validation_rules = "Validation rules are required";
      } else {
        try {
          const parsed = JSON.parse(config.validation_rules as string);
          if (typeof parsed !== "object" || parsed === null) {
            errors.validation_rules = "Validation rules must be a JSON object";
          }
        } catch (e) {
          errors.validation_rules = "Invalid JSON format for validation rules";
        }
      }

      if (config.custom_validators) {
        try {
          const parsed = JSON.parse(config.custom_validators as string);
          if (typeof parsed !== "object" || parsed === null) {
            errors.custom_validators =
              "Custom validators must be a JSON object";
          }
        } catch (e) {
          errors.custom_validators =
            "Invalid JSON format for custom validators";
        }
      }

      return {
        valid: Object.keys(errors).length === 0,
        errors,
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/logic/switch-case.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const switchCase: Integration = createIntegration({
  id: "switch_case",
  name: "Switch",
  category: "logic",
  description: "Multi-path branching based on value matching",
  icon: "git-branch",
  version: "1.0.0",

  schema: {
    fields: [
      {
        key: "input_value",
        type: "text",
        label: "Input Value",
        placeholder: "{{$node.trigger-1.data.status}}",
        required: true,
        supportExpressions: true,
      },
      {
        key: "cases",
        type: "textarea",
        label: "Cases (JSON)",
        placeholder:
          '{"active": "path1", "inactive": "path2", "pending": "path3"}',
        required: true,
        validation: (value: unknown) => {
          if (typeof value !== "string") {
            return "Cases must be a JSON string";
          }
          try {
            const parsed = JSON.parse(value);
            if (
              typeof parsed !== "object" ||
              parsed === null ||
              Array.isArray(parsed)
            ) {
              return "Cases must be a JSON object";
            }
            return null;
          } catch (e) {
            return "Invalid JSON format";
          }
        },
      },
      {
        key: "default_case",
        type: "text",
        label: "Default Case",
        placeholder: "default_path",
        required: false,
      },
      {
        key: "case_sensitive",
        type: "boolean",
        label: "Case Sensitive Matching",
        required: false,
      },
    ],
    required: ["input_value", "cases"],
  },

  executor: {
    async execute(config) {
      const inputValue = config.input_value as string;
      const caseSensitive = (config.case_sensitive as boolean) || false;
      let cases = {};

      try {
        cases = JSON.parse(config.cases as string);
      } catch (e) {
        return {
          success: false,
          error: "Invalid cases JSON format",
          data: {
            input_value: inputValue,
            timestamp: new Date().toISOString(),
          },
          metadata: { nodeType: "logic", subtype: "switch_case" },
        };
      }

      // Find matching case
      let matchedCase = (config.default_case as string) || "no_match";
      const availableCases = Object.keys(cases);

      for (const caseKey of availableCases) {
        const compareValue = caseSensitive ? caseKey : caseKey.toLowerCase();
        const compareInput = caseSensitive
          ? inputValue
          : inputValue.toLowerCase();

        if (compareValue === compareInput) {
          matchedCase = cases[caseKey as keyof typeof cases] as string;
          break;
        }
      }

      return {
        success: true,
        data: {
          input_value: inputValue,
          matched_case: matchedCase,
          available_cases: availableCases,
          case_sensitive: caseSensitive,
          default_case: (config.default_case as string) || "no_match",
          timestamp: new Date().toISOString(),
        },
        metadata: { nodeType: "logic", subtype: "switch_case" },
      };
    },

    validate(config) {
      const errors: Record<string, string> = {};

      if (!config.input_value) {
        errors.input_value = "Input value is required";
      }

      if (!config.cases) {
        errors.cases = "Cases configuration is required";
      } else {
        try {
          const parsed = JSON.parse(config.cases as string);
          if (
            typeof parsed !== "object" ||
            parsed === null ||
            Array.isArray(parsed)
          ) {
            errors.cases = "Cases must be a JSON object";
          }
        } catch (e) {
          errors.cases = "Invalid JSON format for cases";
        }
      }

      return {
        valid: Object.keys(errors).length === 0,
        errors,
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/logic/filter-condition.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from '../utils';
import type { Integration } from '../types';

export const filterCondition: Integration = createIntegration({
  id: "filter_condition",
  name: "Filter",
  category: "logic",
  description: "Filter data conditionally",
  icon: "search",
  version: "1.0.0",

  schema: {
    fields: [
      {
        key: "field",
        type: "text",
        label: "Field to Check",
        placeholder: "{{$node.webhook-1.data.status}}",
        required: true,
        supportExpressions: true,
      },
      {
        key: "operator",
        type: "select",
        label: "Condition",
        required: true,
        options: [
          { label: "equals", value: "equals" },
          { label: "does not equal", value: "not_equals" },
          { label: "contains", value: "contains" },
          { label: "is greater than", value: "greater_than" },
          { label: "is less than", value: "less_than" },
        ],
      },
      {
        key: "value",
        type: "text",
        label: "Comparison Value",
        placeholder: "active",
        required: true,
        supportExpressions: true,
      },
    ],
    required: ["field", "operator", "value"],
  },

  executor: {
    async execute(config) {
      const sampleValue = "active"; // Simulate checking a status field
      const conditionMet = sampleValue === config.value;
      const timestamp = new Date().toISOString();

      return {
        success: true,
        data: {
          field: config.field as string,
          operator: config.operator as string,
          expectedValue: config.value,
          actualValue: sampleValue,
          conditionMet,
          matchedRecords: conditionMet ? 42 : 0,
          timestamp,
        },
        metadata: { nodeType: "logic", subtype: "filter_condition" },
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/logic/branch-condition.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration, WorkflowContext } from "../types";
import { parseExpression } from "../../expression";

export const branchCondition: Integration = createIntegration({
  id: "branch_condition",
  name: "Branch",
  category: "logic",
  description: "Split workflow into multiple paths",
  icon: "diamond",
  version: "1.0.0",

  schema: {
    fields: [
      {
        key: "condition",
        type: "textarea",
        label: "Condition Expression",
        placeholder: "{{$node.trigger-1.data.status}} === 'active'",
        required: true,
        supportExpressions: true,
      },
      {
        key: "trueLabel",
        type: "text",
        label: "True Path Label",
        placeholder: "If condition is true",
        required: false,
      },
      {
        key: "falseLabel",
        type: "text",
        label: "False Path Label",
        placeholder: "If condition is false",
        required: false,
      },
    ],
    required: ["condition"],
  },

  executor: {
    async execute(config, ctx: WorkflowContext) {
      // The condition should already be interpolated by the registry
      const condition = config.condition as string;

      // Parse the condition to replace variables
      const interpolatedCondition = parseExpression(condition, ctx, true);

      let conditionResult = false;
      try {
        conditionResult = Function(
          `"use strict"; return (${interpolatedCondition});`
        )();
      } catch (error) {
        console.warn("Branch condition evaluation failed:", error);
      }

      const timestamp = new Date().toISOString();

      return {
        success: true,
        data: {
          condition: interpolatedCondition, // Show the actual evaluated condition
          result: conditionResult,
          path: conditionResult ? "true" : "false",
          timestamp,
        },
        metadata: { nodeType: "logic", subtype: "branch_condition" },
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/logic/aggregator.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

// Helper functions
function filterData(
  data: unknown[],
  filterCondition: Record<string, unknown>
): unknown[] {
  return data.filter((item) => {
    if (typeof item !== "object" || item === null) return false;

    for (const [key, condition] of Object.entries(filterCondition)) {
      const value = (item as Record<string, unknown>)[key];

      if (typeof condition === "object" && condition !== null) {
        // Handle operators like {"$gt": 0}
        for (const [operator, operatorValue] of Object.entries(condition)) {
          switch (operator) {
            case "$gt":
              if (typeof value !== "number" || value <= operatorValue)
                return false;
              break;
            case "$gte":
              if (typeof value !== "number" || value < operatorValue)
                return false;
              break;
            case "$lt":
              if (typeof value !== "number" || value >= operatorValue)
                return false;
              break;
            case "$lte":
              if (typeof value !== "number" || value > operatorValue)
                return false;
              break;
            case "$eq":
              if (value !== operatorValue) return false;
              break;
            case "$ne":
              if (value === operatorValue) return false;
              break;
            case "$in":
              if (
                !Array.isArray(operatorValue) ||
                !operatorValue.includes(value)
              )
                return false;
              break;
          }
        }
      } else {
        // Simple equality check
        if (value !== condition) return false;
      }
    }

    return true;
  });
}

function getFieldValue(item: unknown, fieldPath: string): unknown {
  if (!fieldPath) return item;

  const keys = fieldPath.split(".");
  let value: unknown = item;

  for (const key of keys) {
    if (value && typeof value === "object" && key in value) {
      value = (value as Record<string, unknown>)[key];
    } else {
      return undefined;
    }
  }

  return value;
}

function aggregateSum(data: unknown[], fieldPath: string): number {
  return data.reduce<number>((sum, item) => {
    const value = getFieldValue(item, fieldPath);
    if (typeof value === "number" && !isNaN(value)) {
      return sum + value;
    }
    return sum;
  }, 0);
}

function aggregateAverage(data: unknown[], fieldPath: string): number {
  const values = data
    .map((item) => getFieldValue(item, fieldPath))
    .filter((value) => typeof value === "number" && !isNaN(value)) as number[];

  if (values.length === 0) return 0;
  return values.reduce((sum, value) => sum + value, 0) / values.length;
}

function aggregateMin(data: unknown[], fieldPath: string): unknown {
  const values = data
    .map((item) => getFieldValue(item, fieldPath))
    .filter((value) => value !== undefined && value !== null);

  if (values.length === 0) return null;
  return Math.min(...(values as number[]));
}

function aggregateMax(data: unknown[], fieldPath: string): unknown {
  const values = data
    .map((item) => getFieldValue(item, fieldPath))
    .filter((value) => value !== undefined && value !== null);

  if (values.length === 0) return null;
  return Math.max(...(values as number[]));
}

function aggregateConcat(
  data: unknown[],
  fieldPath: string,
  separator: string
): string {
  const values = data
    .map((item) => getFieldValue(item, fieldPath))
    .filter((value) => value !== undefined && value !== null)
    .map((value) => String(value));

  return values.join(separator);
}

function aggregateMerge(data: unknown[]): Record<string, unknown> {
  const result: Record<string, unknown> = {};

  for (const item of data) {
    if (item && typeof item === "object") {
      Object.assign(result, item);
    }
  }

  return result;
}

function aggregateGroup(
  data: unknown[],
  groupByField: string,
  valueField: string
): Record<string, unknown> {
  const groups: Record<string, unknown[]> = {};

  for (const item of data) {
    const groupKey = getFieldValue(item, groupByField);
    if (groupKey !== undefined) {
      const key = String(groupKey);
      if (!groups[key]) groups[key] = [];
      groups[key].push(getFieldValue(item, valueField));
    }
  }

  return groups;
}

function aggregateUnique(data: unknown[], fieldPath: string): unknown[] {
  const values = data
    .map((item) => getFieldValue(item, fieldPath))
    .filter((value) => value !== undefined && value !== null);

  return Array.from(new Set(values));
}

export const aggregator: Integration = createIntegration({
  id: "aggregator",
  name: "Aggregator",
  category: "logic",
  description: "Collect and combine data from multiple sources",
  icon: "layers",
  version: "1.0.0",

  schema: {
    fields: [
      {
        key: "operation",
        type: "select",
        label: "Aggregation Operation",
        required: true,
        options: [
          { label: "Sum", value: "sum" },
          { label: "Average", value: "average" },
          { label: "Count", value: "count" },
          { label: "Min", value: "min" },
          { label: "Max", value: "max" },
          { label: "Concatenate", value: "concat" },
          { label: "Merge Objects", value: "merge" },
          { label: "Group By", value: "group" },
          { label: "Unique Values", value: "unique" },
        ],
      },
      {
        key: "input_data",
        type: "textarea",
        label: "Input Data",
        placeholder: "{{$node.iterator-1.data.results}}",
        required: true,
        supportExpressions: true,
      },
      {
        key: "field_path",
        type: "text",
        label: "Field to Aggregate (for array of objects)",
        placeholder:
          "value or price or {{$node.iterator-1.data.results.*.value}}",
        supportExpressions: true,
      },
      {
        key: "group_by_field",
        type: "text",
        label: "Group By Field (for group operation)",
        placeholder: "category or status",
        required: false,
      },
      {
        key: "separator",
        type: "text",
        label: "Separator (for concatenate)",
        placeholder: ", ",
        required: false,
      },
      {
        key: "filter_condition",
        type: "textarea",
        label: "Filter Condition (JSON)",
        placeholder: '{"status": "active", "value": {"$gt": 0}}',
        required: false,
        validation: (value: unknown) => {
          if (!value) return null;
          if (typeof value !== "string") {
            return "Filter condition must be a JSON string";
          }
          try {
            JSON.parse(value);
            return null;
          } catch (e) {
            return "Invalid JSON format";
          }
        },
      },
    ],
    required: ["operation", "input_data"],
  },

  executor: {
    async execute(config) {
      const operation = config.operation as string;
      const inputData = config.input_data as unknown;
      const fieldPath = config.field_path as string;
      const groupByField = config.group_by_field as string;
      const separator = (config.separator as string) || ", ";

      let filterCondition = {};
      if (config.filter_condition) {
        try {
          filterCondition = JSON.parse(config.filter_condition as string);
        } catch (e) {
          return {
            success: false,
            error: "Invalid filter condition JSON format",
            data: {
              timestamp: new Date().toISOString(),
            },
            metadata: { nodeType: "logic", subtype: "aggregator" },
          };
        }
      }

      // Ensure input is an array
      if (!Array.isArray(inputData)) {
        return {
          success: false,
          error: "Input data must be an array",
          data: {
            input_type: typeof inputData,
            timestamp: new Date().toISOString(),
          },
          metadata: { nodeType: "logic", subtype: "aggregator" },
        };
      }

      // Apply filter if specified
      let filteredData = inputData;
      if (Object.keys(filterCondition).length > 0) {
        filteredData = filterData(inputData, filterCondition);
      }

      let result: unknown;
      const metadata: Record<string, unknown> = {
        input_count: inputData.length,
        filtered_count: filteredData.length,
        operation,
      };

      switch (operation) {
        case "sum":
          result = aggregateSum(filteredData, fieldPath);
          break;

        case "average":
          result = aggregateAverage(filteredData, fieldPath);
          break;

        case "count":
          result = filteredData.length;
          break;

        case "min":
          result = aggregateMin(filteredData, fieldPath);
          break;

        case "max":
          result = aggregateMax(filteredData, fieldPath);
          break;

        case "concat":
          result = aggregateConcat(filteredData, fieldPath, separator);
          break;

        case "merge":
          result = aggregateMerge(filteredData);
          break;

        case "group":
          result = aggregateGroup(filteredData, groupByField, fieldPath);
          break;

        case "unique":
          result = aggregateUnique(filteredData, fieldPath);
          break;

        default:
          return {
            success: false,
            error: `Unknown aggregation operation: ${operation}`,
            data: {
              timestamp: new Date().toISOString(),
            },
            metadata: { nodeType: "logic", subtype: "aggregator" },
          };
      }

      return {
        success: true,
        data: {
          result,
          ...metadata,
          timestamp: new Date().toISOString(),
        },
        metadata: { nodeType: "logic", subtype: "aggregator" },
      };
    },

    validate(config) {
      const errors: Record<string, string> = {};

      if (!config.operation) {
        errors.operation = "Aggregation operation is required";
      }

      if (!config.input_data) {
        errors.input_data = "Input data is required";
      }

      if (config.operation === "group" && !config.group_by_field) {
        errors.group_by_field =
          "Group by field is required for group operation";
      }

      if (config.filter_condition) {
        try {
          JSON.parse(config.filter_condition as string);
        } catch (e) {
          errors.filter_condition = "Invalid JSON format for filter condition";
        }
      }

      return {
        valid: Object.keys(errors).length === 0,
        errors,
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/actions/database-select.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

// Helper function
function matchesWhereConditions(
  row: Record<string, unknown>,
  conditions: Record<string, unknown>
): boolean {
  for (const [field, condition] of Object.entries(conditions)) {
    const value = row[field];

    if (typeof condition === "object" && condition !== null) {
      // Handle operators like {"$gte": 18}
      for (const [operator, operatorValue] of Object.entries(condition)) {
        switch (operator) {
          case "$eq":
            if (value !== operatorValue) return false;
            break;
          case "$ne":
            if (value === operatorValue) return false;
            break;
          case "$gt":
            if (typeof value !== "number" || value <= operatorValue)
              return false;
            break;
          case "$gte":
            if (typeof value !== "number" || value < operatorValue)
              return false;
            break;
          case "$lt":
            if (typeof value !== "number" || value >= operatorValue)
              return false;
            break;
          case "$lte":
            if (typeof value !== "number" || value > operatorValue)
              return false;
            break;
          case "$in":
            if (!Array.isArray(operatorValue) || !operatorValue.includes(value))
              return false;
            break;
          case "$nin":
            if (Array.isArray(operatorValue) && operatorValue.includes(value))
              return false;
            break;
          case "$like":
            if (
              typeof value !== "string" ||
              !value.includes(operatorValue as string)
            )
              return false;
            break;
        }
      }
    } else {
      // Simple equality check
      if (value !== condition) return false;
    }
  }

  return true;
}

export const databaseSelect: Integration = createIntegration({
  id: "database_select",
  name: "Database Select",
  category: "action",
  description: "Query data from database tables",
  icon: "database",
  version: "1.0.0",

  auth: {
    type: "api_key",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "connection_string",
        type: "text",
        label: "Database Connection String",
        placeholder:
          "postgresql://user:pass@host:5432/db or mysql://user:pass@host:3306/db",
        required: true,
        validation: (value: unknown) => {
          if (typeof value !== "string" || value.trim().length === 0) {
            return "Connection string is required";
          }
          return null;
        },
      },
      {
        key: "query_type",
        type: "select",
        label: "Query Type",
        required: true,
        options: [
          { label: "SQL Query", value: "sql" },
          { label: "Table Select", value: "table" },
        ],
      },
      {
        key: "sql_query",
        type: "textarea",
        label: "SQL Query",
        placeholder:
          "SELECT * FROM users WHERE status = 'active' ORDER BY created_at DESC LIMIT 10",
        required: false,
        supportExpressions: true,
      },
      {
        key: "table_name",
        type: "text",
        label: "Table Name",
        placeholder: "users or customers",
        required: false,
      },
      {
        key: "select_fields",
        type: "text",
        label: "Select Fields (comma-separated)",
        placeholder: "id, name, email, created_at",
        required: false,
      },
      {
        key: "where_conditions",
        type: "textarea",
        label: "Where Conditions (JSON)",
        placeholder: '{"status": "active", "age": {"$gte": 18}}',
        required: false,
        validation: (value: unknown) => {
          if (!value) return null;
          if (typeof value !== "string") {
            return "Where conditions must be a JSON string";
          }
          try {
            JSON.parse(value);
            return null;
          } catch {
            return "Invalid JSON format";
          }
        },
      },
      {
        key: "order_by",
        type: "text",
        label: "Order By",
        placeholder: "created_at DESC, name ASC",
        required: false,
      },
      {
        key: "limit",
        type: "number",
        label: "Limit",
        placeholder: "100",
        required: false,
      },
      {
        key: "offset",
        type: "number",
        label: "Offset",
        placeholder: "0",
        required: false,
      },
    ],
    required: ["connection_string", "query_type"],
  },

  executor: {
    async execute(config) {
      // Simulate database operation delay
      await new Promise((resolve) => setTimeout(resolve, 600));

      const connectionString = config.connection_string as string;
      const queryType = config.query_type as string;
      const sqlQuery = config.sql_query as string;
      const tableName = config.table_name as string;
      const selectFields = config.select_fields as string;
      const orderBy = config.order_by as string;
      const limit = (config.limit as number) || 100;
      const offset = (config.offset as number) || 0;

      let whereConditions = {};
      if (config.where_conditions) {
        try {
          whereConditions = JSON.parse(config.where_conditions as string);
        } catch {
          return {
            success: false,
            error: "Invalid JSON format for where conditions",
            data: {
              timestamp: new Date().toISOString(),
            },
            metadata: { nodeType: "action", subtype: "database_select" },
          };
        }
      }

      // Validate required fields based on query type
      if (queryType === "sql" && !sqlQuery) {
        return {
          success: false,
          error: "SQL query is required when using SQL query type",
          data: {
            timestamp: new Date().toISOString(),
          },
          metadata: { nodeType: "action", subtype: "database_select" },
        };
      }

      if (queryType === "table" && !tableName) {
        return {
          success: false,
          error: "Table name is required when using table select type",
          data: {
            timestamp: new Date().toISOString(),
          },
          metadata: { nodeType: "action", subtype: "database_select" },
        };
      }

      // Mock database response
      const mockData = [
        {
          id: 1,
          name: "John Doe",
          email: "john@example.com",
          status: "active",
          age: 30,
          created_at: "2024-01-15T10:30:00Z",
          updated_at: "2024-01-15T10:30:00Z",
        },
        {
          id: 2,
          name: "Jane Smith",
          email: "jane@example.com",
          status: "active",
          age: 25,
          created_at: "2024-01-14T15:45:00Z",
          updated_at: "2024-01-14T15:45:00Z",
        },
        {
          id: 3,
          name: "Bob Johnson",
          email: "bob@example.com",
          status: "inactive",
          age: 35,
          created_at: "2024-01-13T09:20:00Z",
          updated_at: "2024-01-13T09:20:00Z",
        },
      ];

      // Apply where conditions filtering
      let filteredData = mockData;
      if (Object.keys(whereConditions).length > 0) {
        filteredData = mockData.filter((row) => {
          return matchesWhereConditions(row, whereConditions);
        });
      }

      // Apply limit and offset
      const paginatedData = filteredData.slice(offset, offset + limit);

      // Filter fields if specified
      let finalData: Record<string, unknown>[] = paginatedData;
      if (selectFields && queryType === "table") {
        const fieldsToSelect = selectFields
          .split(",")
          .map((field) => field.trim());
        finalData = paginatedData.map((row) => {
          const filteredRow: Record<string, unknown> = {};
          for (const field of fieldsToSelect) {
            if (field in row) {
              filteredRow[field] = row[field as keyof typeof row];
            }
          }
          return filteredRow;
        });
      }

      return {
        success: true,
        data: {
          queryType,
          sqlQuery: queryType === "sql" ? sqlQuery : null,
          tableName: queryType === "table" ? tableName : null,
          selectFields: selectFields
            ? selectFields.split(",").map((f) => f.trim())
            : null,
          whereConditions:
            Object.keys(whereConditions).length > 0 ? whereConditions : null,
          orderBy: orderBy || null,
          limit,
          offset,
          results: finalData,
          totalRows: filteredData.length,
          returnedRows: finalData.length,
          executionTime: "23ms",
          timestamp: new Date().toISOString(),
          connectionString: connectionString.replace(/\/\/.*@/, "//***:***@"), // Mask credentials
        },
        metadata: { nodeType: "action", subtype: "database_select" },
      };
    },

    validate(config) {
      const errors: Record<string, string> = {};

      if (!config.connection_string) {
        errors.connection_string = "Connection string is required";
      }

      if (!config.query_type) {
        errors.query_type = "Query type is required";
      }

      if (config.query_type === "sql" && !config.sql_query) {
        errors.sql_query = "SQL query is required when using SQL query type";
      }

      if (config.query_type === "table" && !config.table_name) {
        errors.table_name =
          "Table name is required when using table select type";
      }

      if (config.where_conditions) {
        try {
          JSON.parse(config.where_conditions as string);
        } catch {
          errors.where_conditions = "Invalid JSON format for where conditions";
        }
      }

      if (
        config.limit &&
        (typeof config.limit !== "number" || config.limit <= 0)
      ) {
        errors.limit = "Limit must be a positive number";
      }

      if (
        config.offset &&
        (typeof config.offset !== "number" || config.offset < 0)
      ) {
        errors.offset = "Offset must be a non-negative number";
      }

      return {
        valid: Object.keys(errors).length === 0,
        errors,
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/actions/teams-send-message.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const teamsSendMessage: Integration = createIntegration({
  id: "teams_send_message",
  name: "Send Teams Message",
  category: "action",
  description: "Post messages to Microsoft Teams channels",
  icon: "microsoft",
  version: "1.0.0",

  auth: {
    type: "oauth2",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "team_id",
        type: "text",
        label: "Team ID",
        placeholder: "19:team@contoso.com",
        required: true,
      },
      {
        key: "channel_id",
        type: "text",
        label: "Channel ID",
        placeholder: "19:channel@contoso.com",
        required: true,
      },
      {
        key: "message",
        type: "textarea",
        label: "Message",
        placeholder: "Hello from the automation!",
        required: true,
        supportExpressions: true,
      },
      {
        key: "card_template",
        type: "select",
        label: "Card Template",
        required: false,
        options: [
          { label: "None", value: "none" },
          { label: "Hero Card", value: "hero" },
          { label: "Thumbnail Card", value: "thumbnail" },
          { label: "Adaptive Card", value: "adaptive" },
        ],
      },
    ],
    required: ["team_id", "channel_id", "message"],
  },

  executor: {
    async execute(config) {
      await new Promise((resolve) => setTimeout(resolve, 1000));
      const timestamp = new Date().toISOString();
      
      return {
        success: true,
        data: {
          messageId: "AAMkAGI1AAAt9AHjAAA=",
          teamId: config.team_id as string,
          channelId: config.channel_id as string,
          message: config.message as string,
          cardTemplate: config.card_template as string || "none",
          timestamp,
          webUrl: "https://teams.microsoft.com/l/message/19:channel@contoso.com/1234567890",
          createdBy: "user@contoso.com",
        },
        metadata: { nodeType: "action", subtype: "teams_send_message" },
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/actions/github-create-issue.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const githubCreateIssue: Integration = createIntegration({
  id: "github_create_issue",
  name: "GitHub Create Issue",
  category: "action",
  description: "Create issues in GitHub repositories",
  icon: "github",
  version: "1.0.0",

  auth: {
    type: "oauth2",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "owner",
        type: "text",
        label: "Repository Owner",
        placeholder: "username",
        required: true,
      },
      {
        key: "repo",
        type: "text",
        label: "Repository Name",
        placeholder: "repository-name",
        required: true,
      },
      {
        key: "title",
        type: "text",
        label: "Issue Title",
        placeholder: "Bug: Application crashes on startup",
        required: true,
        supportExpressions: true,
      },
      {
        key: "body",
        type: "textarea",
        label: "Issue Description",
        placeholder: "Describe the issue in detail...",
        required: false,
        supportExpressions: true,
      },
      {
        key: "labels",
        type: "text",
        label: "Labels (comma-separated)",
        placeholder: "bug, high-priority, frontend",
        required: false,
      },
      {
        key: "assignees",
        type: "text",
        label: "Assignees (comma-separated)",
        placeholder: "username1, username2",
        required: false,
      },
      {
        key: "milestone",
        type: "number",
        label: "Milestone ID",
        placeholder: "123",
        required: false,
      },
    ],
    required: ["owner", "repo", "title"],
  },

  executor: {
    async execute(config) {
      await new Promise((resolve) => setTimeout(resolve, 1000));
      const timestamp = new Date().toISOString();
      
      return {
        success: true,
        data: {
          issueId: 12345,
          number: 123,
          title: config.title as string,
          body: config.body as string || "",
          labels: config.labels ? (config.labels as string).split(',').map(label => label.trim()) : [],
          assignees: config.assignees ? (config.assignees as string).split(',').map(assignee => assignee.trim()) : [],
          milestone: config.milestone as number || null,
          state: "open",
          locked: false,
          createdAt: timestamp,
          updatedAt: timestamp,
          closedAt: null,
          author: "username",
          repository: `${config.owner}/${config.repo}`,
          url: `https://github.com/${config.owner}/${config.repo}/issues/${config.issue_id || 123}`,
          htmlUrl: `https://github.com/${config.owner}/${config.repo}/issues/${config.issue_id || 123}`,
          timestamp,
        },
        metadata: { nodeType: "action", subtype: "github_create_issue" },
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/actions/drive-upload-file.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const driveUploadFile: Integration = createIntegration({
  id: "drive_upload_file",
  name: "Google Drive Upload File",
  category: "action",
  description: "Upload files to Google Drive",
  icon: "google",
  version: "1.0.0",

  auth: {
    type: "oauth2",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "filename",
        type: "text",
        label: "Filename",
        placeholder: "document.txt",
        required: true,
        supportExpressions: true,
      },
      {
        key: "content",
        type: "textarea",
        label: "File Content",
        placeholder: "File content or base64 encoded data",
        required: true,
        supportExpressions: true,
      },
      {
        key: "mime_type",
        type: "text",
        label: "MIME Type",
        placeholder: "text/plain",
        required: false,
      },
      {
        key: "parent_folder_id",
        type: "text",
        label: "Parent Folder ID",
        placeholder: "1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms",
        required: false,
      },
      {
        key: "description",
        type: "textarea",
        label: "Description",
        placeholder: "File description",
        required: false,
      },
      {
        key: "permissions",
        type: "select",
        label: "Permissions",
        required: false,
        options: [
          { label: "Private", value: "private" },
          { label: "Anyone with link can view", value: "anyoneWithLink" },
          { label: "Anyone with link can edit", value: "anyoneWithLinkEdit" },
          { label: "Public", value: "public" },
        ],
      },
    ],
    required: ["filename", "content"],
  },

  executor: {
    async execute(config) {
      await new Promise((resolve) => setTimeout(resolve, 1800));
      const timestamp = new Date().toISOString();

      return {
        success: true,
        data: {
          fileId: "1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms",
          filename: config.filename as string,
          mimeType: (config.mime_type as string) || "text/plain",
          parentFolderId: (config.parent_folder_id as string) || "",
          description: (config.description as string) || "",
          permissions: (config.permissions as string) || "private",
          size: (config.content as string).length,
          createdTime: timestamp,
          modifiedTime: timestamp,
          webViewLink: `https://drive.google.com/file/d/${
            config.file_id || "1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms"
          }/view`,
          webContentLink: `https://drive.google.com/uc?id=${
            config.file_id || "1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms"
          }`,
          timestamp,
        },
        metadata: { nodeType: "action", subtype: "drive_upload_file" },
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/actions/sendgrid-send-email.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const sendgridSendEmail: Integration = createIntegration({
  id: "sendgrid_send_email",
  name: "SendGrid Send Email",
  category: "action",
  description: "Send emails via SendGrid",
  icon: "sendgrid",
  version: "1.0.0",

  auth: {
    type: "api_key",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "to",
        type: "email",
        label: "To Email",
        placeholder: "recipient@example.com",
        required: true,
      },
      {
        key: "from",
        type: "email",
        label: "From Email",
        placeholder: "sender@yourdomain.com",
        required: true,
      },
      {
        key: "subject",
        type: "text",
        label: "Subject",
        placeholder: "Email subject",
        required: true,
        supportExpressions: true,
      },
      {
        key: "content",
        type: "textarea",
        label: "Email Content",
        placeholder: "Email body content...",
        required: true,
        supportExpressions: true,
      },
      {
        key: "content_type",
        type: "select",
        label: "Content Type",
        required: false,
        options: [
          { label: "Text", value: "text/plain" },
          { label: "HTML", value: "text/html" },
        ],
      },
      {
        key: "template_id",
        type: "text",
        label: "Template ID",
        placeholder: "d-1234567890abcdef",
        required: false,
      },
      {
        key: "template_data",
        type: "textarea",
        label: "Template Data (JSON)",
        placeholder: '{"name": "John", "company": "Acme Corp"}',
        required: false,
        supportExpressions: true,
      },
    ],
    required: ["to", "from", "subject", "content"],
  },

  executor: {
    async execute(config) {
      await new Promise((resolve) => setTimeout(resolve, 1500));
      const timestamp = new Date().toISOString();

      return {
        success: true,
        data: {
          messageId: "abc123def456ghi789",
          to: config.to as string,
          from: config.from as string,
          subject: config.subject as string,
          content: config.content as string,
          contentType: (config.content_type as string) || "text/plain",
          templateId: (config.template_id as string) || "",
          templateData: config.template_data
            ? JSON.parse(config.template_data as string)
            : {},
          status: "delivered",
          sentAt: timestamp,
          timestamp,
        },
        metadata: { nodeType: "action", subtype: "sendgrid_send_email" },
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/actions/sms-send.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const smsSend: Integration = createIntegration({
  id: "sms_send",
  name: "Send SMS",
  category: "action",
  description: "Send SMS messages via Twilio",
  icon: "message-circle",
  version: "1.0.0",

  auth: {
    type: "api_key",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "to_number",
        type: "text",
        label: "To Phone Number",
        placeholder: "+1234567890",
        required: true,
      },
      {
        key: "from_number",
        type: "text",
        label: "From Phone Number",
        placeholder: "+1234567890",
        required: true,
      },
      {
        key: "message",
        type: "textarea",
        label: "Message",
        placeholder: "Your verification code is: 123456",
        required: true,
        supportExpressions: true,
      },
      {
        key: "media_urls",
        type: "textarea",
        label: "Media URLs (JSON array)",
        placeholder: '["https://example.com/image.jpg"]',
        required: false,
        supportExpressions: true,
      },
    ],
    required: ["to_number", "from_number", "message"],
  },

  executor: {
    async execute(config) {
      await new Promise((resolve) => setTimeout(resolve, 800));
      const timestamp = new Date().toISOString();

      return {
        success: true,
        data: {
          messageId: "SM1234567890abcdef",
          toNumber: config.to_number as string,
          fromNumber: config.from_number as string,
          message: config.message as string,
          mediaUrls: config.media_urls
            ? JSON.parse(config.media_urls as string)
            : [],
          status: "delivered",
          sentAt: timestamp,
          deliveredAt: timestamp,
          price: 0.0075,
          priceUnit: "USD",
          timestamp,
        },
        metadata: { nodeType: "action", subtype: "sms_send" },
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/actions/mailchimp-add-subscriber.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const mailchimpAddSubscriber: Integration = createIntegration({
  id: "mailchimp_add_subscriber",
  name: "Mailchimp Add Subscriber",
  category: "action",
  description: "Add subscribers to Mailchimp lists",
  icon: "mailchimp",
  version: "1.0.0",

  auth: {
    type: "api_key",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "list_id",
        type: "text",
        label: "Audience ID",
        placeholder: "a1b2c3d4e5",
        required: true,
      },
      {
        key: "email",
        type: "email",
        label: "Email Address",
        placeholder: "subscriber@example.com",
        required: true,
      },
      {
        key: "first_name",
        type: "text",
        label: "First Name",
        placeholder: "John",
        required: false,
        supportExpressions: true,
      },
      {
        key: "last_name",
        type: "text",
        label: "Last Name",
        placeholder: "Doe",
        required: false,
        supportExpressions: true,
      },
      {
        key: "merge_fields",
        type: "textarea",
        label: "Merge Fields (JSON)",
        placeholder: '{"PHONE": "+1-555-123-4567", "COMPANY": "Acme Corp"}',
        required: false,
        supportExpressions: true,
      },
      {
        key: "tags",
        type: "text",
        label: "Tags (comma-separated)",
        placeholder: "newsletter, vip, customer",
        required: false,
      },
      {
        key: "status",
        type: "select",
        label: "Subscription Status",
        required: false,
        options: [
          { label: "Subscribed", value: "subscribed" },
          { label: "Unsubscribed", value: "unsubscribed" },
          { label: "Cleaned", value: "cleaned" },
          { label: "Pending", value: "pending" },
        ],
      },
    ],
    required: ["list_id", "email"],
  },

  executor: {
    async execute(config) {
      await new Promise((resolve) => setTimeout(resolve, 1200));
      const timestamp = new Date().toISOString();

      return {
        success: true,
        data: {
          subscriberId: "a1b2c3d4e5f6g7h8i9j0",
          listId: config.list_id as string,
          email: config.email as string,
          firstName: (config.first_name as string) || "",
          lastName: (config.last_name as string) || "",
          mergeFields: config.merge_fields
            ? JSON.parse(config.merge_fields as string)
            : {},
          tags: config.tags
            ? (config.tags as string).split(",").map((tag) => tag.trim())
            : [],
          status: (config.status as string) || "subscribed",
          subscribedAt: timestamp,
          lastChanged: timestamp,
          timestamp,
        },
        metadata: { nodeType: "action", subtype: "mailchimp_add_subscriber" },
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/actions/twitter-post-tweet.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const twitterPostTweet: Integration = createIntegration({
  id: "twitter_post_tweet",
  name: "Twitter Post Tweet",
  category: "action",
  description: "Post tweets to Twitter/X",
  icon: "twitter",
  version: "1.0.0",

  auth: {
    type: "oauth2",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "text",
        type: "textarea",
        label: "Tweet Text",
        placeholder: "What's happening?",
        required: true,
        supportExpressions: true,
      },
      {
        key: "reply_to",
        type: "text",
        label: "Reply To Tweet ID",
        placeholder: "1234567890123456789",
        required: false,
      },
      {
        key: "media_ids",
        type: "text",
        label: "Media IDs (comma-separated)",
        placeholder: "1234567890123456789, 9876543210987654321",
        required: false,
      },
      {
        key: "poll_options",
        type: "textarea",
        label: "Poll Options (JSON array)",
        placeholder: '["Option 1", "Option 2", "Option 3", "Option 4"]',
        required: false,
      },
      {
        key: "poll_duration_minutes",
        type: "number",
        label: "Poll Duration (minutes)",
        placeholder: "1440",
        required: false,
      },
    ],
    required: ["text"],
  },

  executor: {
    async execute(config) {
      await new Promise((resolve) => setTimeout(resolve, 1200));
      const timestamp = new Date().toISOString();
      
      return {
        success: true,
        data: {
          tweetId: "1234567890123456789",
          text: config.text as string,
          replyTo: config.reply_to as string || "",
          mediaIds: config.media_ids ? (config.media_ids as string).split(',').map(id => id.trim()) : [],
          pollOptions: config.poll_options ? JSON.parse(config.poll_options as string) : [],
          pollDurationMinutes: config.poll_duration_minutes as number || 0,
          createdAt: timestamp,
          authorId: "9876543210987654321",
          retweetCount: 0,
          likeCount: 0,
          replyCount: 0,
          quoteCount: 0,
          timestamp,
        },
        metadata: { nodeType: "action", subtype: "twitter_post_tweet" },
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/actions/slack-send-message.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from '../utils';
import type { Integration, ValidationResult } from '../types';

export const slackSendMessage: Integration = createIntegration({
  id: "slack_send_message",
  name: "Send Slack Message",
  category: "action",
  description: "Send a message to a Slack channel",
  icon: "slack",
  version: "1.0.0",

  auth: {
    type: "oauth2",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "channel",
        type: "select",
        label: "Channel",
        placeholder: "#general",
        required: true,
        options: [
          { label: "#general", value: "general" },
          { label: "#random", value: "random" },
          { label: "#dev", value: "dev" },
        ],
      },
      {
        key: "message",
        type: "textarea",
        label: "Message",
        placeholder:
          "New deployment by {{$node.webhook-1.data.commits.0.author}}",
        required: true,
        supportExpressions: true,
      },
      {
        key: "username",
        type: "text",
        label: "Bot Username",
        placeholder: "WorkflowBot",
        required: false,
      },
    ],
    required: ["channel", "message"],
  },

  executor: {
    async execute(config) {
      await new Promise((resolve) => setTimeout(resolve, 800));
      const timestamp = new Date().toISOString();
      return {
        success: true,
        data: {
          messageId: "1234567890.123456",
          channel: config.channel as string,
          message: config.message as string,
          timestamp,
          user: "U123ABCDEF",
          permalink:
            "https://workspace.slack.com/archives/C123/p1609459200123456",
        },
        metadata: { nodeType: "action", subtype: "slack_send_message" },
      };
    },

    validate(config): ValidationResult {
      const errors: Record<string, string> = {};

      if (!config.channel) errors.channel = "Channel is required";
      if (!config.message) errors.message = "Message is required";

      return {
        valid: Object.keys(errors).length === 0,
        errors,
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/actions/postgres-insert.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const postgresInsert: Integration = createIntegration({
  id: "postgres_insert",
  name: "PostgreSQL Insert",
  category: "action",
  description: "Insert records into PostgreSQL database",
  icon: "postgresql",
  version: "1.0.0",

  auth: {
    type: "api_key",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "connection_string",
        type: "text",
        label: "Connection String",
        placeholder: "postgresql://user:pass@host:5432/db",
        required: true,
      },
      {
        key: "table",
        type: "text",
        label: "Table Name",
        placeholder: "users",
        required: true,
      },
      {
        key: "data",
        type: "textarea",
        label: "Data (JSON)",
        placeholder: '{"name": "John", "email": "john@example.com"}',
        required: true,
        supportExpressions: true,
      },
      {
        key: "return_fields",
        type: "text",
        label: "Return Fields",
        placeholder: "id, created_at",
        required: false,
      },
    ],
    required: ["connection_string", "table", "data"],
  },

  executor: {
    async execute(config) {
      await new Promise((resolve) => setTimeout(resolve, 1200));
      const timestamp = new Date().toISOString();

      return {
        success: true,
        data: {
          table: config.table as string,
          insertedRows: 1,
          returnedData: {
            id: 12345,
            name: "John Doe",
            email: "john@example.com",
            created_at: timestamp,
          },
          executionTime: "45ms",
          timestamp,
        },
        metadata: { nodeType: "action", subtype: "postgres_insert" },
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/actions/s3-upload-file.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const s3UploadFile: Integration = createIntegration({
  id: "s3_upload_file",
  name: "AWS S3 Upload File",
  category: "action",
  description: "Upload files to AWS S3 bucket",
  icon: "aws",
  version: "1.0.0",

  auth: {
    type: "api_key",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "bucket",
        type: "text",
        label: "Bucket Name",
        placeholder: "my-upload-bucket",
        required: true,
      },
      {
        key: "key",
        type: "text",
        label: "Object Key",
        placeholder: "uploads/file.txt",
        required: true,
        supportExpressions: true,
      },
      {
        key: "file_content",
        type: "textarea",
        label: "File Content",
        placeholder: "File content or base64 encoded data",
        required: true,
        supportExpressions: true,
      },
      {
        key: "content_type",
        type: "text",
        label: "Content Type",
        placeholder: "text/plain",
        required: false,
      },
      {
        key: "metadata",
        type: "textarea",
        label: "Metadata (JSON)",
        placeholder: '{"author": "John Doe", "version": "1.0"}',
        required: false,
        supportExpressions: true,
      },
      {
        key: "acl",
        type: "select",
        label: "Access Control",
        required: false,
        options: [
          { label: "Private", value: "private" },
          { label: "Public Read", value: "public-read" },
          { label: "Public Read Write", value: "public-read-write" },
          { label: "Authenticated Read", value: "authenticated-read" },
        ],
      },
    ],
    required: ["bucket", "key", "file_content"],
  },

  executor: {
    async execute(config) {
      await new Promise((resolve) => setTimeout(resolve, 2000));
      const timestamp = new Date().toISOString();
      
      return {
        success: true,
        data: {
          bucket: config.bucket as string,
          key: config.key as string,
          etag: '"abc123def456ghi789"',
          versionId: "null",
          location: `https://${config.bucket}.s3.amazonaws.com/${config.key}`,
          contentType: config.content_type as string || "application/octet-stream",
          metadata: config.metadata ? JSON.parse(config.metadata as string) : {},
          acl: config.acl as string || "private",
          size: (config.file_content as string).length,
          lastModified: timestamp,
          timestamp,
        },
        metadata: { nodeType: "action", subtype: "s3_upload_file" },
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/actions/telegram-send-message.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const telegramSendMessage: Integration = createIntegration({
  id: "telegram_send_message",
  name: "Send Telegram Message",
  category: "action",
  description: "Send messages via Telegram Bot",
  icon: "telegram",
  version: "1.0.0",

  auth: {
    type: "api_key",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "chat_id",
        type: "text",
        label: "Chat ID",
        placeholder: "123456789 or @channel_name",
        required: true,
      },
      {
        key: "message",
        type: "textarea",
        label: "Message",
        placeholder: "Hello from the automation!",
        required: true,
        supportExpressions: true,
      },
      {
        key: "parse_mode",
        type: "select",
        label: "Parse Mode",
        required: false,
        options: [
          { label: "Plain Text", value: "text" },
          { label: "HTML", value: "HTML" },
          { label: "Markdown", value: "MarkdownV2" },
        ],
      },
      {
        key: "disable_web_page_preview",
        type: "boolean",
        label: "Disable Web Page Preview",
        required: false,
      },
      {
        key: "disable_notification",
        type: "boolean",
        label: "Silent Message",
        required: false,
      },
    ],
    required: ["chat_id", "message"],
  },

  executor: {
    async execute(config) {
      await new Promise((resolve) => setTimeout(resolve, 600));
      const timestamp = new Date().toISOString();

      return {
        success: true,
        data: {
          messageId: 12345,
          chatId: config.chat_id as string,
          message: config.message as string,
          parseMode: (config.parse_mode as string) || "text",
          disableWebPagePreview:
            (config.disable_web_page_preview as boolean) || false,
          disableNotification:
            (config.disable_notification as boolean) || false,
          timestamp,
          from: {
            id: 987654321,
            isBot: true,
            firstName: "WorkflowBot",
            username: "workflow_bot",
          },
          chat: {
            id: 123456789,
            type: "private",
            title: "Test Chat",
          },
        },
        metadata: { nodeType: "action", subtype: "telegram_send_message" },
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/actions/paypal-send-payment.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const paypalSendPayment: Integration = createIntegration({
  id: "paypal_send_payment",
  name: "PayPal Send Payment",
  category: "action",
  description: "Send payments via PayPal",
  icon: "paypal",
  version: "1.0.0",

  auth: {
    type: "oauth2",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "recipient_email",
        type: "email",
        label: "Recipient Email",
        placeholder: "recipient@example.com",
        required: true,
      },
      {
        key: "amount",
        type: "number",
        label: "Amount",
        placeholder: "25.00",
        required: true,
      },
      {
        key: "currency",
        type: "select",
        label: "Currency",
        required: true,
        options: [
          { label: "USD", value: "USD" },
          { label: "EUR", value: "EUR" },
          { label: "GBP", value: "GBP" },
          { label: "CAD", value: "CAD" },
          { label: "AUD", value: "AUD" },
        ],
      },
      {
        key: "note",
        type: "textarea",
        label: "Note",
        placeholder: "Payment for services rendered",
        required: false,
        supportExpressions: true,
      },
      {
        key: "subject",
        type: "text",
        label: "Subject",
        placeholder: "Payment from WorkflowBot",
        required: false,
      },
    ],
    required: ["recipient_email", "amount", "currency"],
  },

  executor: {
    async execute(config) {
      await new Promise((resolve) => setTimeout(resolve, 1800));
      const timestamp = new Date().toISOString();

      return {
        success: true,
        data: {
          paymentId: "PAY-1234567890ABCDEF",
          recipientEmail: config.recipient_email as string,
          amount: config.amount as number,
          currency: config.currency as string,
          status: "COMPLETED",
          note: (config.note as string) || "",
          subject: (config.subject as string) || "Payment from WorkflowBot",
          timestamp,
          fee: (config.amount as number) * 0.029 + 0.3,
          netAmount:
            (config.amount as number) -
            ((config.amount as number) * 0.029 + 0.3),
        },
        metadata: { nodeType: "action", subtype: "paypal_send_payment" },
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/actions/zoom-create-meeting.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const zoomCreateMeeting: Integration = createIntegration({
  id: "zoom_create_meeting",
  name: "Zoom Create Meeting",
  category: "action",
  description: "Schedule Zoom meetings",
  icon: "zoom",
  version: "1.0.0",

  auth: {
    type: "oauth2",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "topic",
        type: "text",
        label: "Meeting Topic",
        placeholder: "Team Standup",
        required: true,
        supportExpressions: true,
      },
      {
        key: "start_time",
        type: "text",
        label: "Start Time",
        placeholder: "2024-12-01T10:00:00Z",
        required: true,
      },
      {
        key: "duration",
        type: "number",
        label: "Duration (minutes)",
        placeholder: "30",
        required: false,
      },
      {
        key: "password",
        type: "text",
        label: "Meeting Password",
        placeholder: "123456",
        required: false,
      },
      {
        key: "settings",
        type: "textarea",
        label: "Settings (JSON)",
        placeholder:
          '{"host_video": true, "participant_video": true, "join_before_host": true}',
        required: false,
      },
    ],
    required: ["topic", "start_time"],
  },

  executor: {
    async execute(config) {
      await new Promise((resolve) => setTimeout(resolve, 1000));
      const timestamp = new Date().toISOString();

      return {
        success: true,
        data: {
          meetingId: 123456789,
          topic: config.topic as string,
          startTime: config.start_time as string,
          duration: (config.duration as number) || 30,
          password: (config.password as string) || "",
          settings: config.settings
            ? JSON.parse(config.settings as string)
            : {},
          joinUrl: "https://zoom.us/j/123456789?pwd=abc123def456",
          startUrl: "https://zoom.us/s/123456789?zak=abc123def456",
          createdAt: timestamp,
          hostEmail: "host@example.com",
          status: "waiting",
          timestamp,
        },
        metadata: { nodeType: "action", subtype: "zoom_create_meeting" },
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/actions/delay.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from '../utils';
import type { Integration } from '../types';

export const delay: Integration = createIntegration({
  id: "delay",
  name: "Delay",
  category: "action",
  description: "Wait for a specified amount of time",
  icon: "clock",
  version: "1.0.0",

  schema: {
    fields: [
      {
        key: "amount",
        type: "number",
        label: "Delay Amount",
        placeholder: "5",
        required: true,
      },
      {
        key: "unit",
        type: "select",
        label: "Time Unit",
        required: true,
        options: [
          { label: "Seconds", value: "seconds" },
          { label: "Minutes", value: "minutes" },
          { label: "Hours", value: "hours" },
        ],
      },
    ],
    required: ["amount", "unit"],
  },

  executor: {
    async execute(config) {
      const amount = Number(config.amount) || 1;
      const unit = config.unit as string;

      let delayMs = amount * 1000; // default to seconds
      if (unit === "minutes") delayMs = amount * 60 * 1000;
      if (unit === "hours") delayMs = amount * 60 * 60 * 1000;

      // For demo purposes, we'll just simulate the delay
      await new Promise((resolve) =>
        setTimeout(resolve, Math.min(delayMs, 2000))
      );

      const timestamp = new Date().toISOString();
      return {
        success: true,
        data: {
          delayAmount: amount,
          delayUnit: unit,
          actualDelayMs: delayMs,
          timestamp,
        },
        metadata: { nodeType: "action", subtype: "delay" },
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/actions/airtable-create-record.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const airtableCreateRecord: Integration = createIntegration({
  id: "airtable_create_record",
  name: "Airtable Create Record",
  category: "action",
  description: "Create records in Airtable base",
  icon: "airtable",
  version: "1.0.0",

  auth: {
    type: "api_key",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "base_id",
        type: "text",
        label: "Base ID",
        placeholder: "appXXXXXXXXXXXXXX",
        required: true,
      },
      {
        key: "table_id",
        type: "text",
        label: "Table ID",
        placeholder: "tblXXXXXXXXXXXXXX",
        required: true,
      },
      {
        key: "fields",
        type: "textarea",
        label: "Fields (JSON)",
        placeholder: '{"Name": "John Doe", "Email": "john@example.com", "Status": "Active"}',
        required: true,
        supportExpressions: true,
      },
      {
        key: "typecast",
        type: "boolean",
        label: "Enable Type Casting",
        required: false,
      },
    ],
    required: ["base_id", "table_id", "fields"],
  },

  executor: {
    async execute(config) {
      await new Promise((resolve) => setTimeout(resolve, 1000));
      const timestamp = new Date().toISOString();
      
      return {
        success: true,
        data: {
          recordId: "recXXXXXXXXXXXXXX",
          baseId: config.base_id as string,
          tableId: config.table_id as string,
          fields: JSON.parse(config.fields as string),
          createdTime: timestamp,
          typecast: config.typecast as boolean || false,
          timestamp,
        },
        metadata: { nodeType: "action", subtype: "airtable_create_record" },
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/actions/database-insert.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const databaseInsert: Integration = createIntegration({
  id: "database_insert",
  name: "Database Insert",
  category: "action",
  description: "Insert data into database tables",
  icon: "database",
  version: "1.0.0",

  auth: {
    type: "api_key",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "connection_string",
        type: "text",
        label: "Database Connection String",
        placeholder: "postgresql://user:pass@host:5432/db or mysql://user:pass@host:3306/db",
        required: true,
        validation: (value: unknown) => {
          if (typeof value !== "string" || value.trim().length === 0) {
            return "Connection string is required";
          }
          return null;
        },
      },
      {
        key: "table_name",
        type: "text",
        label: "Table Name",
        placeholder: "users or customers",
        required: true,
        validation: (value: unknown) => {
          if (typeof value !== "string" || value.trim().length === 0) {
            return "Table name is required";
          }
          return null;
        },
      },
      {
        key: "data",
        type: "textarea",
        label: "Data to Insert (JSON)",
        placeholder: '{"name": "John Doe", "email": "john@example.com", "age": 30}',
        required: true,
        supportExpressions: true,
        validation: (value: unknown) => {
          if (typeof value !== "string" || value.trim().length === 0) {
            return "Data is required";
          }
          try {
            const parsed = JSON.parse(value);
            if (typeof parsed !== "object" || parsed === null || Array.isArray(parsed)) {
              return "Data must be a JSON object";
            }
            return null;
          } catch (e) {
            return "Invalid JSON format";
          }
        },
      },
      {
        key: "return_fields",
        type: "text",
        label: "Return Fields (comma-separated)",
        placeholder: "id, created_at, updated_at",
        required: false,
      },
      {
        key: "on_conflict",
        type: "select",
        label: "On Conflict Action",
        required: false,
        options: [
          { label: "Do Nothing", value: "do_nothing" },
          { label: "Update", value: "update" },
          { label: "Error", value: "error" },
        ],
      },
      {
        key: "conflict_fields",
        type: "text",
        label: "Conflict Fields (comma-separated)",
        placeholder: "email, username",
        required: false,
      },
      {
        key: "batch_mode",
        type: "boolean",
        label: "Batch Insert Mode",
        required: false,
      },
    ],
    required: ["connection_string", "table_name", "data"],
  },

  executor: {
    async execute(config) {
      // Simulate database operation delay
      await new Promise((resolve) => setTimeout(resolve, 800));
      
      const connectionString = config.connection_string as string;
      const tableName = config.table_name as string;
      const returnFields = config.return_fields as string;
      const onConflict = config.on_conflict as string;
      const conflictFields = config.conflict_fields as string;
      const batchMode = config.batch_mode as boolean || false;
      
      let data: Record<string, unknown> = {};
      try {
        data = JSON.parse(config.data as string);
        if (typeof data !== "object" || data === null || Array.isArray(data)) {
          return {
            success: false,
            error: "Data must be a JSON object",
            data: {
              timestamp: new Date().toISOString(),
            },
            metadata: { nodeType: "action", subtype: "database_insert" },
          };
        }
      } catch (e) {
        return {
          success: false,
          error: "Invalid JSON format for data",
          data: {
            timestamp: new Date().toISOString(),
          },
          metadata: { nodeType: "action", subtype: "database_insert" },
        };
      }

      // Mock database response
      const mockId = Math.floor(Math.random() * 1000000) + 1;
      const timestamp = new Date().toISOString();
      
      const returnedData: Record<string, unknown> = {
        id: mockId,
        ...data,
        created_at: timestamp,
        updated_at: timestamp,
      };

      // Filter returned data based on return_fields
      let finalReturnedData = returnedData;
      if (returnFields) {
        const fieldsToReturn = returnFields.split(",").map(field => field.trim());
        finalReturnedData = Object.fromEntries(
          Object.entries(returnedData).filter(([key]) => 
            fieldsToReturn.includes(key)
          )
        );
      }

      return {
        success: true,
        data: {
          table: tableName,
          insertedRows: 1,
          returnedData: finalReturnedData,
          allReturnedData: returnedData,
          returnFields: returnFields ? returnFields.split(",").map(f => f.trim()) : null,
          onConflict: onConflict || null,
          conflictFields: conflictFields ? conflictFields.split(",").map(f => f.trim()) : null,
          batchMode,
          executionTime: "45ms",
          timestamp,
          connectionString: connectionString.replace(/\/\/.*@/, "//***:***@"), // Mask credentials
        },
        metadata: { nodeType: "action", subtype: "database_insert" },
      };
    },

    validate(config) {
      const errors: Record<string, string> = {};

      if (!config.connection_string) {
        errors.connection_string = "Connection string is required";
      }

      if (!config.table_name) {
        errors.table_name = "Table name is required";
      }

      if (!config.data) {
        errors.data = "Data is required";
      } else {
        try {
          const parsed = JSON.parse(config.data as string);
          if (typeof parsed !== "object" || parsed === null || Array.isArray(parsed)) {
            errors.data = "Data must be a JSON object";
          }
        } catch (e) {
          errors.data = "Invalid JSON format for data";
        }
      }

      if (config.on_conflict === "update" && !config.conflict_fields) {
        errors.conflict_fields = "Conflict fields are required when using update conflict resolution";
      }

      return {
        valid: Object.keys(errors).length === 0,
        errors,
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/actions/hubspot-create-contact.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const hubspotCreateContact: Integration = createIntegration({
  id: "hubspot_create_contact",
  name: "HubSpot Create Contact",
  category: "action",
  description: "Create contacts in HubSpot CRM",
  icon: "hubspot",
  version: "1.0.0",

  auth: {
    type: "oauth2",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "email",
        type: "email",
        label: "Email",
        placeholder: "contact@example.com",
        required: true,
      },
      {
        key: "firstname",
        type: "text",
        label: "First Name",
        placeholder: "John",
        required: false,
        supportExpressions: true,
      },
      {
        key: "lastname",
        type: "text",
        label: "Last Name",
        placeholder: "Doe",
        required: false,
        supportExpressions: true,
      },
      {
        key: "phone",
        type: "text",
        label: "Phone",
        placeholder: "+1-555-123-4567",
        required: false,
      },
      {
        key: "company",
        type: "text",
        label: "Company",
        placeholder: "Acme Corp",
        required: false,
        supportExpressions: true,
      },
      {
        key: "jobtitle",
        type: "text",
        label: "Job Title",
        placeholder: "Software Engineer",
        required: false,
      },
      {
        key: "lifecyclestage",
        type: "select",
        label: "Lifecycle Stage",
        required: false,
        options: [
          { label: "Lead", value: "lead" },
          {
            label: "Marketing Qualified Lead",
            value: "marketingqualifiedlead",
          },
          { label: "Sales Qualified Lead", value: "salesqualifiedlead" },
          { label: "Opportunity", value: "opportunity" },
          { label: "Customer", value: "customer" },
          { label: "Evangelist", value: "evangelist" },
          { label: "Other", value: "other" },
        ],
      },
    ],
    required: ["email"],
  },

  executor: {
    async execute(config) {
      await new Promise((resolve) => setTimeout(resolve, 1200));
      const timestamp = new Date().toISOString();

      return {
        success: true,
        data: {
          contactId: 12345,
          email: config.email as string,
          firstname: (config.firstname as string) || "",
          lastname: (config.lastname as string) || "",
          phone: (config.phone as string) || "",
          company: (config.company as string) || "",
          jobtitle: (config.jobtitle as string) || "",
          lifecyclestage: (config.lifecyclestage as string) || "lead",
          createdAt: timestamp,
          updatedAt: timestamp,
          properties: {
            email: config.email as string,
            firstname: (config.firstname as string) || "",
            lastname: (config.lastname as string) || "",
            phone: (config.phone as string) || "",
            company: (config.company as string) || "",
            jobtitle: (config.jobtitle as string) || "",
            lifecyclestage: (config.lifecyclestage as string) || "lead",
          },
          timestamp,
        },
        metadata: { nodeType: "action", subtype: "hubspot_create_contact" },
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/actions/redis-set.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const redisSet: Integration = createIntegration({
  id: "redis_set",
  name: "Redis Set",
  category: "action",
  description: "Set key-value pairs in Redis",
  icon: "redis",
  version: "1.0.0",

  auth: {
    type: "api_key",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "host",
        type: "text",
        label: "Redis Host",
        placeholder: "localhost",
        required: true,
      },
      {
        key: "port",
        type: "number",
        label: "Redis Port",
        placeholder: "6379",
        required: false,
      },
      {
        key: "key",
        type: "text",
        label: "Key",
        placeholder: "user:123:profile",
        required: true,
        supportExpressions: true,
      },
      {
        key: "value",
        type: "textarea",
        label: "Value",
        placeholder: "Value to store",
        required: true,
        supportExpressions: true,
      },
      {
        key: "ttl",
        type: "number",
        label: "TTL (seconds)",
        placeholder: "3600",
        required: false,
      },
      {
        key: "expire_mode",
        type: "select",
        label: "Expire Mode",
        required: false,
        options: [
          { label: "EX (seconds)", value: "EX" },
          { label: "PX (milliseconds)", value: "PX" },
          { label: "EXAT (timestamp)", value: "EXAT" },
          { label: "PXAT (timestamp ms)", value: "PXAT" },
        ],
      },
    ],
    required: ["host", "key", "value"],
  },

  executor: {
    async execute(config) {
      await new Promise((resolve) => setTimeout(resolve, 300));
      const timestamp = new Date().toISOString();

      return {
        success: true,
        data: {
          host: config.host as string,
          port: (config.port as number) || 6379,
          key: config.key as string,
          value: config.value as string,
          ttl: (config.ttl as number) || null,
          expireMode: (config.expire_mode as string) || "EX",
          result: "OK",
          timestamp,
        },
        metadata: { nodeType: "action", subtype: "redis_set" },
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/actions/cloudinary-upload-image.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const cloudinaryUploadImage: Integration = createIntegration({
  id: "cloudinary_upload_image",
  name: "Cloudinary Upload Image",
  category: "action",
  description: "Upload and transform images with Cloudinary",
  icon: "cloudinary",
  version: "1.0.0",

  auth: {
    type: "api_key",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "file",
        type: "textarea",
        label: "File (Base64 or URL)",
        placeholder: "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQ...",
        required: true,
        supportExpressions: true,
      },
      {
        key: "folder",
        type: "text",
        label: "Folder",
        placeholder: "my-app/uploads",
        required: false,
      },
      {
        key: "public_id",
        type: "text",
        label: "Public ID",
        placeholder: "my-image",
        required: false,
      },
      {
        key: "transformations",
        type: "textarea",
        label: "Transformations (JSON)",
        placeholder: '{"width": 800, "height": 600, "crop": "fill", "quality": "auto"}',
        required: false,
        supportExpressions: true,
      },
      {
        key: "tags",
        type: "text",
        label: "Tags (comma-separated)",
        placeholder: "profile, avatar, user",
        required: false,
      },
    ],
    required: ["file"],
  },

  executor: {
    async execute(config) {
      await new Promise((resolve) => setTimeout(resolve, 2000));
      const timestamp = new Date().toISOString();
      
      return {
        success: true,
        data: {
          publicId: config.public_id as string || "my-app/image_123",
          url: "https://res.cloudinary.com/demo/image/upload/v1234567890/my-app/image_123.jpg",
          secureUrl: "https://res.cloudinary.com/demo/image/upload/v1234567890/my-app/image_123.jpg",
          width: 800,
          height: 600,
          format: "jpg",
          resourceType: "image",
          bytes: 12345,
          folder: config.folder as string || "",
          tags: config.tags ? (config.tags as string).split(',').map(tag => tag.trim()) : [],
          transformations: config.transformations ? JSON.parse(config.transformations as string) : {},
          createdAt: timestamp,
          timestamp,
        },
        metadata: { nodeType: "action", subtype: "cloudinary_upload_image" },
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/actions/jira-create-issue.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const jiraCreateIssue: Integration = createIntegration({
  id: "jira_create_issue",
  name: "Jira Create Issue",
  category: "action",
  description: "Create issues in Jira",
  icon: "jira",
  version: "1.0.0",

  auth: {
    type: "oauth2",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "project_key",
        type: "text",
        label: "Project Key",
        placeholder: "PROJ",
        required: true,
      },
      {
        key: "issue_type",
        type: "select",
        label: "Issue Type",
        required: true,
        options: [
          { label: "Bug", value: "Bug" },
          { label: "Story", value: "Story" },
          { label: "Task", value: "Task" },
          { label: "Epic", value: "Epic" },
          { label: "Subtask", value: "Subtask" },
        ],
      },
      {
        key: "summary",
        type: "text",
        label: "Summary",
        placeholder: "Brief description of the issue",
        required: true,
        supportExpressions: true,
      },
      {
        key: "description",
        type: "textarea",
        label: "Description",
        placeholder: "Detailed description of the issue...",
        required: false,
        supportExpressions: true,
      },
      {
        key: "priority",
        type: "select",
        label: "Priority",
        required: false,
        options: [
          { label: "Highest", value: "Highest" },
          { label: "High", value: "High" },
          { label: "Medium", value: "Medium" },
          { label: "Low", value: "Low" },
          { label: "Lowest", value: "Lowest" },
        ],
      },
      {
        key: "assignee",
        type: "text",
        label: "Assignee",
        placeholder: "username",
        required: false,
      },
      {
        key: "labels",
        type: "text",
        label: "Labels (comma-separated)",
        placeholder: "bug, frontend, high-priority",
        required: false,
      },
    ],
    required: ["project_key", "issue_type", "summary"],
  },

  executor: {
    async execute(config) {
      await new Promise((resolve) => setTimeout(resolve, 1200));
      const timestamp = new Date().toISOString();
      
      return {
        success: true,
        data: {
          issueId: "PROJ-123",
          key: "PROJ-123",
          projectKey: config.project_key as string,
          issueType: config.issue_type as string,
          summary: config.summary as string,
          description: config.description as string || "",
          priority: config.priority as string || "Medium",
          assignee: config.assignee as string || "",
          labels: config.labels ? (config.labels as string).split(',').map(label => label.trim()) : [],
          status: "To Do",
          created: timestamp,
          updated: timestamp,
          reporter: "current-user",
          url: `https://company.atlassian.net/browse/${config.project_key}-123`,
          timestamp,
        },
        metadata: { nodeType: "action", subtype: "jira_create_issue" },
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/actions/api-request.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const apiRequest: Integration = createIntegration({
  id: "api_request",
  name: "API Request",
  category: "action",
  description: "Make an HTTP API request",
  icon: "globe",
  version: "1.0.0",

  schema: {
    fields: [
      {
        key: "url",
        type: "url",
        label: "API Endpoint",
        placeholder: "https://api.example.com/endpoint",
        required: true,
      },
      {
        key: "method",
        type: "select",
        label: "HTTP Method",
        required: true,
        options: [
          { label: "GET", value: "GET" },
          { label: "POST", value: "POST" },
          { label: "PUT", value: "PUT" },
          { label: "DELETE", value: "DELETE" },
        ],
      },
      {
        key: "headers",
        type: "textarea",
        label: "Headers (JSON)",
        placeholder: '{"Authorization": "Bearer token"}',
        required: false,
      },
      {
        key: "body",
        type: "textarea",
        label: "Request Body (JSON)",
        placeholder:
          '{"user_id": "{{$node.webhook-1.data.user.id}}", "status": "{{$node.webhook-1.data.status}}"}',
        required: false,
        supportExpressions: true,
      },
    ],
    required: ["url", "method"],
  },

  executor: {
    async execute() {
      await new Promise((resolve) => setTimeout(resolve, 600));
      const timestamp = new Date().toISOString();
      return {
        success: true,
        data: {
          status: 200,
          statusText: "OK",
          headers: {
            "content-type": "application/json",
            "x-ratelimit-remaining": "4999",
          },
          response: {
            id: 12345,
            name: "John Doe",
            email: "john@example.com",
            created_at: "2024-12-01T10:30:00Z",
          },
          responseTime: "245ms",
          timestamp,
        },
        metadata: { nodeType: "action", subtype: "api_request" },
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/actions/notion-create-page.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const notionCreatePage: Integration = createIntegration({
  id: "notion_create_page",
  name: "Notion Create Page",
  category: "action",
  description: "Create pages in Notion",
  icon: "notion",
  version: "1.0.0",

  auth: {
    type: "oauth2",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "parent_id",
        type: "text",
        label: "Parent Page/Database ID",
        placeholder: "12345678-1234-1234-1234-123456789abc",
        required: true,
      },
      {
        key: "title",
        type: "text",
        label: "Page Title",
        placeholder: "New Page Title",
        required: true,
        supportExpressions: true,
      },
      {
        key: "content",
        type: "textarea",
        label: "Page Content",
        placeholder: "Page content in Notion format...",
        required: false,
        supportExpressions: true,
      },
      {
        key: "properties",
        type: "textarea",
        label: "Properties (JSON)",
        placeholder:
          '{"Status": {"select": {"name": "In Progress"}}, "Priority": {"select": {"name": "High"}}}',
        required: false,
        supportExpressions: true,
      },
      {
        key: "icon",
        type: "text",
        label: "Page Icon",
        placeholder: "üöÄ",
        required: false,
      },
      {
        key: "cover",
        type: "url",
        label: "Cover Image URL",
        placeholder: "https://example.com/image.jpg",
        required: false,
      },
    ],
    required: ["parent_id", "title"],
  },

  executor: {
    async execute(config) {
      await new Promise((resolve) => setTimeout(resolve, 1200));
      const timestamp = new Date().toISOString();

      return {
        success: true,
        data: {
          pageId: "12345678-1234-1234-1234-123456789abc",
          parentId: config.parent_id as string,
          title: config.title as string,
          content: (config.content as string) || "",
          properties: config.properties
            ? JSON.parse(config.properties as string)
            : {},
          icon: (config.icon as string) || "",
          cover: (config.cover as string) || "",
          createdTime: timestamp,
          lastEditedTime: timestamp,
          url: `https://notion.so/${
            config.page_id || "12345678-1234-1234-1234-123456789abc"
          }`,
          archived: false,
          timestamp,
        },
        metadata: { nodeType: "action", subtype: "notion_create_page" },
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/actions/discord-send-message.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const discordSendMessage: Integration = createIntegration({
  id: "discord_send_message",
  name: "Send Discord Message",
  category: "action",
  description: "Send messages to Discord channels",
  icon: "discord",
  version: "1.0.0",

  auth: {
    type: "oauth2",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "channel_id",
        type: "text",
        label: "Channel ID",
        placeholder: "123456789012345678",
        required: true,
      },
      {
        key: "message",
        type: "textarea",
        label: "Message",
        placeholder: "Hello from the automation!",
        required: true,
        supportExpressions: true,
      },
      {
        key: "username",
        type: "text",
        label: "Bot Username",
        placeholder: "WorkflowBot",
        required: false,
      },
      {
        key: "avatar_url",
        type: "url",
        label: "Avatar URL",
        placeholder: "https://example.com/avatar.png",
        required: false,
      },
      {
        key: "tts",
        type: "boolean",
        label: "Text-to-Speech",
        required: false,
      },
    ],
    required: ["channel_id", "message"],
  },

  executor: {
    async execute(config) {
      await new Promise((resolve) => setTimeout(resolve, 800));
      const timestamp = new Date().toISOString();
      
      return {
        success: true,
        data: {
          messageId: "1234567890123456789",
          channelId: config.channel_id as string,
          message: config.message as string,
          username: config.username as string || "WorkflowBot",
          tts: config.tts as boolean || false,
          timestamp,
          guildId: "987654321098765432",
          authorId: "111222333444555666",
        },
        metadata: { nodeType: "action", subtype: "discord_send_message" },
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/actions/asana-create-task.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const asanaCreateTask: Integration = createIntegration({
  id: "asana_create_task",
  name: "Asana Create Task",
  category: "action",
  description: "Create tasks in Asana",
  icon: "asana",
  version: "1.0.0",

  auth: {
    type: "oauth2",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "name",
        type: "text",
        label: "Task Name",
        placeholder: "Complete project documentation",
        required: true,
        supportExpressions: true,
      },
      {
        key: "notes",
        type: "textarea",
        label: "Description",
        placeholder: "Detailed description of the task...",
        required: false,
        supportExpressions: true,
      },
      {
        key: "project_id",
        type: "text",
        label: "Project ID",
        placeholder: "123456789",
        required: false,
      },
      {
        key: "assignee_id",
        type: "text",
        label: "Assignee ID",
        placeholder: "987654321",
        required: false,
      },
      {
        key: "due_date",
        type: "text",
        label: "Due Date",
        placeholder: "2024-12-31",
        required: false,
      },
      {
        key: "priority",
        type: "select",
        label: "Priority",
        required: false,
        options: [
          { label: "Low", value: "low" },
          { label: "Medium", value: "medium" },
          { label: "High", value: "high" },
        ],
      },
    ],
    required: ["name"],
  },

  executor: {
    async execute(config) {
      await new Promise((resolve) => setTimeout(resolve, 1000));
      const timestamp = new Date().toISOString();

      return {
        success: true,
        data: {
          taskId: "123456789",
          name: config.name as string,
          notes: (config.notes as string) || "",
          projectId: (config.project_id as string) || "",
          assigneeId: (config.assignee_id as string) || "",
          dueDate: (config.due_date as string) || "",
          priority: (config.priority as string) || "medium",
          status: "incomplete",
          createdAt: timestamp,
          modifiedAt: timestamp,
          permalinkUrl: `https://app.asana.com/0/${
            config.project_id || "123456789"
          }/${config.task_id || "123456789"}`,
          timestamp,
        },
        metadata: { nodeType: "action", subtype: "asana_create_task" },
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/actions/ai.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const aiIntegration: Integration = createIntegration({
  id: "ai",
  name: "AI",
  category: "action",
  description: "LLM, image generation, text-to-speech, and speech-to-text",
  icon: "brain",
  version: "1.0.0",

  schema: {
    fields: [
      {
        key: "ai_mode",
        type: "select",
        label: "AI Mode",
        required: true,
        options: [
          { label: "Text Generation (LLM)", value: "llm" },
          { label: "Image Generation", value: "image" },
          { label: "Text to Speech", value: "tts" },
          { label: "Speech to Text", value: "stt" },
        ],
      },
      {
        key: "model",
        type: "select",
        label: "AI Model",
        required: true,
        options: [
          { label: "GPT-4", value: "gpt-4" },
          { label: "GPT-3.5 Turbo", value: "gpt-3.5-turbo" },
          { label: "Claude-3 Opus", value: "claude-3-opus" },
          { label: "Claude-3 Sonnet", value: "claude-3-sonnet" },
          { label: "DALL-E 3", value: "dall-e-3" },
          { label: "Midjourney", value: "midjourney" },
          { label: "Stable Diffusion", value: "stable-diffusion" },
          { label: "Whisper", value: "whisper" },
          { label: "ElevenLabs", value: "elevenlabs" },
        ],
      },
      {
        key: "prompt",
        type: "textarea",
        label: "Prompt/Input",
        placeholder:
          "Enter your prompt, text, or describe what you want to generate...",
        required: true,
        supportExpressions: true,
      },
      {
        key: "max_tokens",
        type: "number",
        label: "Max Tokens (LLM only)",
        placeholder: "1000",
        required: false,
      },
      {
        key: "temperature",
        type: "number",
        label: "Temperature/Creativity",
        placeholder: "0.7",
        required: false,
      },
      {
        key: "image_size",
        type: "select",
        label: "Image Size (Image generation only)",
        required: false,
        options: [
          { label: "1024x1024", value: "1024x1024" },
          { label: "1792x1024", value: "1792x1024" },
          { label: "1024x1792", value: "1024x1792" },
        ],
      },
      {
        key: "voice_id",
        type: "select",
        label: "Voice ID (TTS only)",
        required: false,
        options: [
          { label: "Rachel (Female)", value: "rachel" },
          { label: "Domingo (Male)", value: "domingo" },
          { label: "Bella (Female)", value: "bella" },
          { label: "Antoni (Male)", value: "antoni" },
        ],
      },
      {
        key: "language",
        type: "select",
        label: "Language (STT only)",
        required: false,
        options: [
          { label: "English", value: "en" },
          { label: "Spanish", value: "es" },
          { label: "French", value: "fr" },
          { label: "German", value: "de" },
          { label: "Japanese", value: "ja" },
        ],
      },
    ],
    required: ["ai_mode", "model", "prompt"],
  },

  executor: {
    async execute(config: Record<string, unknown>) {
      const {
        ai_mode,
        model,
        prompt,
        max_tokens,
        temperature,
        image_size,
        voice_id,
        language,
      } = config;

      // Simulate API call delay
      await new Promise((resolve) => setTimeout(resolve, 800));

      const timestamp = new Date().toISOString();
      const executionId = `ai_${Date.now()}_${Math.random()
        .toString(36)
        .substr(2, 9)}`;

      // Mock responses based on AI mode
      let response: Record<string, unknown> = {};

      switch (ai_mode) {
        case "llm":
          response = {
            text: `Here's a response to your prompt: "${prompt}"\n\nThis is a mock LLM response generated by ${model}. In a real implementation, this would be the actual AI-generated text based on your prompt. The response would be tailored to your specific request and would demonstrate the AI's understanding and capabilities.`,
            tokens_used: Math.floor(Math.random() * 500) + 100,
            finish_reason: "stop",
            model_used: model,
          };
          break;

        case "image":
          response = {
            image_url: `https://example.com/generated-images/${executionId}.png`,
            image_id: executionId,
            prompt: prompt,
            size: image_size || "1024x1024",
            model_used: model,
            generation_time: "2.3s",
          };
          break;

        case "tts":
          response = {
            audio_url: `https://example.com/generated-audio/${executionId}.mp3`,
            audio_id: executionId,
            text: prompt,
            voice_used: voice_id || "rachel",
            duration: "3.2s",
            sample_rate: "44100Hz",
          };
          break;

        case "stt":
          response = {
            text: "This is a mock transcription of the provided audio. In a real implementation, this would be the actual transcribed text from the audio file.",
            confidence: 0.95,
            language: language || "en",
            duration: "5.1s",
            words: 12,
          };
          break;
      }

      return {
        success: true,
        data: {
          ...response,
          execution_id: executionId,
          timestamp,
          ai_mode,
          model,
          prompt,
          config: {
            max_tokens,
            temperature,
            image_size,
            voice_id,
            language,
          },
        },
        metadata: {
          nodeType: "action",
          subtype: "ai",
          aiMode: ai_mode,
          model: model,
        },
      };
    },

    validate(config: Record<string, unknown>) {
      const errors: Record<string, string> = {};

      if (!config.ai_mode) {
        errors.ai_mode = "AI mode is required";
      }

      if (!config.model) {
        errors.model = "Model is required";
      }

      if (!config.prompt) {
        errors.prompt = "Prompt is required";
      }

      // Validate model compatibility with AI mode
      if (config.ai_mode && config.model) {
        const aiMode = config.ai_mode as string;
        const model = config.model as string;

        const validModels = {
          llm: ["gpt-4", "gpt-3.5-turbo", "claude-3-opus", "claude-3-sonnet"],
          image: ["dall-e-3", "midjourney", "stable-diffusion"],
          tts: ["elevenlabs"],
          stt: ["whisper"],
        };

        if (
          validModels[aiMode as keyof typeof validModels] &&
          !validModels[aiMode as keyof typeof validModels].includes(model)
        ) {
          errors.model = `Model ${model} is not compatible with ${aiMode} mode`;
        }
      }

      return {
        valid: Object.keys(errors).length === 0,
        errors,
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/actions/linkedin-create-post.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const linkedinCreatePost: Integration = createIntegration({
  id: "linkedin_create_post",
  name: "LinkedIn Create Post",
  category: "action",
  description: "Create posts on LinkedIn",
  icon: "linkedin",
  version: "1.0.0",

  auth: {
    type: "oauth2",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "content",
        type: "textarea",
        label: "Post Content",
        placeholder: "Share your thoughts...",
        required: true,
        supportExpressions: true,
      },
      {
        key: "visibility",
        type: "select",
        label: "Visibility",
        required: false,
        options: [
          { label: "Public", value: "PUBLIC" },
          { label: "Connections", value: "CONNECTIONS" },
          { label: "Group", value: "GROUP" },
        ],
      },
      {
        key: "group_id",
        type: "text",
        label: "Group ID (if posting to group)",
        placeholder: "123456789",
        required: false,
      },
      {
        key: "media_urls",
        type: "textarea",
        label: "Media URLs (JSON array)",
        placeholder: '["https://example.com/image1.jpg", "https://example.com/image2.jpg"]',
        required: false,
        supportExpressions: true,
      },
      {
        key: "article_url",
        type: "url",
        label: "Article URL",
        placeholder: "https://example.com/article",
        required: false,
      },
    ],
    required: ["content"],
  },

  executor: {
    async execute(config) {
      await new Promise((resolve) => setTimeout(resolve, 1500));
      const timestamp = new Date().toISOString();
      
      return {
        success: true,
        data: {
          postId: "urn:li:activity:1234567890123456789",
          content: config.content as string,
          visibility: config.visibility as string || "PUBLIC",
          groupId: config.group_id as string || "",
          mediaUrls: config.media_urls ? JSON.parse(config.media_urls as string) : [],
          articleUrl: config.article_url as string || "",
          createdAt: timestamp,
          authorId: "urn:li:person:123456789",
          likeCount: 0,
          commentCount: 0,
          shareCount: 0,
          timestamp,
        },
        metadata: { nodeType: "action", subtype: "linkedin_create_post" },
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/actions/stripe-create-payment.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const stripeCreatePayment: Integration = createIntegration({
  id: "stripe_create_payment",
  name: "Stripe Create Payment",
  category: "action",
  description: "Process payments with Stripe",
  icon: "stripe",
  version: "1.0.0",

  auth: {
    type: "api_key",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "amount",
        type: "number",
        label: "Amount (in cents)",
        placeholder: "2000",
        required: true,
      },
      {
        key: "currency",
        type: "select",
        label: "Currency",
        required: true,
        options: [
          { label: "USD", value: "usd" },
          { label: "EUR", value: "eur" },
          { label: "GBP", value: "gbp" },
          { label: "CAD", value: "cad" },
          { label: "AUD", value: "aud" },
        ],
      },
      {
        key: "payment_method",
        type: "text",
        label: "Payment Method ID",
        placeholder: "pm_1234567890abcdef",
        required: true,
      },
      {
        key: "customer_id",
        type: "text",
        label: "Customer ID",
        placeholder: "cus_1234567890abcdef",
        required: false,
      },
      {
        key: "description",
        type: "text",
        label: "Description",
        placeholder: "Payment for services",
        required: false,
        supportExpressions: true,
      },
      {
        key: "metadata",
        type: "textarea",
        label: "Metadata (JSON)",
        placeholder: '{"order_id": "12345", "user_id": "67890"}',
        required: false,
        supportExpressions: true,
      },
    ],
    required: ["amount", "currency", "payment_method"],
  },

  executor: {
    async execute(config) {
      await new Promise((resolve) => setTimeout(resolve, 2000));
      const timestamp = new Date().toISOString();
      
      return {
        success: true,
        data: {
          paymentIntentId: "pi_1234567890abcdef",
          amount: config.amount as number,
          currency: config.currency as string,
          status: "succeeded",
          customerId: config.customer_id as string || "cus_1234567890abcdef",
          description: config.description as string || "Payment for services",
          metadata: config.metadata ? JSON.parse(config.metadata as string) : {},
          created: Math.floor(Date.now() / 1000),
          timestamp,
          receiptUrl: "https://receipt.stripe.com/1234567890",
        },
        metadata: { nodeType: "action", subtype: "stripe_create_payment" },
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/actions/sheets-append-row.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const sheetsAppendRow: Integration = createIntegration({
  id: "sheets_append_row",
  name: "Google Sheets Append Row",
  category: "action",
  description: "Add data to Google Sheets",
  icon: "google",
  version: "1.0.0",

  auth: {
    type: "oauth2",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "spreadsheet_id",
        type: "text",
        label: "Spreadsheet ID",
        placeholder: "1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms",
        required: true,
      },
      {
        key: "range",
        type: "text",
        label: "Range",
        placeholder: "Sheet1!A:Z",
        required: true,
      },
      {
        key: "values",
        type: "textarea",
        label: "Row Data (JSON Array)",
        placeholder: '["John", "Doe", "john@example.com", "2024-01-01"]',
        required: true,
        supportExpressions: true,
      },
      {
        key: "value_input_option",
        type: "select",
        label: "Value Input Option",
        required: false,
        options: [
          { label: "Raw", value: "RAW" },
          { label: "User Entered", value: "USER_ENTERED" },
        ],
      },
    ],
    required: ["spreadsheet_id", "range", "values"],
  },

  executor: {
    async execute(config) {
      await new Promise((resolve) => setTimeout(resolve, 1500));
      const timestamp = new Date().toISOString();

      const spreadsheetId = config.spreadsheet_id as string;
      const range = config.range as string;
      const sheetName = range.split("!")[0];

      return {
        success: true,
        data: {
          spreadsheetId,
          range,
          updatedRange: `${sheetName}!A123:D123`,
          updatedRows: 1,
          updatedColumns: 4,
          updatedCells: 4,
          timestamp,
          spreadsheetUrl: `https://docs.google.com/spreadsheets/d/${spreadsheetId}`,
        },
        metadata: { nodeType: "action", subtype: "sheets_append_row" },
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/actions/email-send.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const emailSend: Integration = createIntegration({
  id: "email_send",
  name: "Send Email",
  category: "action",
  description: "Send an email message",
  icon: "mail",
  version: "1.0.0",

  auth: {
    type: "api_key",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "to",
        type: "email",
        label: "To Email",
        placeholder: "user@example.com",
        required: true,
      },
      {
        key: "subject",
        type: "text",
        label: "Subject",
        placeholder: "Email subject",
        required: true,
        supportExpressions: true,
      },
      {
        key: "body",
        type: "textarea",
        label: "Body",
        placeholder:
          "Hello {{$node.webhook-1.data.user.name}}, your order {{$node.webhook-1.data.order.id}} has been shipped!",
        required: true,
        supportExpressions: true,
      },
    ],
    required: ["to", "subject", "body"],
  },

  executor: {
    async execute(config) {
      await new Promise((resolve) => setTimeout(resolve, 1200));
      const timestamp = new Date().toISOString();
      return {
        success: true,
        data: {
          messageId: "<20241201120000.abc123@smtp.gmail.com>",
          to: config.to as string,
          subject: config.subject as string,
          status: "sent",
          deliveryTime: "2.3s",
          provider: "SendGrid",
          timestamp,
        },
        metadata: { nodeType: "action", subtype: "email_send" },
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/actions/trello-create-card.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const trelloCreateCard: Integration = createIntegration({
  id: "trello_create_card",
  name: "Trello Create Card",
  category: "action",
  description: "Create cards in Trello boards",
  icon: "trello",
  version: "1.0.0",

  auth: {
    type: "oauth2",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "name",
        type: "text",
        label: "Card Name",
        placeholder: "Implement new feature",
        required: true,
        supportExpressions: true,
      },
      {
        key: "description",
        type: "textarea",
        label: "Description",
        placeholder: "Detailed description of the card...",
        required: false,
        supportExpressions: true,
      },
      {
        key: "list_id",
        type: "text",
        label: "List ID",
        placeholder: "5f7b8c9d1a2b3c4d5e6f7g8",
        required: true,
      },
      {
        key: "due_date",
        type: "text",
        label: "Due Date",
        placeholder: "2024-12-31",
        required: false,
      },
      {
        key: "labels",
        type: "text",
        label: "Label IDs (comma-separated)",
        placeholder: "5f7b8c9d1a2b3c4d5e6f7g8, 5f7b8c9d1a2b3c4d5e6f7g9",
        required: false,
      },
      {
        key: "position",
        type: "select",
        label: "Position",
        required: false,
        options: [
          { label: "Top", value: "top" },
          { label: "Bottom", value: "bottom" },
        ],
      },
    ],
    required: ["name", "list_id"],
  },

  executor: {
    async execute(config) {
      await new Promise((resolve) => setTimeout(resolve, 800));
      const timestamp = new Date().toISOString();

      return {
        success: true,
        data: {
          cardId: "5f7b8c9d1a2b3c4d5e6f7g8",
          name: config.name as string,
          description: (config.description as string) || "",
          listId: config.list_id as string,
          dueDate: (config.due_date as string) || "",
          labels: config.labels
            ? (config.labels as string).split(",").map((id) => id.trim())
            : [],
          position: (config.position as string) || "bottom",
          shortUrl: "https://trello.com/c/abc123",
          url: "https://trello.com/c/abc123/implement-new-feature",
          createdAt: timestamp,
          timestamp,
        },
        metadata: { nodeType: "action", subtype: "trello_create_card" },
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/actions/google-sheets-append.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const googleSheetsAppend: Integration = createIntegration({
  id: "google_sheets_append",
  name: "Google Sheets Append",
  category: "action",
  description: "Append data to Google Sheets",
  icon: "google",
  version: "1.0.0",

  auth: {
    type: "oauth2",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "spreadsheet_id",
        type: "text",
        label: "Spreadsheet ID",
        placeholder: "1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms",
        required: true,
        validation: (value: unknown) => {
          if (typeof value !== "string" || value.trim().length === 0) {
            return "Spreadsheet ID is required";
          }
          return null;
        },
      },
      {
        key: "range",
        type: "text",
        label: "Range (Sheet Name)",
        placeholder: "Sheet1 or Sheet1!A:Z",
        required: true,
        validation: (value: unknown) => {
          if (typeof value !== "string" || value.trim().length === 0) {
            return "Range is required";
          }
          return null;
        },
      },
      {
        key: "values",
        type: "textarea",
        label: "Data to Append (JSON Array)",
        placeholder: '[["John", "Doe", "john@example.com"], ["Jane", "Smith", "jane@example.com"]]',
        required: true,
        supportExpressions: true,
        validation: (value: unknown) => {
          if (typeof value !== "string" || value.trim().length === 0) {
            return "Values are required";
          }
          try {
            const parsed = JSON.parse(value);
            if (!Array.isArray(parsed)) {
              return "Values must be a JSON array";
            }
            return null;
          } catch (e) {
            return "Invalid JSON format";
          }
        },
      },
      {
        key: "value_input_option",
        type: "select",
        label: "Value Input Option",
        required: false,
        options: [
          { label: "Raw", value: "RAW" },
          { label: "User Entered", value: "USER_ENTERED" },
        ],
      },
      {
        key: "insert_data_option",
        type: "select",
        label: "Insert Data Option",
        required: false,
        options: [
          { label: "Insert Rows", value: "INSERT_ROWS" },
          { label: "Overwrite", value: "OVERWRITE" },
        ],
      },
      {
        key: "include_values_in_response",
        type: "boolean",
        label: "Include Values in Response",
        required: false,
      },
    ],
    required: ["spreadsheet_id", "range", "values"],
  },

  executor: {
    async execute(config) {
      // Simulate API call delay
      await new Promise((resolve) => setTimeout(resolve, 1200));
      
      const spreadsheetId = config.spreadsheet_id as string;
      const range = config.range as string;
      const valueInputOption = (config.value_input_option as string) || "RAW";
      const insertDataOption = config.insert_data_option as string;
      const includeValuesInResponse = config.include_values_in_response as boolean || false;
      
      let values: unknown[][] = [];
      try {
        values = JSON.parse(config.values as string);
        if (!Array.isArray(values)) {
          return {
            success: false,
            error: "Values must be a JSON array",
            data: {
              timestamp: new Date().toISOString(),
            },
            metadata: { nodeType: "action", subtype: "google_sheets_append" },
          };
        }
      } catch (e) {
        return {
          success: false,
          error: "Invalid JSON format for values",
          data: {
            timestamp: new Date().toISOString(),
          },
          metadata: { nodeType: "action", subtype: "google_sheets_append" },
        };
      }

      // Extract sheet name from range
      const sheetName = range.includes("!") ? range.split("!")[0] : range;
      
      // Calculate the updated range
      const rowCount = values.length;
      const colCount = values[0]?.length || 0;
      const startRow = Math.floor(Math.random() * 100) + 1; // Mock starting row
      const endRow = startRow + rowCount - 1;
      const startCol = "A";
      const endCol = String.fromCharCode(65 + colCount - 1); // Convert number to letter
      const updatedRange = `${sheetName}!${startCol}${startRow}:${endCol}${endRow}`;

      return {
        success: true,
        data: {
          spreadsheetId,
          tableRange: range,
          updates: {
            spreadsheetId,
            updatedRange,
            updatedRows: rowCount,
            updatedColumns: colCount,
            updatedCells: rowCount * colCount,
            updatedData: includeValuesInResponse ? values : undefined,
          },
          valueInputOption,
          insertDataOption: insertDataOption || null,
          includeValuesInResponse,
          timestamp: new Date().toISOString(),
          spreadsheetUrl: `https://docs.google.com/spreadsheets/d/${spreadsheetId}`,
        },
        metadata: { nodeType: "action", subtype: "google_sheets_append" },
      };
    },

    validate(config) {
      const errors: Record<string, string> = {};

      if (!config.spreadsheet_id) {
        errors.spreadsheet_id = "Spreadsheet ID is required";
      }

      if (!config.range) {
        errors.range = "Range is required";
      }

      if (!config.values) {
        errors.values = "Values are required";
      } else {
        try {
          const parsed = JSON.parse(config.values as string);
          if (!Array.isArray(parsed)) {
            errors.values = "Values must be a JSON array";
          }
        } catch (e) {
          errors.values = "Invalid JSON format for values";
        }
      }

      return {
        valid: Object.keys(errors).length === 0,
        errors,
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/actions/salesforce-create-lead.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const salesforceCreateLead: Integration = createIntegration({
  id: "salesforce_create_lead",
  name: "Salesforce Create Lead",
  category: "action",
  description: "Create leads in Salesforce",
  icon: "salesforce",
  version: "1.0.0",

  auth: {
    type: "oauth2",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "firstname",
        type: "text",
        label: "First Name",
        placeholder: "John",
        required: true,
        supportExpressions: true,
      },
      {
        key: "lastname",
        type: "text",
        label: "Last Name",
        placeholder: "Doe",
        required: true,
        supportExpressions: true,
      },
      {
        key: "email",
        type: "email",
        label: "Email",
        placeholder: "john.doe@example.com",
        required: true,
      },
      {
        key: "company",
        type: "text",
        label: "Company",
        placeholder: "Acme Corporation",
        required: true,
        supportExpressions: true,
      },
      {
        key: "phone",
        type: "text",
        label: "Phone",
        placeholder: "+1-555-123-4567",
        required: false,
      },
      {
        key: "title",
        type: "text",
        label: "Title",
        placeholder: "VP of Engineering",
        required: false,
      },
      {
        key: "lead_source",
        type: "select",
        label: "Lead Source",
        required: false,
        options: [
          { label: "Web", value: "Web" },
          { label: "Phone Inquiry", value: "Phone Inquiry" },
          { label: "Email", value: "Email" },
          { label: "Campaign", value: "Campaign" },
          { label: "Partner", value: "Partner" },
          { label: "Other", value: "Other" },
        ],
      },
      {
        key: "status",
        type: "select",
        label: "Status",
        required: false,
        options: [
          { label: "New", value: "New" },
          { label: "Contacted", value: "Contacted" },
          { label: "Qualified", value: "Qualified" },
          { label: "Unqualified", value: "Unqualified" },
        ],
      },
    ],
    required: ["firstname", "lastname", "email", "company"],
  },

  executor: {
    async execute(config) {
      await new Promise((resolve) => setTimeout(resolve, 1500));
      const timestamp = new Date().toISOString();
      
      return {
        success: true,
        data: {
          leadId: "00Q1234567890ABCD",
          firstname: config.firstname as string,
          lastname: config.lastname as string,
          email: config.email as string,
          company: config.company as string,
          phone: config.phone as string || "",
          title: config.title as string || "",
          leadSource: config.lead_source as string || "Web",
          status: config.status as string || "New",
          createdDate: timestamp,
          lastModifiedDate: timestamp,
          systemModstamp: timestamp,
          timestamp,
        },
        metadata: { nodeType: "action", subtype: "salesforce_create_lead" },
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/actions/set-variable.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration, ValidationResult, WorkflowContext } from "../types";

export const setVariable: Integration = createIntegration({
  id: "set_variable",
  name: "Set Variable",
  category: "action",
  description: "Store data in a variable",
  icon: "database",
  version: "1.0.0",

  schema: {
    fields: [
      {
        key: "variableName",
        type: "text",
        label: "Variable Name",
        placeholder: "myVariable",
        required: true,
        validation: (value: unknown) => {
          if (
            typeof value !== "string" ||
            !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(value)
          ) {
            return "Variable name must start with letter or underscore and contain only letters, numbers, and underscores";
          }
          return null;
        },
      },
      {
        key: "value",
        type: "textarea",
        label: "Value",
        placeholder: "Enter value or reference data...",
        required: true,
        supportExpressions: true,
      },
    ],
    required: ["variableName", "value"],
  },

  executor: {
    async execute(config, context: WorkflowContext) {
      if (config.variableName) {
        let val: unknown = config.value;
        /* If user pasted JSON, keep it as an object so {{$vars.x.y}} works */
        if (typeof val === "string") {
          try {
            val = JSON.parse(val);
          } catch {
            /* ignore */
          }
        }
        context.variables[config.variableName as string] = val;
      }

      const timestamp = new Date().toISOString();
      return {
        success: true,
        data: {
          variableName: config.variableName as string,
          value: config.value,
          timestamp,
        },
        metadata: { nodeType: "action", subtype: "set_variable" },
      };
    },

    validate(config): ValidationResult {
      const errors: Record<string, string> = {};

      if (!config.variableName) {
        errors.variableName = "Variable name is required";
      } else if (
        !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(config.variableName as string)
      ) {
        errors.variableName = "Invalid variable name format";
      }

      if (!config.value) {
        errors.value = "Value is required";
      }

      return {
        valid: Object.keys(errors).length === 0,
        errors,
      };
    },
  },
});

----- Content End -----

