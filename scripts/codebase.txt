===== File: app/layout.tsx =====
Type: .tsx
----- Content Start -----
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { ThemeProvider } from "next-themes";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Agent Maker",
  description: "Automations and Workflows for your business",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <head>
        <script
          dangerouslySetInnerHTML={{
            __html: `
              (function() {
                try {
                  var theme = localStorage.getItem('theme');
                  if (!theme) {
                    theme = 'dark';
                  }
                  if (theme === 'system') {
                    theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
                  }
                  
                  var themeColor = theme === 'dark' ? '#0a0a0a' : '#ffffff';
                  var meta = document.createElement('meta');
                  meta.name = 'theme-color';
                  meta.content = themeColor;
                  document.head.appendChild(meta);
                } catch (e) {}
              })();
            `,
          }}
        />
      </head>
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <ThemeProvider attribute="class" defaultTheme="dark" enableSystem>
          {children}
        </ThemeProvider>
      </body>
    </html>
  );
}

----- Content End -----

===== File: app/page.tsx =====
Type: .tsx
----- Content Start -----
"use client";

import { useState, useEffect } from "react";
import Link from "next/link";
import { useThemeToggle } from "../hooks/useThemeToggle";
import {
  Plus,
  Edit,
  Trash2,
  Clock,
  Zap,
  User,
  Mail,
  Globe,
} from "lucide-react";

// ============================================
// TYPE DEFINITIONS
// ============================================

interface NodeData {
  subtype?: string;
  description?: string;
  label?: string;
}

interface Node {
  type: string;
  data?: NodeData;
}

interface Automation {
  id: string;
  name: string;
  nodes: Node[];
  edges: Record<string, unknown>[];
  status: string;
  created_at: string;
  updated_at: string;
}

// ============================================
// UTILITY FUNCTIONS
// ============================================

const getTriggerIcon = (nodes: Node[]) => {
  // Find the first trigger node to determine the trigger type
  const triggerNode = nodes.find(
    (node) =>
      node.type === "trigger" ||
      (node.data?.subtype && node.data.subtype.includes("_trigger"))
  );

  if (!triggerNode) return <Zap className="w-4 h-4" />;

  const subtype = triggerNode.data?.subtype;
  switch (subtype) {
    case "webhook_trigger":
      return <Globe className="w-4 h-4" />;
    case "schedule_trigger":
      return <Clock className="w-4 h-4" />;
    case "email_trigger":
      return <Mail className="w-4 h-4" />;
    case "manual_trigger":
      return <User className="w-4 h-4" />;
    default:
      return <Zap className="w-4 h-4" />;
  }
};

const getAutomationDescription = (nodes: Node[]) => {
  if (nodes.length === 0) return "No nodes configured";

  const actionNodes = nodes.filter(
    (node) =>
      node.type === "action" ||
      (node.data?.subtype && !node.data.subtype.includes("_trigger"))
  );

  if (actionNodes.length === 0) return "No actions configured";

  const firstAction = actionNodes[0];
  return (
    firstAction.data?.description ||
    firstAction.data?.label ||
    "Action configured"
  );
};

// ============================================
// MAIN COMPONENT
// ============================================

export default function Home() {
  const { theme, toggleTheme, mounted } = useThemeToggle();
  const [automations, setAutomations] = useState<Automation[]>([]);
  const [loading, setLoading] = useState(true);

  // Fetch automations on component mount
  useEffect(() => {
    const fetchAutomations = async () => {
      try {
        const response = await fetch("/api/automations");
        if (response.ok) {
          const data = await response.json();
          setAutomations(data);
        }
      } catch (error) {
        console.error("Failed to fetch automations:", error);
      } finally {
        setLoading(false);
      }
    };
    fetchAutomations();
  }, []);

  // Sort automations by last updated
  const sortedAutomations = automations.sort(
    (a, b) =>
      new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime()
  );

  const handleDeleteAutomation = async (id: string) => {
    if (!window.confirm("Are you sure you want to delete this automation?"))
      return;

    try {
      const response = await fetch(`/api/automations?id=${id}`, {
        method: "DELETE",
      });
      if (response.ok) {
        setAutomations((prev) =>
          prev.filter((automation) => automation.id !== id)
        );
      }
    } catch (error) {
      console.error("Failed to delete automation:", error);
    }
  };

  return (
    <div className="min-h-screen bg-[var(--background)]">
      {/* TOP BAR */}
      <div className="bg-[var(--card)] border-b border-[var(--border)] px-6 py-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-8">
            {/* Empty space for layout consistency */}
          </div>

          {/* Action Buttons */}
          <div className="flex items-center gap-3">
            {mounted && (
              <button
                onClick={toggleTheme}
                className="p-2 text-[var(--foreground)] hover:bg-[var(--muted)] rounded-lg transition-colors"
                aria-label="Toggle theme"
              >
                {theme === "dark" ? (
                  <svg
                    className="w-5 h-5"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth={2}
                      d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"
                    />
                  </svg>
                ) : (
                  <svg
                    className="w-5 h-5"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth={2}
                      d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"
                    />
                  </svg>
                )}
              </button>
            )}

            {!loading && sortedAutomations.length > 0 && (
              <Link
                href="/editor"
                className="inline-flex items-center gap-2 px-4 py-2 bg-[var(--primary)] text-[var(--primary-foreground)] rounded-lg hover:bg-[var(--primary)]/90 transition-colors text-sm font-medium"
              >
                <Plus className="w-4 h-4" />
                New Automation
              </Link>
            )}
          </div>
        </div>
      </div>

      {/* AUTOMATION GRID */}
      <div className="p-6">
        {loading ? (
          <div className="flex items-center justify-center min-h-[calc(100vh-200px)]">
            <div className="text-center">
              <div className="animate-spin w-8 h-8 border-2 border-[var(--primary)] border-t-transparent rounded-full mx-auto mb-4"></div>
              <p className="text-[var(--muted-foreground)]">
                Loading automations...
              </p>
            </div>
          </div>
        ) : sortedAutomations.length === 0 ? (
          <div className="flex items-center justify-center min-h-[calc(100vh-200px)]">
            <div className="text-center">
              <div className="w-16 h-16 mx-auto mb-4 bg-[var(--muted)] rounded-full flex items-center justify-center">
                <Zap className="w-8 h-8 text-[var(--muted-foreground)]" />
              </div>
              <h3 className="text-lg font-medium text-[var(--foreground)] mb-2">
                No automations yet
              </h3>
              <p className="text-[var(--muted-foreground)] mb-6">
                Create your first automation to get started
              </p>
              <Link
                href="/editor"
                className="inline-flex items-center gap-2 px-4 py-2 bg-[var(--primary)] text-[var(--primary-foreground)] rounded-lg hover:bg-[var(--primary)]/90 transition-colors text-sm font-medium"
              >
                <Plus className="w-4 h-4" />
                Create Automation
              </Link>
            </div>
          </div>
        ) : (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {sortedAutomations.map((automation) => (
              <div
                key={automation.id}
                className="group relative bg-[var(--card)] border border-[var(--border)] rounded-xl p-5 hover:shadow-lg hover:border-[var(--ring)] transition-all duration-200 cursor-pointer"
              >
                {/* Status Indicator */}
                <div className="absolute top-4 right-4">
                  <div
                    className={`w-2 h-2 rounded-full ${
                      automation.status === "active"
                        ? "bg-green-500"
                        : automation.status === "error"
                        ? "bg-red-500"
                        : "bg-gray-400"
                    }`}
                  />
                </div>

                {/* Header */}
                <div className="flex items-start gap-3 mb-4">
                  <div className="p-2.5 bg-[var(--muted)] rounded-lg flex-shrink-0">
                    {getTriggerIcon(automation.nodes)}
                  </div>
                  <div className="min-w-0 flex-1">
                    <h3 className="font-semibold text-[var(--foreground)] text-lg mb-1 truncate">
                      {automation.name}
                    </h3>
                    <p className="text-sm text-[var(--muted-foreground)] line-clamp-2 leading-relaxed">
                      {getAutomationDescription(automation.nodes)}
                    </p>
                  </div>
                </div>

                {/* Action Bar */}
                <div className="flex items-center justify-between pt-3 border-t border-[var(--border)] relative z-20">
                  <div className="text-xs text-[var(--muted-foreground)]">
                    {new Date(automation.updated_at).toLocaleDateString()}
                  </div>
                  <div className="flex items-center gap-2">
                    <Link
                      href={`/editor?id=${automation.id}`}
                      className="p-2 text-[var(--muted-foreground)] hover:text-[var(--foreground)] hover:bg-[var(--muted)] rounded-lg transition-colors"
                      onClick={(e) => e.stopPropagation()}
                    >
                      <Edit className="w-4 h-4" />
                    </Link>
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        handleDeleteAutomation(automation.id);
                      }}
                      className="p-2 text-[var(--muted-foreground)] hover:text-red-600 hover:bg-red-50 dark:hover:bg-red-900/20 rounded-lg transition-colors"
                    >
                      <Trash2 className="w-4 h-4" />
                    </button>
                  </div>
                </div>

                {/* Click Overlay */}
                <Link
                  href={`/editor?id=${automation.id}`}
                  className="absolute inset-0 z-10"
                  aria-label={`View ${automation.name} details`}
                />
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}

----- Content End -----

===== File: app/globals.css =====
Type: .css
----- Content Start -----
@import "tailwindcss";

/* CSS Variables for Light and Dark Themes */
:root {
  /* Light theme variables */
  --background: #ffffff;
  --foreground: #171717;
  --card: #ffffff;
  --card-foreground: #171717;
  --popover: #ffffff;
  --popover-foreground: #171717;
  --primary: #0f172a;
  --primary-foreground: #f8fafc;
  --secondary: #f1f5f9;
  --secondary-foreground: #0f172a;
  --muted: #f1f5f9;
  --muted-foreground: #64748b;
  --accent: #f1f5f9;
  --accent-foreground: #0f172a;
  --destructive: #ef4444;
  --destructive-foreground: #f8fafc;
  --border: #e2e8f0;
  --input: #e2e8f0;
  --ring: #0f172a;
  --radius: 0.5rem;
  --scrollbar-thumb: #d1d5db;
  --scrollbar-thumb-hover: #9ca3af;
  --scrollbar-thumb-active: #6b7280;
}

.dark {
  /* Dark theme variables */
  --background: #0a0a0a;
  --foreground: #ededed;
  --card: #171717;
  --card-foreground: #ededed;
  --popover: #171717;
  --popover-foreground: #ededed;
  --primary: #f8fafc;
  --primary-foreground: #0f172a;
  --secondary: #262626;
  --secondary-foreground: #f8fafc;
  --muted: #262626;
  --muted-foreground: #a1a1aa;
  --accent: #262626;
  --accent-foreground: #f8fafc;
  --destructive: #7f1d1d;
  --destructive-foreground: #f8fafc;
  --border: #262626;
  --input: #262626;
  --ring: #f8fafc;
  --scrollbar-thumb: #404040;
  --scrollbar-thumb-hover: #525252;
  --scrollbar-thumb-active: #737373;
}

/* Apply theme colors to body */
body {
  background-color: var(--background);
  color: var(--foreground);
  transition: background-color 0.3s ease, color 0.3s ease;
}

/* Custom Scrollbar Styles */
.custom-scrollbar::-webkit-scrollbar {
  width: 6px;
}

.custom-scrollbar::-webkit-scrollbar-track {
  background: transparent;
}

.custom-scrollbar::-webkit-scrollbar-thumb {
  background: var(--scrollbar-thumb);
  border-radius: 3px;
  transition: background 0.2s ease;
}

.custom-scrollbar::-webkit-scrollbar-thumb:hover {
  background: var(--scrollbar-thumb-hover);
}

.custom-scrollbar::-webkit-scrollbar-thumb:active {
  background: var(--scrollbar-thumb-active);
}

/* Firefox scrollbar styles */
.custom-scrollbar {
  scrollbar-width: thin;
  scrollbar-color: var(--scrollbar-thumb) transparent;
}

/* Modern Dropdown/Select Styles */
select {
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
  background-position: right 12px center;
  background-repeat: no-repeat;
  background-size: 16px;
  padding-right: 40px;
  cursor: pointer;
  transition: all 0.2s ease;
}

select:hover {
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%239ca3af' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
}

select:focus {
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%230f172a' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
}

.dark select {
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23a1a1aa' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
}

.dark select:hover {
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23d1d5db' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
}

.dark select:focus {
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23f8fafc' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
}

/* Option styling for better readability */
select option {
  background-color: var(--background);
  color: var(--foreground);
  padding: 8px 12px;
  font-size: 14px;
}

select option:hover {
  background-color: var(--accent);
}

select option:checked {
  background-color: var(--primary);
  color: var(--primary-foreground);
}

/* Firefox specific select styling */
@-moz-document url-prefix() {
  select {
    background-image: none;
    padding-right: 12px;
  }

  select::-moz-focus-inner {
    border: 0;
  }

  select:-moz-focusring {
    color: transparent;
    text-shadow: 0 0 0 var(--foreground);
  }
}

/* Enhanced focus states for better accessibility */
select:focus-visible {
  outline: 2px solid var(--ring);
  outline-offset: 2px;
}

/* Disabled state styling */
select:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%239ca3af' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
}

.dark select:disabled {
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23525252' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
}

----- Content End -----

===== File: app/api/init/route.ts =====
Type: .ts
----- Content Start -----
import { NextResponse } from "next/server";
import { initializeDatabase } from "@/lib/db";
import { QueueProcessor } from "@/lib/execution-engine";

export async function POST() {
  try {
    // Initialize database schema
    await initializeDatabase();

    // Then start background processes
    startBackgroundProcesses();

    return NextResponse.json({
      status: "Database initialized and background processes started",
    });
  } catch (error) {
    console.error("Failed to initialize:", error);
    return NextResponse.json(
      {
        error: "Failed to initialize database and background processes",
      },
      { status: 500 }
    );
  }
}

let queueProcessor: QueueProcessor | null = null;

function startBackgroundProcesses() {
  if (queueProcessor) return; // Already started

  queueProcessor = new QueueProcessor();
  queueProcessor.start();

  // Graceful shutdown
  process.on("SIGINT", () => {
    console.log("Shutting down background processes...");
    queueProcessor?.stop();
    process.exit(0);
  });

  process.on("SIGTERM", () => {
    console.log("Shutting down background processes...");
    queueProcessor?.stop();
    process.exit(0);
  });
}

----- Content End -----

===== File: app/api/automations/route.ts =====
Type: .ts
----- Content Start -----
import { NextRequest, NextResponse } from "next/server";
import {
  getAllAutomations,
  createAutomation,
  updateAutomation,
  deleteAutomation,
} from "@/lib/db";

export async function GET() {
  try {
    const automations = await getAllAutomations();
    return NextResponse.json(automations);
  } catch (error) {
    console.error("Database error:", error);
    return NextResponse.json(
      { error: "Failed to fetch automations" },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const { name, nodes, edges } = await request.json();

    const automation = await createAutomation(name, nodes, edges);
    return NextResponse.json(automation);
  } catch (error) {
    console.error("Database error:", error);
    return NextResponse.json(
      { error: "Failed to save automation" },
      { status: 500 }
    );
  }
}

export async function PUT(request: NextRequest) {
  try {
    const { id, name, nodes, edges } = await request.json();

    const automation = await updateAutomation(id, name, nodes, edges);
    return NextResponse.json(automation);
  } catch (error) {
    console.error("Database error:", error);
    if (error instanceof Error && error.message === "Automation not found") {
      return NextResponse.json(
        { error: "Automation not found" },
        { status: 404 }
      );
    }
    return NextResponse.json(
      { error: "Failed to update automation" },
      { status: 500 }
    );
  }
}

export async function DELETE(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const id = searchParams.get("id");

    if (!id) {
      return NextResponse.json(
        { error: "Automation ID is required" },
        { status: 400 }
      );
    }

    await deleteAutomation(id);
    return NextResponse.json({ message: "Automation deleted successfully" });
  } catch (error) {
    console.error("Database error:", error);
    if (error instanceof Error && error.message === "Automation not found") {
      return NextResponse.json(
        { error: "Automation not found" },
        { status: 404 }
      );
    }
    return NextResponse.json(
      { error: "Failed to delete automation" },
      { status: 500 }
    );
  }
}

----- Content End -----

===== File: app/api/execute/route.ts =====
Type: .ts
----- Content Start -----
import { NextRequest, NextResponse } from "next/server";
import {
  createExecution,
  getExecutionWithSteps,
  getLatestExecution,
} from "@/lib/db";

export async function POST(request: NextRequest) {
  try {
    const { workflowId } = await request.json();

    if (!workflowId) {
      return NextResponse.json(
        { error: "Automation ID is required" },
        { status: 400 }
      );
    }

    // Create execution record
    const execution = await createExecution(workflowId);

    return NextResponse.json({
      executionId: execution.id,
      status: "queued",
    });
  } catch (error) {
    console.error("Database error:", error);
    return NextResponse.json(
      { error: "Failed to start execution" },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const executionId = searchParams.get("executionId");
    const workflowId = searchParams.get("workflowId");
    const latest = searchParams.get("latest");

    if (executionId) {
      // Get specific execution status
      const execution = await getExecutionWithSteps(executionId);

      if (!execution) {
        return NextResponse.json(
          { error: "Execution not found" },
          { status: 404 }
        );
      }

      return NextResponse.json({
        id: execution.id,
        status: execution.status,
        started_at: execution.started_at,
        completed_at: execution.completed_at,
        error_message: execution.error_message,
        steps: execution.steps,
      });
    } else if (workflowId && latest) {
      // Get latest execution for an automation
      const execution = await getLatestExecution(workflowId);

      if (!execution) {
        return NextResponse.json(null);
      }

      return NextResponse.json(execution);
    } else {
      return NextResponse.json(
        {
          error:
            "Either executionId or workflowId with latest=true is required",
        },
        { status: 400 }
      );
    }
  } catch (error) {
    console.error("Database error:", error);
    return NextResponse.json(
      { error: "Failed to get execution status" },
      { status: 500 }
    );
  }
}

----- Content End -----

===== File: app/editor/page.tsx =====
Type: .tsx
----- Content Start -----
"use client";

import { useCallback, useEffect, DragEvent, Suspense } from "react";
import { useThemeToggle } from "../../hooks/useThemeToggle";
import { getIcon } from "../../hooks/useIcons";
import { useSearchParams } from "next/navigation";
import type { WorkflowTemplate } from "../../lib/integrations/templates";

import {
  ReactFlow,
  ReactFlowProvider,
  applyNodeChanges,
  applyEdgeChanges,
  addEdge,
  NodeChange,
  EdgeChange,
  Connection,
  Node,
  Edge,
  NodeTypes,
  Background,
  BackgroundVariant,
  Handle,
  Position,
  useReactFlow,
} from "@xyflow/react";
import "@xyflow/react/dist/style.css";

// Import extracted components
import TopBar from "./components/TopBar";
import NodeLibraryPanel from "./components/NodeLibraryPanel";
import ConfigurationPanel from "./components/ConfigurationPanel";
import ExecutionPanel from "./components/ExecutionPanel";
import {
  AutomationProvider,
  useAutomationContext,
} from "./context/AutomationContext";

// ============================================
// TYPE DEFINITIONS
// ============================================

interface NodeData {
  label: string;
  subtype?: string;
  icon?: string;
  description?: string;
  config?: Record<string, unknown>;
  status?: "idle" | "running" | "success" | "error";
  lastRun?: string;
  executionResult?: Record<string, unknown>;
  colorClass?: string;
  borderClass?: string;
  selectedBorderClass?: string;
}

// ------------------------------------------------
// NODE-ID UTIL
// ------------------------------------------------
const nextNodeId = (existing: Node[], base: string) => {
  // base = webhook_trigger   â†’  webhook_trigger-1, -2, â€¦
  const re = new RegExp(`^${base}-(\\d+)$`);
  const max = existing.reduce((highest, n) => {
    const m = n.id.match(re);
    return m ? Math.max(highest, Number(m[1])) : highest;
  }, 0);
  return `${base}-${max + 1}`;
};

// ============================================
// CUSTOM NODE COMPONENTS
// ============================================

const BaseNode = ({
  data,
  selected,
  icon,
}: {
  data: NodeData;
  selected: boolean;
  icon: string;
}) => {
  const getStatusIndicator = () => {
    switch (data.status) {
      case "running":
        return <div className="w-2 h-2 bg-black rounded-full animate-pulse" />;
      case "success":
        return <div className="w-2 h-2 bg-green-500 rounded-full" />;
      case "error":
        return <div className="w-2 h-2 bg-red-500 rounded-full" />;
      default:
        return <div className="w-2 h-2 bg-gray-300 rounded-full" />;
    }
  };

  const getIconComponent = () => {
    const colorClass = data.colorClass || "text-[var(--foreground)]";
    return getIcon(icon, "w-5 h-5", colorClass);
  };

  const getBorderClasses = () => {
    if (selected) {
      return (
        data.selectedBorderClass ||
        "border-gray-800 dark:border-gray-200 shadow-lg ring-1 ring-gray-500/20 dark:ring-gray-400/20"
      );
    } else {
      return (
        data.borderClass ||
        "border-gray-200 dark:border-gray-700 hover:border-gray-300 dark:hover:border-gray-600"
      );
    }
  };

  return (
    <div
      className={`
        relative bg-[var(--card)] rounded-xl shadow-sm border transition-all duration-200
        min-w-[180px] px-5 py-4 group hover:shadow-md
        ${getBorderClasses()}
      `}
    >
      {/* Only show left handle for non-trigger nodes or triggers that support input */}
      {data.subtype !== "manual_trigger" &&
        data.subtype !== "webhook_trigger" &&
        data.subtype !== "schedule_trigger" && (
          <Handle
            type="target"
            position={Position.Left}
            style={{
              background: "#6b7280",
              width: 12,
              height: 12,
              border: "2px solid white",
              boxShadow: "0 2px 4px rgba(0,0,0,0.1)",
            }}
            className="hover:bg-gray-600 transition-colors"
          />
        )}
      <Handle
        type="source"
        position={Position.Right}
        style={{
          background: "#6b7280",
          width: 12,
          height: 12,
          border: "2px solid white",
          boxShadow: "0 2px 4px rgba(0,0,0,0.1)",
        }}
        className="hover:bg-gray-600 transition-colors"
      />
      {/* Status indicator */}
      <div className="absolute top-3 right-3">{getStatusIndicator()}</div>

      {/* Content */}
      <div className="pr-6">
        <div className="flex items-center gap-3 mb-2">
          {getIconComponent()}
          <h3 className="font-medium text-[var(--foreground)] leading-tight">
            {data.label}
          </h3>
        </div>

        <p className="text-sm text-[var(--muted-foreground)] leading-relaxed max-w-[200px] break-words">
          {data.description || "Not configured"}
        </p>

        {data.lastRun && (
          <p className="text-xs text-[var(--muted-foreground)] mt-2">
            {data.lastRun}
          </p>
        )}
      </div>
    </div>
  );
};

const TriggerNode = ({
  data,
  selected,
}: {
  data: NodeData;
  selected: boolean;
}) => <BaseNode data={data} selected={selected} icon={data.icon || "zap"} />;

const ActionNode = ({
  data,
  selected,
}: {
  data: NodeData;
  selected: boolean;
}) => <BaseNode data={data} selected={selected} icon={data.icon || "circle"} />;

const ConditionNode = ({
  data,
  selected,
}: {
  data: NodeData;
  selected: boolean;
}) => (
  <BaseNode data={data} selected={selected} icon={data.icon || "diamond"} />
);

const BranchNode = ({
  data,
  selected,
}: {
  data: NodeData;
  selected: boolean;
}) => {
  const baseNodeProps = { data, selected, icon: data.icon || "diamond" };

  return (
    <div className="relative">
      <BaseNode {...baseNodeProps} />
      {/* True output handle */}
      <Handle
        type="source"
        position={Position.Right}
        id="true"
        style={{
          background: "#22c55e",
          width: 12,
          height: 12,
          border: "2px solid white",
          boxShadow: "0 2px 4px rgba(0,0,0,0.1)",
          top: "30%",
        }}
        className="hover:bg-green-600 transition-colors"
      />
      {/* False output handle */}
      <Handle
        type="source"
        position={Position.Right}
        id="false"
        style={{
          background: "#ef4444",
          width: 12,
          height: 12,
          border: "2px solid white",
          boxShadow: "0 2px 4px rgba(0,0,0,0.1)",
          top: "70%",
        }}
        className="hover:bg-red-600 transition-colors"
      />
    </div>
  );
};

// Register custom node types
const nodeTypes: NodeTypes = {
  trigger: TriggerNode,
  action: ActionNode,
  condition: ConditionNode,
  logic: (props) => {
    if (props.data.subtype === "branch_condition") {
      return <BranchNode {...props} />;
    }
    return <ConditionNode {...props} />;
  },
};

// ============================================
// MAIN APP COMPONENT
// ============================================

function WorkflowEditorContent() {
  const { theme } = useThemeToggle();
  const { screenToFlowPosition } = useReactFlow();
  const connectionLineStyle = { stroke: "#d1d5db", strokeWidth: 2 };
  const searchParams = useSearchParams();
  const automationId = searchParams.get("id");

  // Get state from context
  const {
    nodes,
    edges,
    selectedNode,
    sidebarOpen,
    showExecutionPanel,
    setNodes,
    setEdges,
    setSelectedNode,
    setSidebarOpen,
    setShowExecutionPanel,
    setWorkflowName,
    setCurrentWorkflowId,
    restoreLatestExecution,
    restoreExecutionState,
  } = useAutomationContext();

  // Load automation from URL parameter
  useEffect(() => {
    const loadAutomationFromUrl = async () => {
      if (automationId) {
        try {
          const response = await fetch("/api/automations");
          if (response.ok) {
            const automations = await response.json();
            const automation = automations.find(
              (a: { id: string }) => a.id === automationId
            );
            if (automation) {
              setNodes(automation.nodes || []);
              setEdges(automation.edges || []);
              setWorkflowName(automation.name);
              setCurrentWorkflowId(automation.id);

              // ðŸŽ¯ THE MISSING PIECE: Restore execution state
              try {
                const restoredExecution = await restoreLatestExecution(
                  automation.id
                );

                if (restoredExecution) {
                  console.log("âœ… Execution state restored from database");

                  // Restore visual node states
                  if (restoredExecution.steps) {
                    restoreExecutionState(
                      automation.nodes || [],
                      restoredExecution.steps,
                      (
                        nodeId: string,
                        status: "idle" | "running" | "success" | "error",
                        lastRun?: string,
                        executionResult?: Record<string, unknown>
                      ) => {
                        // Update node visual states
                        setNodes((currentNodes) =>
                          currentNodes.map((node) =>
                            node.id === nodeId
                              ? {
                                  ...node,
                                  data: {
                                    ...node.data,
                                    status,
                                    lastRun,
                                    executionResult,
                                  },
                                }
                              : node
                          )
                        );
                      }
                    );
                  }
                } else {
                  console.log(
                    "â„¹ï¸ No previous execution found for this workflow"
                  );
                }
              } catch (error) {
                console.error("Failed to restore execution state:", error);
              }
            }
          }
        } catch (error) {
          console.error("Failed to load automation:", error);
        }
      } else {
        // Clear everything for new automation
        setNodes([]);
        setEdges([]);
        setWorkflowName("Untitled Workflow");
        setCurrentWorkflowId(null);
      }
    };

    loadAutomationFromUrl();
  }, [
    automationId,
    setNodes,
    setEdges,
    setWorkflowName,
    setCurrentWorkflowId,
    restoreLatestExecution,
    restoreExecutionState,
  ]);

  // ============================================
  // REACTFLOW EVENT HANDLERS
  // ============================================

  const onNodesChange = useCallback(
    (changes: NodeChange[]) => {
      setNodes((nds: Node[]) => applyNodeChanges(changes, nds));
    },
    [setNodes]
  );

  const onEdgesChange = useCallback(
    (changes: EdgeChange[]) => {
      setEdges((eds: Edge[]) => applyEdgeChanges(changes, eds));
    },
    [setEdges]
  );

  const onConnect = useCallback(
    (params: Connection) => {
      setEdges((eds: Edge[]) =>
        addEdge(
          {
            ...params,
            id: `${params.source}-${params.sourceHandle || "default"}-${
              params.target
            }`,
            style: {
              stroke:
                params.sourceHandle === "true"
                  ? "#22c55e"
                  : params.sourceHandle === "false"
                  ? "#ef4444"
                  : "#d1d5db",
              strokeWidth: 2,
            },
            animated: false,
          } as Edge,
          eds
        )
      );
    },
    [setEdges]
  );

  const onNodeClick = useCallback(
    (_event: React.MouseEvent, node: Node) => {
      setSelectedNode(node);
      // Close execution panel when a node is clicked
      setShowExecutionPanel(false);
    },
    [setSelectedNode, setShowExecutionPanel]
  );

  const onSelectionChange = useCallback(
    ({ nodes }: { nodes: Node[] }) => {
      // If no nodes are selected, clear the selectedNode
      if (nodes.length === 0) {
        setSelectedNode(null);
      }
    },
    [setSelectedNode]
  );

  // ============================================
  // DRAG & DROP FUNCTIONALITY
  // ============================================

  const onDragOver = useCallback((event: DragEvent) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = "move";
  }, []);

  const onDrop = useCallback(
    (event: DragEvent) => {
      event.preventDefault();

      // Check if it's a template first
      const templateData = event.dataTransfer.getData(
        "application/reactflow/template"
      );
      if (templateData) {
        const template: WorkflowTemplate = JSON.parse(templateData);

        // Convert screen coordinates to flow coordinates
        const position = screenToFlowPosition({
          x: event.clientX,
          y: event.clientY,
        });

        /* ---------- keep ids from the template ----------- */
        const idMap = new Map<string, string>();
        template.nodes.forEach((n) => {
          // only change the id if it already exists on the canvas
          const clash = nodes.find((x) => x.id === n.id);
          if (clash) {
            idMap.set(n.id, nextNodeId(nodes, n.data.subtype || n.type));
          } else {
            idMap.set(n.id, n.id);
          }
        });

        /* ---------- offset positions so the group lands where the user dropped it --------- */
        const templateBounds = template.nodes.reduce(
          (b, n) => ({
            minX: Math.min(b.minX, n.position.x),
            minY: Math.min(b.minY, n.position.y),
          }),
          { minX: Infinity, minY: Infinity }
        );

        const newNodes = template.nodes.map((n) => ({
          id: idMap.get(n.id)!,
          type: n.type,
          position: {
            x: position.x + (n.position.x - templateBounds.minX),
            y: position.y + (n.position.y - templateBounds.minY),
          },
          data: { ...n.data },
        }));

        const newEdges = template.edges.map((e) => ({
          id: `${idMap.get(e.source)}-${
            e.sourceHandle || "default"
          }-${idMap.get(e.target)}`,
          source: idMap.get(e.source)!,
          target: idMap.get(e.target)!,
          sourceHandle: e.sourceHandle,
          style: {
            stroke:
              e.sourceHandle === "true"
                ? "#22c55e"
                : e.sourceHandle === "false"
                ? "#ef4444"
                : "#d1d5db",
            strokeWidth: 2,
          },
          animated: false,
        }));

        // Add template nodes and edges to existing workflow
        setNodes((nds: Node[]) => [...nds, ...newNodes]);
        setEdges((eds: Edge[]) => [...eds, ...newEdges]);

        return;
      }

      // Original single node drop logic
      const nodeData = event.dataTransfer.getData("application/reactflow");
      if (!nodeData) return;

      const {
        type,
        label,
        subtype,
        icon,
        description,
        colorClass,
        borderClass,
        selectedBorderClass,
      } = JSON.parse(nodeData);

      // Convert screen coordinates to flow coordinates (accounts for zoom and pan)
      const position = screenToFlowPosition({
        x: event.clientX,
        y: event.clientY,
      });

      const newNode: Node = {
        id: nextNodeId(nodes, subtype || type),
        type,
        position,
        data: {
          label,
          subtype, // This is now the integration ID
          icon,
          description,
          status: "idle",
          colorClass,
          borderClass,
          selectedBorderClass,
          config: { integrationId: subtype }, // Add this line
        },
      };

      setNodes((nds: Node[]) => [...nds, newNode]);
    },
    [screenToFlowPosition, setNodes, setEdges, nodes]
  );

  // ============================================
  // RENDER
  // ============================================

  return (
    <div className="flex flex-col h-screen bg-[var(--background)]">
      <TopBar />

      <div className="flex-1 flex overflow-hidden">
        <NodeLibraryPanel />

        {/* MAIN CONTENT AREA */}
        <div className="flex-1 relative">
          {!sidebarOpen && (
            <button
              onClick={() => setSidebarOpen(true)}
              className="absolute top-6 left-6 z-10 p-3 bg-[var(--primary)] rounded-xl shadow-lg hover:bg-[var(--primary)]/90 transition-colors"
            >
              {getIcon("plus", "w-6 h-6", "text-[var(--primary-foreground)]")}
            </button>
          )}
          <div className="relative w-full h-full">
            <ReactFlow
              nodes={nodes}
              edges={edges}
              onNodesChange={onNodesChange}
              onEdgesChange={onEdgesChange}
              onConnect={onConnect}
              onNodeClick={onNodeClick}
              onSelectionChange={onSelectionChange}
              onDrop={onDrop}
              onDragOver={onDragOver}
              nodeTypes={nodeTypes}
              defaultViewport={{ x: 0, y: 0, zoom: 0.8 }}
              className="bg-[var(--background)]"
              connectionLineStyle={connectionLineStyle}
              defaultEdgeOptions={{
                style: { stroke: "#d1d5db", strokeWidth: 2 },
                animated: false,
              }}
              panOnDrag
              elementsSelectable
              nodesConnectable
              nodesDraggable
              proOptions={{ hideAttribution: true }}
            >
              <Background
                color={theme === "dark" ? "#6b7280" : "#d1d5db"}
                gap={20}
                size={theme === "dark" ? 1.5 : 2}
                variant={BackgroundVariant.Dots}
              />
            </ReactFlow>
          </div>
        </div>

        {/* RIGHT SIDEBAR - Configuration or Execution Panel */}
        {(selectedNode || showExecutionPanel) && (
          <div className="w-80 bg-[var(--card)] border-l border-[var(--border)] overflow-y-auto">
            <div className="p-6">
              {showExecutionPanel ? (
                <ExecutionPanel />
              ) : (
                selectedNode && <ConfigurationPanel />
              )}
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

function WorkflowEditor() {
  return (
    <AutomationProvider>
      <WorkflowEditorContent />
    </AutomationProvider>
  );
}

export default function App() {
  useEffect(() => {
    fetch("/api/init", { method: "POST" }).catch(console.error);
  }, []);

  return (
    <ReactFlowProvider>
      <Suspense fallback={<div>Loading...</div>}>
        <WorkflowEditor />
      </Suspense>
    </ReactFlowProvider>
  );
}

----- Content End -----

===== File: app/editor/context/AutomationContext.tsx =====
Type: .tsx
----- Content Start -----
"use client";

import React, {
  createContext,
  useContext,
  ReactNode,
  useState,
  useCallback,
  useEffect,
} from "react";
import { Node, Edge } from "@xyflow/react";
import { integrationRegistry } from "../../../lib/integrations/registry";
import type { Integration } from "../../../lib/integrations/types";
import {
  workflowTemplates,
  type WorkflowTemplate,
} from "../../../lib/integrations/templates";
import { useEditor } from "../hooks/useEditor";

// ------------------------------------------------
// NODE-ID UTIL
// ------------------------------------------------
const nextNodeId = (existing: Node[], base: string) => {
  // base = webhook_trigger   â†’  webhook_trigger-1, -2, â€¦
  const re = new RegExp(`^${base}-(\\d+)$`);
  const max = existing.reduce((highest, n) => {
    const m = n.id.match(re);
    return m ? Math.max(highest, Number(m[1])) : highest;
  }, 0);
  return `${base}-${max + 1}`;
};

interface ExecutionStep {
  node_id: string;
  status: string;
  completed_at?: string;
  result?: {
    success: boolean;
    data?: Record<string, unknown>;
    metadata?: {
      nodeType: string;
      subtype: string;
      [key: string]: unknown;
    };
    [key: string]: unknown;
  };
}

interface ExecutionState {
  status: "idle" | "running" | "completed" | "failed";
  context: {
    variables: Record<string, unknown>;
    nodeOutputs: Record<string, unknown>;
  };
  currentNode: string | null;
}

interface AutomationContextType {
  // Workflow state
  nodes: Node[];
  edges: Edge[];
  selectedNode: Node | null;
  workflowName: string;
  isEditingTitle: boolean;
  sidebarOpen: boolean;
  showExecutionPanel: boolean;
  copiedField: string | null;
  currentWorkflowId: string | null;
  setNodes: (updater: Node[] | ((prev: Node[]) => Node[])) => void;
  setEdges: (updater: Edge[] | ((prev: Edge[]) => Edge[])) => void;
  setSelectedNode: (node: Node | null) => void;
  setWorkflowName: (name: string) => void;
  setIsEditingTitle: (editing: boolean) => void;
  setSidebarOpen: (open: boolean) => void;
  setShowExecutionPanel: (show: boolean) => void;
  setCopiedField: (field: string | null) => void;
  setCurrentWorkflowId: (id: string | null) => void;

  // Operations
  getIntegration: (id: string) => Integration | undefined;
  getTriggerIntegrations: () => Integration[];
  getActionIntegrations: () => Integration[];
  getLogicIntegrations: () => Integration[];
  updateNodeConfig: (nodeId: string, config: Record<string, unknown>) => void;
  deleteSelectedNode: () => void;
  copyExpression: (expression: string) => void;
  copyDataFieldExpressionWithFeedback: (
    nodeId: string,
    fieldKey: string
  ) => void;
  handleTitleEdit: () => void;
  handleTitleSave: () => void;
  handleTitleKeyDown: (e: React.KeyboardEvent) => void;

  // Templates
  getTemplates: () => WorkflowTemplate[];
  applyTemplate: (templateId: string) => void;

  // Execution
  executionState: ExecutionState;
  isExecuting: boolean;
  executeWorkflow: (
    nodes: Node[],
    edges: Edge[],
    onNodeStatusChange: (
      nodeId: string,
      status: "idle" | "running" | "success" | "error",
      lastRun?: string,
      executionResult?: Record<string, unknown>
    ) => void
  ) => Promise<void>;
  saveWorkflow: (
    nodes: Node[],
    edges: Edge[],
    name: string
  ) => Promise<unknown>;
  loadWorkflow: () => Promise<unknown>;
  restoreExecutionState: (
    nodes: Node[],
    steps: ExecutionStep[],
    onNodeStatusChange: (
      nodeId: string,
      status: "idle" | "running" | "success" | "error",
      lastRun?: string,
      executionResult?: Record<string, unknown>
    ) => void
  ) => void;
  restoreLatestExecution: (
    workflowId: string
  ) => Promise<{ execution: unknown; steps: ExecutionStep[] } | null>;

  // Auto-save state
  isSaving: boolean;
  lastSaveError: string | null;
}

const AutomationContext = createContext<AutomationContextType | undefined>(
  undefined
);

export const useAutomationContext = () => {
  const context = useContext(AutomationContext);
  if (context === undefined) {
    throw new Error(
      "useAutomationContext must be used within a AutomationProvider"
    );
  }
  return context;
};

interface AutomationProviderProps {
  children: ReactNode;
}

export const AutomationProvider = ({ children }: AutomationProviderProps) => {
  // Core workflow state
  const [nodes, setNodes] = useState<Node[]>([]);
  const [edges, setEdges] = useState<Edge[]>([]);
  const [selectedNode, setSelectedNode] = useState<Node | null>(null);

  // UI state
  const [workflowName, setWorkflowName] = useState("Untitled Workflow");
  const [isEditingTitle, setIsEditingTitle] = useState(false);
  const [sidebarOpen, setSidebarOpen] = useState(true);
  const [showExecutionPanel, setShowExecutionPanel] = useState(false);

  // Copy state
  const [copiedField, setCopiedField] = useState<string | null>(null);

  // Current workflow ID
  const [currentWorkflowId, setCurrentWorkflowId] = useState<string | null>(
    null
  );

  // Auto-save state
  const [isSaving, setIsSaving] = useState(false);
  const [lastSaveError, setLastSaveError] = useState<string | null>(null);

  // Integration helpers
  const getIntegration = useCallback((id: string) => {
    return integrationRegistry.get(id);
  }, []);

  const getTriggerIntegrations = useCallback(() => {
    return integrationRegistry.getTriggers();
  }, []);

  const getActionIntegrations = useCallback(() => {
    return integrationRegistry.getActions();
  }, []);

  const getLogicIntegrations = useCallback(() => {
    return integrationRegistry.getLogic();
  }, []);

  // Node operations
  const updateNodeConfig = useCallback(
    (nodeId: string, config: Record<string, unknown>) => {
      setNodes((nds) =>
        nds.map((node) =>
          node.id === nodeId
            ? { ...node, data: { ...node.data, config } }
            : node
        )
      );

      // Also update the selectedNode state to reflect the changes immediately
      if (selectedNode && selectedNode.id === nodeId) {
        setSelectedNode({
          ...selectedNode,
          data: { ...selectedNode.data, config },
        });
      }
    },
    [selectedNode]
  );

  const deleteSelectedNode = useCallback(() => {
    if (!selectedNode) return;
    setNodes((nds) => nds.filter((n) => n.id !== selectedNode.id));
    setEdges((eds) =>
      eds.filter(
        (e) => e.source !== selectedNode.id && e.target !== selectedNode.id
      )
    );
    setSelectedNode(null);
  }, [selectedNode]);

  // Copy operations
  const copyExpression = useCallback((expression: string) => {
    navigator.clipboard.writeText(expression);
  }, []);

  const copyDataFieldExpressionWithFeedback = useCallback(
    (nodeId: string, fieldKey: string) => {
      navigator.clipboard.writeText(`{{$node.${nodeId}.data.${fieldKey}}}`);
      setCopiedField(fieldKey);
      setTimeout(() => setCopiedField(null), 1500);
    },
    []
  );

  // Title operations
  const handleTitleEdit = useCallback(() => {
    setIsEditingTitle(true);
  }, []);

  const handleTitleSave = useCallback(() => {
    setIsEditingTitle(false);
  }, []);

  const handleTitleKeyDown = useCallback(
    (e: React.KeyboardEvent) => {
      if (e.key === "Enter") {
        handleTitleSave();
      } else if (e.key === "Escape") {
        setIsEditingTitle(false);
      }
    },
    [handleTitleSave]
  );

  // Template operations
  const getTemplates = useCallback(() => {
    return workflowTemplates;
  }, []);

  const applyTemplate = useCallback(
    (templateId: string) => {
      const template = workflowTemplates.find((t) => t.id === templateId);
      if (!template) return;

      /* ---------- keep ids from the template ----------- */
      const idMap = new Map<string, string>();
      template.nodes.forEach((n) => {
        // only change the id if it already exists on the canvas
        const clash = nodes.find((x) => x.id === n.id);
        if (clash) {
          idMap.set(n.id, nextNodeId(nodes, n.data.subtype || n.type));
        } else {
          idMap.set(n.id, n.id);
        }
      });

      const newNodes = template.nodes.map((n) => ({
        id: idMap.get(n.id)!,
        type: n.type,
        position: n.position,
        data: { ...n.data },
      }));

      const newEdges = template.edges.map((e) => ({
        id: `${idMap.get(e.source)}-${idMap.get(e.target)}`,
        source: idMap.get(e.source)!,
        target: idMap.get(e.target)!,
        style: { stroke: "#d1d5db", strokeWidth: 2 },
        animated: false,
      }));

      // Replace current workflow with template
      setNodes(newNodes);
      setEdges(newEdges);
      setWorkflowName(template.name);
    },
    [setNodes, setEdges, setWorkflowName, nodes]
  );

  // Execution logic from useExecution hook
  const {
    executionState,
    isExecuting,
    saveWorkflow: saveWorkflowAPI,
    loadWorkflow: loadWorkflowAPI,
    executeWorkflow: executeWorkflowAPI,
    restoreNodeStates,
    restoreLatestExecution,
  } = useEditor(currentWorkflowId);

  // Auto-save functionality
  useEffect(() => {
    // Only auto-save if we have nodes or edges and a workflow name
    if ((nodes.length > 0 || edges.length > 0) && workflowName.trim()) {
      const timeoutId = setTimeout(async () => {
        try {
          setIsSaving(true);
          setLastSaveError(null);
          console.log("Auto-saving workflow...", {
            nodes: nodes.length,
            edges: edges.length,
          });

          const result = await saveWorkflowAPI(nodes, edges, workflowName);

          // Update currentWorkflowId if this is a new workflow
          if (
            result &&
            typeof result === "object" &&
            "id" in result &&
            !currentWorkflowId
          ) {
            setCurrentWorkflowId(result.id as string);
            // Update URL to reflect the new automation ID
            window.history.replaceState({}, "", `/editor?id=${result.id}`);
          }

          console.log("Auto-save successful");
        } catch (error) {
          console.error("Auto-save failed:", error);
          setLastSaveError(
            error instanceof Error ? error.message : "Save failed"
          );
        } finally {
          setIsSaving(false);
        }
      }, 2000); // Save 2 seconds after changes stop

      return () => clearTimeout(timeoutId);
    }
  }, [nodes, edges, workflowName, saveWorkflowAPI, currentWorkflowId]);

  const executeWorkflow = useCallback(
    async (
      nodes: Node[],
      edges: Edge[],
      onNodeStatusChange: (
        nodeId: string,
        status: "idle" | "running" | "success" | "error",
        lastRun?: string,
        executionResult?: Record<string, unknown>
      ) => void
    ) => {
      await executeWorkflowAPI(nodes, edges, onNodeStatusChange);
    },
    [executeWorkflowAPI]
  );

  const saveWorkflow = useCallback(
    async (nodes: Node[], edges: Edge[], name: string) => {
      const result = await saveWorkflowAPI(nodes, edges, name);
      if (
        result &&
        typeof result === "object" &&
        "id" in result &&
        !currentWorkflowId
      ) {
        setCurrentWorkflowId(result.id as string);
      }
      return result;
    },
    [saveWorkflowAPI, currentWorkflowId, setCurrentWorkflowId]
  );

  const loadWorkflow = useCallback(async () => {
    return await loadWorkflowAPI();
  }, [loadWorkflowAPI]);

  const restoreExecutionState = useCallback(
    (
      nodes: Node[],
      steps: ExecutionStep[],
      onNodeStatusChange: (
        nodeId: string,
        status: "idle" | "running" | "success" | "error",
        lastRun?: string,
        executionResult?: Record<string, unknown>
      ) => void
    ) => {
      restoreNodeStates(nodes, steps, onNodeStatusChange);
    },
    [restoreNodeStates]
  );

  // Create wrapper functions that handle the type conversion
  const setNodesWrapper = useCallback(
    (updater: Node[] | ((prev: Node[]) => Node[])) => {
      setNodes(updater);
    },
    []
  );

  const setEdgesWrapper = useCallback(
    (updater: Edge[] | ((prev: Edge[]) => Edge[])) => {
      setEdges(updater);
    },
    []
  );

  const value = {
    // State
    nodes,
    setNodes: setNodesWrapper,
    edges,
    setEdges: setEdgesWrapper,
    selectedNode,
    setSelectedNode,
    workflowName,
    setWorkflowName,
    isEditingTitle,
    setIsEditingTitle,
    sidebarOpen,
    setSidebarOpen,
    showExecutionPanel,
    setShowExecutionPanel,
    copiedField,
    setCopiedField,
    currentWorkflowId,
    setCurrentWorkflowId,
    isSaving,
    lastSaveError,

    // Operations
    getIntegration,
    getTriggerIntegrations,
    getActionIntegrations,
    getLogicIntegrations,
    updateNodeConfig,
    deleteSelectedNode,
    copyExpression,
    copyDataFieldExpressionWithFeedback,
    handleTitleEdit,
    handleTitleSave,
    handleTitleKeyDown,

    // Templates
    getTemplates,
    applyTemplate,

    // Execution
    executionState,
    isExecuting,
    executeWorkflow,
    saveWorkflow,
    loadWorkflow,
    restoreExecutionState,
    restoreLatestExecution,
  };

  return (
    <AutomationContext.Provider value={value}>
      {children}
    </AutomationContext.Provider>
  );
};

----- Content End -----

===== File: app/editor/components/TopBar.tsx =====
Type: .tsx
----- Content Start -----
"use client";

import Link from "next/link";
import { Loader2, CheckCircle, AlertCircle } from "lucide-react";
import { getIcon } from "../../../hooks/useIcons";
import { useAutomationContext } from "../context/AutomationContext";
import { useThemeToggle } from "../../../hooks/useThemeToggle";
import { useState } from "react";
import { Node } from "@xyflow/react";

const TopBar = () => {
  const {
    workflowName,
    isEditingTitle,
    nodes,
    edges,
    isExecuting,
    isSaving,
    lastSaveError,
    showExecutionPanel,
    setWorkflowName,
    setNodes,
    setShowExecutionPanel,
    handleTitleEdit,
    handleTitleSave,
    handleTitleKeyDown,
    executeWorkflow,
    saveWorkflow,
  } = useAutomationContext();

  const [showSaveSuccess, setShowSaveSuccess] = useState(false);
  const { theme, toggleTheme, mounted } = useThemeToggle();

  const handleExecuteWorkflow = async () => {
    const onNodeStatusChange = (
      nodeId: string,
      status: "idle" | "running" | "success" | "error",
      lastRun?: string,
      executionResult?: Record<string, unknown>
    ) => {
      // Update the node status in the nodes array
      setNodes((prevNodes: Node[]) =>
        prevNodes.map((node: Node) =>
          node.id === nodeId
            ? {
                ...node,
                data: {
                  ...node.data,
                  status,
                  lastRun,
                  executionResult,
                },
              }
            : node
        )
      );
    };

    setShowExecutionPanel(true);
    await executeWorkflow(nodes, edges, onNodeStatusChange);
  };

  const handleManualSave = async () => {
    try {
      await saveWorkflow(nodes, edges, workflowName);
      setShowSaveSuccess(true);
      setTimeout(() => setShowSaveSuccess(false), 2000); // Hide after 2 seconds
    } catch (error) {
      console.error("Manual save failed:", error);
    }
  };

  return (
    <div className="bg-[var(--card)] border-b border-[var(--border)] px-6 py-4">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-4">
          {/* Home Button */}
          <Link
            href="/"
            className="p-2 hover:bg-[var(--muted)] rounded-lg transition-colors"
            aria-label="Go to home"
          >
            {getIcon("dashboard", "w-6 h-6", "text-[var(--foreground)]")}
          </Link>

          <div className="flex items-center gap-3">
            {isEditingTitle ? (
              <input
                type="text"
                value={workflowName}
                onChange={(e) => setWorkflowName(e.target.value)}
                onBlur={handleTitleSave}
                onKeyDown={handleTitleKeyDown}
                className="text-xl font-semibold text-[var(--foreground)] bg-[var(--card)] border border-[var(--border)] rounded-md shadow-sm focus:border-[var(--ring)] focus:ring-1 focus:ring-[var(--ring)] focus:outline-none px-3 py-1"
                autoFocus
              />
            ) : (
              <h1
                className="text-xl font-semibold text-[var(--foreground)] cursor-pointer hover:text-[var(--muted-foreground)] transition-colors px-1 py-0.5 rounded"
                onClick={handleTitleEdit}
                title="Click to edit title"
              >
                {workflowName}
              </h1>
            )}

            {/* Auto-save status indicator */}
            <div className="flex items-center gap-2">
              {isSaving && (
                <div className="flex items-center gap-1 text-sm text-[var(--muted-foreground)]">
                  <Loader2 className="w-3 h-3 animate-spin" />
                  <span>Saving...</span>
                </div>
              )}
              {!isSaving && nodes.length > 0 && !lastSaveError && (
                <div className="flex items-center gap-1 text-sm text-green-600 dark:text-green-400">
                  <CheckCircle className="w-3 h-3" />
                </div>
              )}
              {lastSaveError && (
                <div
                  className="flex items-center gap-1 text-sm text-red-600 dark:text-red-400"
                  title={lastSaveError}
                >
                  <AlertCircle className="w-3 h-3" />
                  <span>Save failed</span>
                </div>
              )}
            </div>
          </div>
        </div>

        {/* Action Buttons */}
        <div className="flex items-center gap-3">
          {mounted && (
            <button
              onClick={toggleTheme}
              className="p-2 text-[var(--foreground)] hover:bg-[var(--muted)] rounded-lg transition-colors"
              aria-label="Toggle theme"
            >
              {theme === "dark" ? (
                <svg
                  className="w-5 h-5"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"
                  />
                </svg>
              ) : (
                <svg
                  className="w-5 h-5"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"
                  />
                </svg>
              )}
            </button>
          )}

          <button
            onClick={() => setShowExecutionPanel(!showExecutionPanel)}
            className="p-2 text-[var(--foreground)] hover:bg-[var(--muted)] rounded-lg transition-colors"
            title="View execution details"
          >
            {getIcon("activity", "w-4 h-4")}
          </button>

          <button
            onClick={handleManualSave}
            disabled={isSaving}
            className={`px-3 py-2 text-sm font-medium rounded-lg transition-colors min-w-[80px] ${
              isSaving
                ? "bg-[var(--muted)] text-[var(--muted-foreground)] cursor-not-allowed"
                : showSaveSuccess
                ? "bg-green-100 text-green-800 dark:bg-green-900/20 dark:text-green-400 cursor-not-allowed"
                : "bg-[var(--secondary)] text-[var(--secondary-foreground)] hover:bg-[var(--secondary)]/80"
            }`}
            title="Save workflow"
            aria-label="Save workflow"
          >
            {isSaving ? (
              <div className="flex items-center justify-center">
                <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                Saving...
              </div>
            ) : showSaveSuccess ? (
              <div className="flex items-center justify-center">
                <CheckCircle className="w-4 h-4 mr-2" />
                Saved!
              </div>
            ) : (
              <div className="flex items-center justify-center">
                {getIcon("save", "w-4 h-4", "mr-2")}
                Save
              </div>
            )}
          </button>
          <button
            onClick={handleExecuteWorkflow}
            disabled={isExecuting}
            className={`px-4 py-2 text-sm font-medium rounded-lg transition-colors ${
              isExecuting
                ? "bg-[var(--muted)] text-[var(--muted-foreground)] cursor-not-allowed"
                : "bg-[var(--primary)] text-[var(--primary-foreground)] hover:bg-[var(--primary)]/90"
            }`}
          >
            {isExecuting ? (
              <div className="flex items-center">
                <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                Running...
              </div>
            ) : (
              <div className="flex items-center">
                {getIcon("play", "w-4 h-4", "mr-2")}
                Run
              </div>
            )}
          </button>
        </div>
      </div>
    </div>
  );
};

export default TopBar;

----- Content End -----

===== File: app/editor/components/ConfigurationPanel.tsx =====
Type: .tsx
----- Content Start -----
"use client";

import { getIcon } from "../../../hooks/useIcons";
import { Copy as CopyIcon } from "lucide-react";
import { useAutomationContext } from "../context/AutomationContext";
import type { SchemaField } from "../../../lib/integrations/types";

interface NodeData {
  label: string;
  subtype?: string;
  icon?: string;
  description?: string;
  config?: Record<string, unknown>;
  status?: "idle" | "running" | "success" | "error";
  lastRun?: string;
  executionResult?: Record<string, unknown>;
  colorClass?: string;
  borderClass?: string;
  selectedBorderClass?: string;
}

const ConfigurationPanel = () => {
  const {
    selectedNode,
    executionState,
    copiedField,
    deleteSelectedNode,
    updateNodeConfig,
    getIntegration,
    copyExpression,
    copyDataFieldExpressionWithFeedback,
  } = useAutomationContext();

  if (!selectedNode) {
    return null;
  }

  const nodeData = selectedNode.data as unknown as NodeData;
  const integrationId = nodeData.subtype;
  const integration = getIntegration(integrationId || "");

  if (!integration) {
    return (
      <div className="text-red-500 text-sm">
        Integration not found: {integrationId}
      </div>
    );
  }

  return (
    <>
      <div className="flex items-center justify-between mb-6">
        <div className="flex items-center gap-3">
          <div className="p-2 bg-[var(--muted)] rounded-lg">
            {getIcon(
              nodeData.icon || "circle",
              "w-5 h-5",
              "text-[var(--muted-foreground)]"
            )}
          </div>
          <div>
            <h2 className="text-lg font-semibold text-[var(--foreground)]">
              {nodeData.label}
            </h2>
            <p className="text-sm text-[var(--muted-foreground)] capitalize">
              {selectedNode.type} step
            </p>
          </div>
        </div>
        <button
          onClick={deleteSelectedNode}
          className="p-2 text-[var(--muted-foreground)] hover:text-red-500 hover:bg-red-500/10 rounded-lg transition-colors"
        >
          {getIcon("trash", "w-4 h-4")}
        </button>
      </div>

      {/* Output Section */}
      {nodeData.executionResult && (
        <div className="mb-6">
          <h3 className="text-sm font-semibold text-[var(--foreground)] mb-3">
            Output
          </h3>
          <div className="flex flex-wrap gap-2">
            {Object.keys(
              (nodeData.executionResult?.data as Record<string, unknown>) || {}
            ).map((fieldKey) => (
              <button
                key={fieldKey}
                onClick={() =>
                  copyDataFieldExpressionWithFeedback(selectedNode.id, fieldKey)
                }
                className={`inline-flex items-center gap-1.5 px-3 py-1.5 text-xs font-medium rounded-lg transition-all duration-200 cursor-pointer shadow-sm ${
                  copiedField === fieldKey
                    ? "bg-green-100 border-green-300 text-green-800 dark:bg-green-900/20 dark:border-green-700 dark:text-green-400"
                    : "text-[var(--foreground)] bg-[var(--card)] border border-[var(--border)] hover:bg-[var(--muted)] hover:border-[var(--ring)]"
                }`}
                title={
                  copiedField === fieldKey
                    ? "Copied!"
                    : "Click to copy reference"
                }
              >
                {copiedField === fieldKey ? (
                  <svg
                    className="w-3 h-3"
                    fill="currentColor"
                    viewBox="0 0 20 20"
                  >
                    <path
                      fillRule="evenodd"
                      d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z"
                      clipRule="evenodd"
                    />
                  </svg>
                ) : (
                  <CopyIcon className="w-3 h-3 text-[var(--muted-foreground)]" />
                )}
                {fieldKey}
              </button>
            ))}
          </div>
        </div>
      )}

      <div className="space-y-6">
        <div className="space-y-4">
          {integration.schema.fields.map((field: SchemaField) => (
            <div key={field.key} className="space-y-3">
              <div>
                <label className="block text-sm font-medium text-[var(--foreground)] select-none">
                  {field.label}
                  {field.required && (
                    <span className="text-red-500 ml-1">*</span>
                  )}
                </label>
              </div>

              {field.type === "select" ? (
                <select
                  className="w-full px-4 py-3 border border-[var(--border)] rounded-xl text-sm focus:outline-none focus:border-[var(--ring)] focus:ring-1 focus:ring-[var(--ring)]/10 transition-all bg-[var(--muted)]/50"
                  value={(nodeData.config?.[field.key] as string) || ""}
                  onChange={(e) => {
                    const currentConfig = nodeData.config || {};
                    updateNodeConfig(selectedNode.id, {
                      ...currentConfig,
                      [field.key]: e.target.value,
                    });
                  }}
                >
                  <option value="">Select {field.label}</option>
                  {Array.isArray(field.options) &&
                    field.options.map(
                      (option: { label: string; value: string }) => (
                        <option key={option.value} value={option.value}>
                          {option.label}
                        </option>
                      )
                    )}
                </select>
              ) : field.type === "textarea" ? (
                <textarea
                  className="w-full px-4 py-3 border border-[var(--border)] rounded-xl text-sm focus:outline-none focus:border-[var(--ring)] focus:ring-1 focus:ring-[var(--ring)]/10 transition-all bg-[var(--muted)]/50 resize-none"
                  rows={3}
                  placeholder={field.placeholder}
                  value={(nodeData.config?.[field.key] as string) || ""}
                  onChange={(e) => {
                    const currentConfig = nodeData.config || {};
                    updateNodeConfig(selectedNode.id, {
                      ...currentConfig,
                      [field.key]: e.target.value,
                    });
                  }}
                />
              ) : (
                <input
                  type={
                    field.type === "number"
                      ? "number"
                      : field.type === "email"
                      ? "email"
                      : field.type === "url"
                      ? "url"
                      : "text"
                  }
                  className="w-full px-4 py-3 border border-[var(--border)] rounded-xl text-sm focus:outline-none focus:border-[var(--ring)] focus:ring-1 focus:ring-[var(--ring)]/10 transition-all bg-[var(--muted)]/50"
                  placeholder={field.placeholder}
                  value={(nodeData.config?.[field.key] as string) || ""}
                  onChange={(e) => {
                    const currentConfig = nodeData.config || {};
                    updateNodeConfig(selectedNode.id, {
                      ...currentConfig,
                      [field.key]: e.target.value,
                    });
                  }}
                />
              )}

              {field.supportExpressions && (
                <p className="text-xs text-[var(--muted-foreground)] mt-1">
                  Use {"{{$node.NodeId.data.field}}"} to reference previous
                  nodes or {"{{$vars.variableName}}"} for variables
                </p>
              )}
            </div>
          ))}
        </div>

        {/* Branch Outputs Section */}
        {nodeData.subtype === "branch_condition" && (
          <div className="mt-6 p-4 bg-[var(--muted)]/50 rounded-lg">
            <h4 className="text-sm font-medium text-[var(--foreground)] mb-2">
              Branch Outputs
            </h4>
            <div className="space-y-2 text-xs text-[var(--muted-foreground)]">
              <div>
                âœ… True path: Connects to nodes that execute when condition is
                true
              </div>
              <div>
                âŒ False path: Connects to nodes that execute when condition is
                false
              </div>
            </div>
          </div>
        )}

        {/* Available Data Section */}
        <div className="space-y-4 border-t border-[var(--border)] pt-6">
          <h3 className="text-sm font-semibold text-[var(--foreground)]">
            Available Data
          </h3>

          {/* Previous Node Outputs */}
          {Object.keys(executionState.context.nodeOutputs).length > 0 && (
            <div>
              <h4 className="text-xs font-medium text-[var(--muted-foreground)] mb-2">
                From Previous Nodes:
              </h4>
              <div className="space-y-2 max-h-32 overflow-y-auto">
                {Object.entries(executionState.context.nodeOutputs).map(
                  ([nodeId, output]) => (
                    <div
                      key={nodeId}
                      className="bg-[var(--muted)]/50 rounded p-2"
                    >
                      <button
                        onClick={() =>
                          copyExpression(`{{$node.${nodeId}.data.FIELD}}`)
                        }
                        className="text-xs font-mono text-[var(--foreground)] hover:text-[var(--primary)] cursor-pointer mb-1 block w-full text-left"
                        title="Click to copy"
                      >
                        {`{{$node.${nodeId}.data.FIELD}}`}
                      </button>
                      <div className="text-xs text-[var(--muted-foreground)]">
                        Available fields:{" "}
                        {Object.keys(
                          ((output as Record<string, unknown>)?.data as Record<
                            string,
                            unknown
                          >) || {}
                        ).join(", ") || "none"}
                      </div>
                    </div>
                  )
                )}
              </div>
            </div>
          )}

          {/* Variables */}
          {Object.keys(executionState.context.variables).length > 0 && (
            <div>
              <h4 className="text-xs font-medium text-[var(--muted-foreground)] mb-2">
                Variables:
              </h4>
              <div className="bg-[var(--muted)]/50 rounded p-2">
                {Object.keys(executionState.context.variables).map(
                  (varName) => (
                    <button
                      key={varName}
                      onClick={() => copyExpression(`{{$vars.${varName}}}`)}
                      className="text-xs font-mono text-[var(--foreground)] hover:text-[var(--primary)] cursor-pointer block w-full text-left"
                      title="Click to copy"
                    >
                      {`{{$vars.${varName}}}`}
                    </button>
                  )
                )}
              </div>
            </div>
          )}

          {/* Helpful hint when nothing is available */}
          {Object.keys(executionState.context.nodeOutputs).length === 0 &&
            Object.keys(executionState.context.variables).length === 0 && (
              <div className="text-xs text-[var(--muted-foreground)] italic">
                Run previous nodes to see available data
              </div>
            )}
        </div>
      </div>
    </>
  );
};

export default ConfigurationPanel;

----- Content End -----

===== File: app/editor/components/ExecutionPanel.tsx =====
Type: .tsx
----- Content Start -----
"use client";

import { Loader2 } from "lucide-react";
import { getIcon } from "../../../hooks/useIcons";
import { useAutomationContext } from "../context/AutomationContext";

const ExecutionPanel = () => {
  const { executionState, setShowExecutionPanel } = useAutomationContext();

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between mb-6">
        <h2 className="text-lg font-semibold text-[var(--foreground)]">
          Execution Details
        </h2>
        <button
          onClick={() => setShowExecutionPanel(false)}
          className="p-2 text-[var(--muted-foreground)] hover:bg-[var(--muted)] rounded-lg transition-colors"
        >
          {getIcon("x", "w-4 h-4")}
        </button>
      </div>

      <div
        className={`px-2 py-1 rounded text-xs font-medium mb-4 ${
          executionState.status === "running"
            ? "bg-blue-100 text-blue-800"
            : executionState.status === "completed"
            ? "bg-green-100 text-green-800"
            : executionState.status === "failed"
            ? "bg-red-100 text-red-800"
            : "bg-gray-100 text-gray-800"
        }`}
      >
        {executionState.status}
      </div>

      {/* Variables */}
      <div>
        <h3 className="text-sm font-medium text-[var(--foreground)] mb-2">
          Variables
        </h3>
        <div className="bg-[var(--muted)]/50 rounded-lg p-3 text-xs">
          <pre className="whitespace-pre-wrap text-[var(--muted-foreground)]">
            {Object.keys(executionState.context.variables).length > 0
              ? JSON.stringify(executionState.context.variables, null, 2)
              : "No variables set"}
          </pre>
        </div>
      </div>

      {/* Node Outputs */}
      <div>
        <h3 className="text-sm font-medium text-[var(--foreground)] mb-2">
          Node Outputs
        </h3>
        <div className="space-y-2 max-h-64 overflow-y-auto">
          {Object.keys(executionState.context.nodeOutputs).length === 0 ? (
            <div className="text-xs text-[var(--muted-foreground)] italic">
              No node outputs yet. Run the workflow to see results.
            </div>
          ) : (
            Object.entries(executionState.context.nodeOutputs).map(
              ([nodeId, output]) => (
                <div
                  key={nodeId}
                  className="bg-[var(--muted)]/50 rounded-lg p-3"
                >
                  <div className="flex items-center gap-2 mb-2">
                    <span className="text-xs font-medium text-[var(--foreground)]">
                      {nodeId}
                    </span>
                    {executionState.currentNode === nodeId && (
                      <Loader2 className="w-3 h-3 animate-spin text-blue-500" />
                    )}
                  </div>
                  <pre className="text-xs text-[var(--muted-foreground)] whitespace-pre-wrap">
                    {JSON.stringify(output, null, 2)}
                  </pre>
                </div>
              )
            )
          )}
        </div>
      </div>
    </div>
  );
};

export default ExecutionPanel;

----- Content End -----

===== File: app/editor/components/NodeLibraryPanel.tsx =====
Type: .tsx
----- Content Start -----
"use client";

import { useState, useMemo } from "react";
import { getIcon } from "../../../hooks/useIcons";
import { useAutomationContext } from "../context/AutomationContext";
import type { Integration } from "../../../lib/integrations/types";
import type { WorkflowTemplate } from "../../../lib/integrations/templates";

const NodeLibraryPanel = () => {
  const {
    sidebarOpen,
    setSidebarOpen,
    getTriggerIntegrations,
    getActionIntegrations,
    getLogicIntegrations,
    getTemplates,
  } = useAutomationContext();

  const [searchTerm, setSearchTerm] = useState("");

  const renderSidebarIcon = (
    iconName: string,
    nodeData: { colorClass?: string }
  ) => {
    const colorClass = nodeData.colorClass || "text-[var(--foreground)]";
    return getIcon(iconName, "w-5 h-5", colorClass);
  };

  const onDragStart = (
    event: React.DragEvent,
    nodeType: string,
    label: string,
    subtype: string,
    icon: string,
    description: string,
    colorClass: string,
    borderClass: string,
    selectedBorderClass: string
  ) => {
    event.dataTransfer.setData(
      "application/reactflow",
      JSON.stringify({
        type: nodeType,
        label,
        subtype,
        icon,
        description,
        colorClass,
        borderClass,
        selectedBorderClass,
      })
    );
    event.dataTransfer.effectAllowed = "move";
  };

  // Filter integrations based on search term
  const filteredTriggers = useMemo(() => {
    if (!searchTerm) return getTriggerIntegrations();
    return getTriggerIntegrations().filter(
      (integration) =>
        integration.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        integration.description.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [searchTerm, getTriggerIntegrations]);

  const filteredActions = useMemo(() => {
    if (!searchTerm) return getActionIntegrations();
    return getActionIntegrations().filter(
      (integration) =>
        integration.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        integration.description.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [searchTerm, getActionIntegrations]);

  const filteredLogic = useMemo(() => {
    if (!searchTerm) return getLogicIntegrations();
    return getLogicIntegrations().filter(
      (integration) =>
        integration.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        integration.description.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [searchTerm, getLogicIntegrations]);

  // Add filtered templates
  const filteredTemplates = useMemo(() => {
    if (!searchTerm) return getTemplates();
    return getTemplates().filter(
      (template) =>
        template.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        template.description.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [searchTerm, getTemplates]);

  const renderIntegrationCard = (
    integration: Integration,
    category: string,
    index: number
  ) => (
    <div
      key={`${category}-${index}`}
      className={`p-3 border rounded-lg cursor-move hover:shadow-sm transition-all group bg-[var(--card)] ${
        integration.borderClass ||
        "border-gray-200 dark:border-gray-700 hover:border-gray-300 dark:hover:border-gray-600"
      }`}
      draggable
      onDragStart={(e) =>
        onDragStart(
          e,
          integration.category,
          integration.name,
          integration.id,
          integration.icon,
          integration.description,
          integration.colorClass || "",
          integration.borderClass || "",
          integration.selectedBorderClass || ""
        )
      }
    >
      <div className="flex items-start gap-3">
        <div className="flex-shrink-0">
          {renderSidebarIcon(integration.icon, integration)}
        </div>
        <div className="min-w-0 flex-1">
          <h3 className="font-medium text-[var(--foreground)] text-sm leading-snug">
            {integration.name}
          </h3>
          <p className="text-xs text-[var(--muted-foreground)] mt-1 leading-relaxed">
            {integration.description}
          </p>
        </div>
      </div>
    </div>
  );

  // Add template card renderer
  const renderTemplateCard = (template: WorkflowTemplate, index: number) => (
    <div
      key={`template-${index}`}
      className="p-3 border rounded-lg cursor-move hover:shadow-sm transition-all group bg-[var(--card)] border-emerald-200 dark:border-emerald-800 hover:border-emerald-300 dark:hover:border-emerald-700"
      draggable
      onDragStart={(e) => onDragStartTemplate(e, template)}
    >
      <div className="flex items-start gap-3">
        <div className="flex-shrink-0">
          {getIcon(
            template.icon,
            "w-5 h-5",
            "text-emerald-600 dark:text-emerald-400"
          )}
        </div>
        <div className="min-w-0 flex-1">
          <h3 className="font-medium text-[var(--foreground)] text-sm leading-snug">
            {template.name}
          </h3>
          <p className="text-xs text-[var(--muted-foreground)] mt-1 leading-relaxed">
            {template.description}
          </p>
          <p className="text-xs text-emerald-600 dark:text-emerald-400 mt-1">
            {template.nodes.length} nodes
          </p>
        </div>
      </div>
    </div>
  );

  // Add this new function in the same component
  const onDragStartTemplate = (
    event: React.DragEvent,
    template: WorkflowTemplate
  ) => {
    event.dataTransfer.setData(
      "application/reactflow/template",
      JSON.stringify(template)
    );
    event.dataTransfer.effectAllowed = "move";
  };

  return (
    <div
      className={`
        bg-[var(--card)] border-r border-[var(--border)] transition-colors duration-200 flex flex-col
        ${sidebarOpen ? "w-80" : "w-0 overflow-hidden"}
      `}
    >
      {/* Fixed Header with Search and Close */}
      <div className="sticky top-0 z-10 bg-[var(--card)] border-b border-[var(--border)] px-6 py-4">
        <div className="flex items-center gap-3">
          <div className="flex-1 relative">
            <div className="absolute inset-y-0 left-3 flex items-center pointer-events-none">
              {getIcon("search", "w-4 h-4", "text-[var(--muted-foreground)]")}
            </div>
            <input
              type="text"
              placeholder="Search components..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="w-full pl-10 pr-3 py-2 text-sm bg-[var(--muted)] border border-[var(--border)] rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-[var(--foreground)] placeholder-[var(--muted-foreground)]"
            />
          </div>
          <button
            onClick={() => setSidebarOpen(false)}
            className="p-2 hover:bg-[var(--muted)] rounded-md transition-colors flex-shrink-0"
          >
            {getIcon("x", "w-4 h-4", "text-[var(--foreground)]")}
          </button>
        </div>
      </div>

      {/* Scrollable Content */}
      <div className="flex-1 overflow-y-auto px-6 pb-4 custom-scrollbar">
        <div className="space-y-6 pt-4">
          {/* Templates Section - Add this FIRST */}
          {filteredTemplates.length > 0 && (
            <div>
              <div className="space-y-2">
                <h3 className="text-sm font-semibold text-[var(--foreground)] mb-3">
                  Templates
                </h3>
                {filteredTemplates.map((template, index) =>
                  renderTemplateCard(template, index)
                )}
              </div>
            </div>
          )}

          {/* Triggers Section */}
          {filteredTriggers.length > 0 && (
            <div>
              <div className="space-y-2">
                <h3 className="text-sm font-semibold text-[var(--foreground)] mb-3">
                  Triggers
                </h3>
                {filteredTriggers.map((integration, index) =>
                  renderIntegrationCard(integration, "trigger", index)
                )}
              </div>
            </div>
          )}

          {/* Actions Section */}
          {filteredActions.length > 0 && (
            <div>
              <div className="space-y-2">
                <h3 className="text-sm font-semibold text-[var(--foreground)] mb-3">
                  Actions
                </h3>
                {filteredActions.map((integration, index) =>
                  renderIntegrationCard(integration, "action", index)
                )}
              </div>
            </div>
          )}

          {/* Logic Section */}
          {filteredLogic.length > 0 && (
            <div>
              <div className="space-y-2">
                <h3 className="text-sm font-semibold text-[var(--foreground)] mb-3">
                  Logic
                </h3>
                {filteredLogic.map((integration, index) =>
                  renderIntegrationCard(integration, "logic", index)
                )}
              </div>
            </div>
          )}

          {/* Update No Results Message */}
          {searchTerm &&
            filteredTemplates.length === 0 &&
            filteredTriggers.length === 0 &&
            filteredActions.length === 0 &&
            filteredLogic.length === 0 && (
              <div className="text-center py-8">
                <div className="text-[var(--muted-foreground)] text-sm">
                  No components or templates found for &quot;{searchTerm}&quot;
                </div>
              </div>
            )}
        </div>
      </div>
    </div>
  );
};

export default NodeLibraryPanel;

----- Content End -----

===== File: app/editor/hooks/useEditor.tsx =====
Type: .tsx
----- Content Start -----
import { useState, useCallback } from "react";
import { Node, Edge } from "@xyflow/react";
import { integrationRegistry } from "../../../lib/integrations/registry";
import { parseExpression } from "../../../lib/expression";

// ============================================
// TYPE DEFINITIONS
// ============================================

interface WorkflowContext {
  variables: Record<string, unknown>;
  nodeOutputs: Record<string, unknown>;
  executionId: string;
  userId?: string;
}

interface ExecutionState {
  currentNode: string | null;
  completedNodes: Set<string>;
  context: WorkflowContext;
  status: "idle" | "running" | "completed" | "failed";
}

interface ExecutionStep {
  node_id: string;
  status: string;
  completed_at?: string;
  result?: {
    success: boolean;
    data?: Record<string, unknown>;
    metadata?: {
      nodeType: string;
      subtype: string;
      [key: string]: unknown;
    };
    [key: string]: unknown;
  };
}

interface WorkflowDefinition {
  id: string;
  name: string;
  nodes: Node[];
  edges: Edge[];
  createdAt: string;
  updatedAt: string;
}

// ============================================
// EXPRESSION PARSER
// ============================================

// Using shared parseExpression from lib/expression.ts

// ============================================
// USE EDITOR HOOK
// ============================================

export const useEditor = (currentWorkflowId: string | null = null) => {
  const registry = integrationRegistry;
  const [executionState, setExecutionState] = useState<ExecutionState>({
    currentNode: null,
    completedNodes: new Set(),
    context: {
      variables: {},
      nodeOutputs: {},
      executionId: "",
    },
    status: "idle",
  });
  const [isExecuting, setIsExecuting] = useState(false);
  const [lastLoadedExecutionId, setLastLoadedExecutionId] = useState<
    string | null
  >(null);

  // Function to restore execution state from database
  const restoreLatestExecution = useCallback(async (workflowId: string) => {
    try {
      // Get the most recent execution for this workflow
      const response = await fetch(
        `/api/execute?workflowId=${workflowId}&latest=true`
      );
      if (!response.ok) return null;

      const execution = await response.json();
      if (!execution || execution.status === "pending") return null;

      // Get detailed execution status with steps
      const statusResponse = await fetch(
        `/api/execute?executionId=${execution.id}`
      );
      if (!statusResponse.ok) return null;

      const executionDetails = await statusResponse.json();

      console.log("ðŸ”„ Restoring execution state:", executionDetails);

      // Restore execution state
      const restoredContext: WorkflowContext = {
        variables: {},
        nodeOutputs: {},
        executionId: execution.id,
      };

      // Process each step to rebuild context
      if (executionDetails.steps) {
        executionDetails.steps.forEach((step: ExecutionStep) => {
          if (step.status === "completed" && step.result) {
            // Add to node outputs
            restoredContext.nodeOutputs[step.node_id] = step.result;

            // Handle variables from set_variable steps
            if (
              step.result?.metadata?.subtype === "set_variable" &&
              step.result.data
            ) {
              const data = step.result.data as {
                variableName: string;
                value: unknown;
              };
              restoredContext.variables[data.variableName] = data.value;
            }
          }
        });
      }

      // Update execution state
      setExecutionState({
        currentNode: null,
        completedNodes: new Set(
          executionDetails.steps
            ?.filter((s: ExecutionStep) => s.status === "completed")
            ?.map((s: ExecutionStep) => s.node_id) || []
        ),
        context: restoredContext,
        status:
          executionDetails.status === "completed"
            ? "completed"
            : executionDetails.status === "failed"
            ? "failed"
            : "idle",
      });

      setLastLoadedExecutionId(execution.id);

      return { execution, steps: executionDetails.steps };
    } catch (error) {
      console.error("Failed to restore execution state:", error);
      return null;
    }
  }, []);

  // Function to restore node visual states
  const restoreNodeStates = useCallback(
    (
      nodes: Node[],
      steps: ExecutionStep[],
      onNodeStatusChange: (
        nodeId: string,
        status: "idle" | "running" | "success" | "error",
        lastRun?: string,
        executionResult?: Record<string, unknown>
      ) => void
    ) => {
      steps?.forEach((step: ExecutionStep) => {
        if (step.result) {
          onNodeStatusChange(
            step.node_id,
            step.status === "completed" ? "success" : "error",
            step.completed_at
              ? new Date(step.completed_at).toLocaleTimeString()
              : undefined,
            step.result
          );
        }
      });
    },
    []
  );

  // Enhanced loadWorkflow to restore execution state
  const loadWorkflow = useCallback(async (): Promise<
    | (WorkflowDefinition & {
        restoredExecution?: {
          execution: unknown;
          steps: ExecutionStep[];
        } | null;
      })
    | null
  > => {
    try {
      const response = await fetch("/api/automations");
      if (!response.ok) throw new Error("Failed to load automations");

      const workflows = await response.json();
      if (workflows.length > 0) {
        const workflow = workflows[0];
        // setCurrentWorkflowId(workflow.id); // This line is removed as per the edit hint

        const result = {
          id: workflow.id,
          name: workflow.name,
          nodes: workflow.nodes,
          edges: workflow.edges,
          createdAt: workflow.createdAt || new Date().toISOString(),
          updatedAt: workflow.updatedAt || new Date().toISOString(),
        };

        // Try to restore the latest execution state
        const restoredExecution = await restoreLatestExecution(workflow.id);

        return {
          ...result,
          restoredExecution,
        };
      }
      return null;
    } catch (error) {
      console.error("Load failed:", error);
      return null;
    }
  }, [restoreLatestExecution]);

  // Save workflow to database
  const saveWorkflow = useCallback(
    async (
      nodes: Node[],
      edges: Edge[],
      name: string = "Untitled Workflow"
    ) => {
      try {
        const method = currentWorkflowId ? "PUT" : "POST";
        const body = currentWorkflowId
          ? JSON.stringify({ id: currentWorkflowId, name, nodes, edges })
          : JSON.stringify({ name, nodes, edges });

        const response = await fetch("/api/automations", {
          method,
          headers: { "Content-Type": "application/json" },
          body,
        });

        if (!response.ok) throw new Error("Failed to save workflow");

        const workflow = await response.json();

        // Update the URL to reflect the new automation ID if this is a new workflow
        if (!currentWorkflowId) {
          window.history.replaceState({}, "", `/editor?id=${workflow.id}`);
        }

        console.log("Workflow saved:", workflow);
        return { success: true, id: workflow.id };
      } catch (error) {
        console.error("Save failed:", error);
        throw error;
      }
    },
    [currentWorkflowId]
  );

  // Execute workflow in background
  const executeWorkflow = useCallback(
    async (
      nodes: Node[],
      edges: Edge[],
      onNodeStatusChange: (
        nodeId: string,
        status: "idle" | "running" | "success" | "error",
        lastRun?: string,
        executionResult?: Record<string, unknown>
      ) => void
    ) => {
      if (isExecuting || !currentWorkflowId) return;

      // Clear any previously restored state
      setLastLoadedExecutionId(null);

      // Reset execution state to fresh
      setExecutionState({
        currentNode: null,
        completedNodes: new Set(),
        context: {
          variables: {},
          nodeOutputs: {},
          executionId: "",
        },
        status: "idle",
      });

      setIsExecuting(true);

      try {
        // Start background execution
        const response = await fetch(`/api/execute`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ workflowId: currentWorkflowId }),
        });

        if (!response.ok) throw new Error("Failed to start execution");

        const { executionId } = await response.json();

        setExecutionState((prev) => ({
          ...prev,
          status: "running",
          context: { ...prev.context, executionId },
        }));

        // Poll for execution status
        const pollInterval = setInterval(async () => {
          try {
            const statusResponse = await fetch(
              `/api/execute?executionId=${executionId}`
            );
            const status = await statusResponse.json();

            if (status.status === "completed" || status.status === "failed") {
              clearInterval(pollInterval);
              setExecutionState((prev) => ({
                ...prev,
                status: status.status === "completed" ? "completed" : "failed",
              }));
              setIsExecuting(false);

              // Reset all nodes to idle first, then update completed nodes
              if (status.steps) {
                // Reset all nodes to idle first
                nodes.forEach((node) => {
                  onNodeStatusChange(node.id, "idle");
                });

                // Update completed nodes
                status.steps.forEach((step: ExecutionStep) => {
                  onNodeStatusChange(
                    step.node_id,
                    step.status === "completed" ? "success" : "error",
                    step.completed_at
                      ? new Date(step.completed_at).toLocaleTimeString()
                      : undefined,
                    step.result
                  );

                  if (step.status === "completed" && step.result) {
                    setExecutionState((prev) => ({
                      ...prev,
                      context: {
                        ...prev.context,
                        nodeOutputs: {
                          ...prev.context.nodeOutputs,
                          [step.node_id]: step.result,
                        },
                        variables:
                          step.result?.metadata?.subtype === "set_variable" &&
                          step.result.data
                            ? {
                                ...prev.context.variables,
                                [(
                                  step.result.data as {
                                    variableName: string;
                                    value: unknown;
                                  }
                                ).variableName]: (
                                  step.result.data as {
                                    variableName: string;
                                    value: unknown;
                                  }
                                ).value,
                              }
                            : prev.context.variables,
                      },
                    }));
                  }
                });
              }
            } else if (status.status === "running") {
              // Find the currently running step and update only that node
              const runningStep = status.steps?.find(
                (s: ExecutionStep) => s.status === "running"
              );
              if (runningStep) {
                // Reset all to idle first, then set current to running
                nodes.forEach((node) => {
                  const isCompleted = status.steps?.some(
                    (s: ExecutionStep) =>
                      s.node_id === node.id && s.status === "completed"
                  );
                  onNodeStatusChange(node.id, isCompleted ? "success" : "idle");
                });

                onNodeStatusChange(runningStep.node_id, "running");
              }
            }
          } catch (error) {
            console.error("Polling error:", error);
            clearInterval(pollInterval);
            setIsExecuting(false);
          }
        }, 2000); // Poll every 2 seconds
      } catch (error) {
        console.error("Execution failed:", error);
        setIsExecuting(false);
        setExecutionState((prev) => ({ ...prev, status: "failed" }));
      }
    },
    [isExecuting, currentWorkflowId]
  );

  return {
    // State
    executionState,
    isExecuting,
    registry,
    lastLoadedExecutionId,

    // Actions
    saveWorkflow,
    loadWorkflow,
    executeWorkflow,
    restoreLatestExecution,
    restoreNodeStates,

    // Utilities
    parseExpression,
  };
};

----- Content End -----

===== File: lib/expression.ts =====
Type: .ts
----- Content Start -----
export interface WorkflowContext {
  variables: Record<string, unknown>;
  nodeOutputs: Record<string, unknown>;
}

function getNestedValue(obj: unknown, path: string): unknown {
  return path
    .split(".")
    .reduce(
      (acc, key) =>
        acc && typeof acc === "object" && key in acc
          ? (acc as Record<string, unknown>)[key]
          : undefined,
      obj
    );
}

/**
 * Interpolate {{ â€¦ }} placeholders.
 *   â€¢ quoteStrings = false  â†’ bare values (for Slack, e-mail, etc.)
 *   â€¢ quoteStrings = true   â†’ strings are JSON-quoted (for eval)
 */
export function parseExpression(
  str: unknown,
  ctx: WorkflowContext,
  quoteStrings = false
): unknown {
  if (typeof str !== "string") return str;

  return str.replace(/\{\{([^}]+)\}\}/g, (match, expr) => {
    const trimmed = expr.trim();

    // Debug logging
    console.log(`ðŸ” Parsing expression: ${trimmed}`);

    // ---------------- $node ----------------
    if (trimmed.startsWith("$node.")) {
      const [, nodeId, ...rest] = trimmed.split(".");
      const nodeOutput = ctx.nodeOutputs[nodeId];
      console.log(`ðŸ“Š Node ${nodeId} output:`, nodeOutput);

      if (!nodeOutput) {
        console.warn(`âš ï¸ Node output not found for: ${nodeId}`);
        return match; // Return original if not found
      }

      const value = getNestedValue(nodeOutput, rest.join("."));
      console.log(`âœ… Resolved value:`, value);
      return serialise(value, quoteStrings);
    }

    // ---------------- $vars ----------------
    if (trimmed.startsWith("$vars.")) {
      const [, varName, ...rest] = trimmed.split(".");
      const base = ctx.variables[varName];
      console.log(`ðŸ“ Variable ${varName}:`, base);

      if (base === undefined) {
        console.warn(`âš ï¸ Variable not found: ${varName}`);
        return match;
      }

      const value =
        rest.length === 0 ? base : getNestedValue(base, rest.join("."));
      return serialise(value, quoteStrings);
    }

    console.warn(`âŒ Unknown expression pattern: ${trimmed}`);
    return match; // leave untouched
  });
}

function serialise(v: unknown, quoteStrings: boolean): string {
  if (v === undefined || v === null) return "";
  if (typeof v === "string") {
    // When quoteStrings === true we want a JS string literal
    //   high  â†’  'high'
    //   foo's â†’  'foo\'s'
    return quoteStrings ? `'${String(v).replace(/'/g, "\\'")}'` : v;
  }
  if (typeof v === "number" || typeof v === "boolean") return String(v);
  return JSON.stringify(v); // objects / arrays
}

----- Content End -----

===== File: lib/execution-engine.ts =====
Type: .ts
----- Content Start -----
import {
  getExecutionWithWorkflow,
  updateExecutionToRunning,
  updateExecutionToCompleted,
  updateExecutionToFailed,
  createExecutionStep,
  updateExecutionStepToRunning,
  updateExecutionStepToCompleted,
  updateExecutionStepToFailed,
  getNextPendingExecution,
} from "./db";
import { integrationRegistry } from "./integrations/registry";
import type { WorkflowContext } from "./integrations/types";

interface WorkflowNode {
  id: string;
  type: string;
  data: {
    label: string;
    subtype?: string;
    config?: Record<string, unknown>;
  };
}

interface WorkflowEdge {
  id: string;
  source: string;
  target: string;
  sourceHandle?: string; // Add this to identify which output handle (true/false)
}

export class ExecutionEngine {
  private branchDecisions: Map<string, boolean> = new Map(); // Track branch decisions

  async executeWorkflow(executionId: string) {
    try {
      // Get execution and workflow data
      const execution = await getExecutionWithWorkflow(executionId);
      if (!execution) {
        const error = new Error("Execution not found");
        throw error;
      }

      const nodes: WorkflowNode[] =
        execution.nodes as unknown as WorkflowNode[];
      const edges: WorkflowEdge[] =
        execution.edges as unknown as WorkflowEdge[];

      // Update status to running
      await updateExecutionToRunning(executionId);

      const context: WorkflowContext = {
        variables: {},
        nodeOutputs: {},
        executionId,
      };

      // Reset branch decisions for each execution
      this.branchDecisions.clear();

      // Get execution order (topological sort)
      const executionOrder = this.getExecutionOrder(nodes, edges);

      // Execute nodes in order with conditional path support
      for (const nodeId of executionOrder) {
        const node = nodes.find((n) => n.id === nodeId);
        if (!node) {
          continue;
        }

        // Check if this node should be skipped based on branch conditions
        if (this.shouldSkipNode(nodeId, nodes, edges)) {
          console.log(`Skipping node ${nodeId} due to branch condition`);
          continue;
        }

        await this.executeNode(node, context, executionId);
      }

      // Mark as completed
      await updateExecutionToCompleted(executionId);
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : "Unknown error";

      // Mark as failed
      await updateExecutionToFailed(executionId, errorMessage);
      throw error;
    }
  }

  private shouldSkipNode(
    nodeId: string,
    nodes: WorkflowNode[],
    edges: WorkflowEdge[]
  ): boolean {
    // Find all edges leading to this node
    const incomingEdges = edges.filter((e) => e.target === nodeId);

    for (const edge of incomingEdges) {
      const sourceNode = nodes.find((n) => n.id === edge.source);
      if (!sourceNode) continue;

      // Check if source is a branch node
      if (sourceNode.data.subtype === "branch_condition") {
        const branchResult = this.branchDecisions.get(sourceNode.id);
        if (branchResult === undefined) continue; // Branch not yet executed

        // Check if this edge matches the branch result
        const isTrue =
          edge.sourceHandle === "true" || edge.id.includes("-true-");
        const isFalse =
          edge.sourceHandle === "false" || edge.id.includes("-false-");

        if ((isTrue && !branchResult) || (isFalse && branchResult)) {
          return true; // Skip this node
        }
      }
    }

    return false;
  }

  private async executeNode(
    node: WorkflowNode,
    context: WorkflowContext,
    executionId: string
  ) {
    const nodeId = node.id;

    // Create execution step record
    const stepId = await createExecutionStep(executionId, nodeId);

    // Set to running BEFORE execution
    await updateExecutionStepToRunning(stepId);

    try {
      // Execute the node
      const result = await this.simulateNodeExecution(node, context);

      // Store branch decisions
      if (
        node.data.subtype === "branch_condition" &&
        "data" in result &&
        result.data
      ) {
        const branchData = result.data as Record<string, unknown>;
        if (branchData.result !== undefined) {
          this.branchDecisions.set(node.id, branchData.result as boolean);
        }
      }

      // Store result in context
      context.nodeOutputs[nodeId] = result;

      // Update step as completed
      await updateExecutionStepToCompleted(stepId, result);
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : "Unknown error";

      // Update step as failed
      await updateExecutionStepToFailed(stepId, errorMessage);
      throw error;
    }
  }

  private async simulateNodeExecution(
    node: WorkflowNode,
    context: WorkflowContext
  ) {
    const config = node.data.config || {};
    const integrationId = node.data.subtype;

    if (!integrationId) {
      return {
        success: false,
        error: "No integration subtype specified for node",
        metadata: { nodeType: "unknown" },
      };
    }

    try {
      // Use the integration registry to execute the node
      const result = await integrationRegistry.executeIntegration(
        integrationId,
        config,
        context
      );

      return result;
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
        metadata: { nodeType: integrationId },
      };
    }
  }

  private getExecutionOrder(
    nodes: WorkflowNode[],
    edges: WorkflowEdge[]
  ): string[] {
    const adjacencyList: Record<string, string[]> = {};
    const inDegree: Record<string, number> = {};

    // Initialize
    nodes.forEach((node) => {
      adjacencyList[node.id] = [];
      inDegree[node.id] = 0;
    });

    // Build graph
    edges.forEach((edge) => {
      adjacencyList[edge.source].push(edge.target);
      inDegree[edge.target]++;
    });

    // Topological sort
    const queue: string[] = [];
    const result: string[] = [];

    Object.keys(inDegree).forEach((nodeId) => {
      if (inDegree[nodeId] === 0) {
        queue.push(nodeId);
      }
    });

    while (queue.length > 0) {
      const nodeId = queue.shift()!;
      result.push(nodeId);

      adjacencyList[nodeId].forEach((neighbor) => {
        inDegree[neighbor]--;
        if (inDegree[neighbor] === 0) {
          queue.push(neighbor);
        }
      });
    }

    if (result.length !== nodes.length) {
      throw new Error("Workflow contains cycles");
    }

    return result;
  }
}

export class QueueProcessor {
  private isProcessing = false;
  private engine = new ExecutionEngine();
  private processingCount = 0;

  async start() {
    if (this.isProcessing) return;
    this.isProcessing = true;

    while (this.isProcessing) {
      try {
        await this.processNextExecution();
        await new Promise((resolve) => setTimeout(resolve, 1000)); // Wait 1 second
      } catch (error) {
        console.error("Queue processing error:", error);
        await new Promise((resolve) => setTimeout(resolve, 5000)); // Wait 5 seconds on error
      }
    }
  }

  stop() {
    this.isProcessing = false;
  }

  private async processNextExecution() {
    const executionId = await getNextPendingExecution();

    if (executionId) {
      this.processingCount++;
      await this.engine.executeWorkflow(executionId);
      this.processingCount--;
    }
  }
}

----- Content End -----

===== File: lib/db.ts =====
Type: .ts
----- Content Start -----
import { Pool } from "pg";

if (!process.env.DATABASE_URL) {
  throw new Error("DATABASE_URL environment variable is not set");
}

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: { rejectUnauthorized: false },
  max: 10,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 10000,
});

// Test the connection
pool.on("connect", () => {
  console.log("âœ… Connected to PostgreSQL database");
});

pool.on("error", (err) => {
  console.error("âŒ PostgreSQL connection error:", err);
});

// SQL table creation script
const createTablesSQL = `
CREATE TABLE IF NOT EXISTS automations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  nodes JSONB NOT NULL,
  edges JSONB NOT NULL,
  status VARCHAR(20) DEFAULT 'active',
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS automation_executions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  automation_id UUID REFERENCES automations(id) ON DELETE CASCADE,
  status VARCHAR(20) DEFAULT 'pending',
  started_at TIMESTAMP DEFAULT NOW(),
  completed_at TIMESTAMP,
  context JSONB DEFAULT '{}',
  error_message TEXT,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS execution_steps (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  execution_id UUID REFERENCES automation_executions(id) ON DELETE CASCADE,
  node_id VARCHAR(255) NOT NULL,
  status VARCHAR(20) DEFAULT 'pending',
  result JSONB,
  started_at TIMESTAMP,
  completed_at TIMESTAMP,
  error_message TEXT,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS scheduled_automations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  automation_id UUID REFERENCES automations(id) ON DELETE CASCADE,
  cron_expression VARCHAR(100) NOT NULL,
  timezone VARCHAR(50) DEFAULT 'UTC',
  last_run TIMESTAMP,
  next_run TIMESTAMP NOT NULL,
  active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_automation_executions_automation_id ON automation_executions(automation_id);
CREATE INDEX IF NOT EXISTS idx_automation_executions_status ON automation_executions(status);
CREATE INDEX IF NOT EXISTS idx_execution_steps_execution_id ON execution_steps(execution_id);
CREATE INDEX IF NOT EXISTS idx_scheduled_automations_next_run ON scheduled_automations(next_run, active);
`;

/**
 * Initialize database schema
 * Creates all necessary tables and indexes if they don't exist
 */
export async function initializeDatabase() {
  try {
    await pool.query(createTablesSQL);
    console.log("âœ… Database tables created/verified");
    return true;
  } catch (error) {
    console.error("âŒ Failed to initialize database:", error);
    throw error;
  }
}

// ============================================
// AUTOMATION DATABASE OPERATIONS
// ============================================

export interface Automation {
  id: string;
  name: string;
  nodes: Record<string, unknown>[];
  edges: Record<string, unknown>[];
  status: string;
  created_at: string;
  updated_at: string;
}

/**
 * Get all automations ordered by most recently updated
 */
export async function getAllAutomations(): Promise<Automation[]> {
  try {
    const result = await pool.query(
      "SELECT * FROM automations ORDER BY updated_at DESC"
    );
    return result.rows;
  } catch (error) {
    console.error("Failed to fetch automations:", error);
    throw new Error("Failed to fetch automations");
  }
}

/**
 * Create a new automation
 */
export async function createAutomation(
  name: string,
  nodes: Record<string, unknown>[],
  edges: Record<string, unknown>[]
): Promise<Automation> {
  try {
    const result = await pool.query(
      "INSERT INTO automations (name, nodes, edges) VALUES ($1, $2, $3) RETURNING *",
      [name, JSON.stringify(nodes), JSON.stringify(edges)]
    );
    return result.rows[0];
  } catch (error) {
    console.error("Failed to create automation:", error);
    throw new Error("Failed to create automation");
  }
}

/**
 * Update an existing automation
 */
export async function updateAutomation(
  id: string,
  name: string,
  nodes: Record<string, unknown>[],
  edges: Record<string, unknown>[]
): Promise<Automation> {
  try {
    const result = await pool.query(
      "UPDATE automations SET name = $1, nodes = $2, edges = $3, updated_at = NOW() WHERE id = $4 RETURNING *",
      [name, JSON.stringify(nodes), JSON.stringify(edges), id]
    );

    if (result.rows.length === 0) {
      throw new Error("Automation not found");
    }

    return result.rows[0];
  } catch (error) {
    console.error("Failed to update automation:", error);
    throw error;
  }
}

/**
 * Delete an automation
 */
export async function deleteAutomation(id: string): Promise<void> {
  try {
    const result = await pool.query(
      "DELETE FROM automations WHERE id = $1 RETURNING *",
      [id]
    );

    if (result.rows.length === 0) {
      throw new Error("Automation not found");
    }
  } catch (error) {
    console.error("Failed to delete automation:", error);
    throw error;
  }
}

// ============================================
// EXECUTION DATABASE OPERATIONS
// ============================================

export interface ExecutionStep {
  id: string | null;
  node_id: string;
  status: string;
  result: string | number | boolean | object | null;
  started_at: string | null;
  completed_at: string | null;
  error_message: string | null;
}

export interface Execution {
  id: string;
  automation_id: string;
  status: string;
  started_at: string;
  completed_at: string | null;
  context: Record<string, unknown>;
  error_message: string | null;
  created_at: string;
  steps?: ExecutionStep[];
}

/**
 * Create a new execution record
 */
export async function createExecution(
  automationId: string
): Promise<Execution> {
  try {
    const result = await pool.query(
      "INSERT INTO automation_executions (automation_id, status) VALUES ($1, $2) RETURNING *",
      [automationId, "pending"]
    );
    return result.rows[0];
  } catch (error) {
    console.error("Failed to create execution:", error);
    throw new Error("Failed to create execution");
  }
}

/**
 * Get execution with steps by execution ID
 */
export async function getExecutionWithSteps(
  executionId: string
): Promise<Execution | null> {
  try {
    const executionQuery = `
      SELECT 
        we.*,
        json_agg(
          json_build_object(
            'id', es.id,
            'node_id', es.node_id,
            'status', es.status,
            'result', es.result,
            'started_at', es.started_at,
            'completed_at', es.completed_at,
            'error_message', es.error_message
          ) ORDER BY es.created_at
        ) as steps
      FROM automation_executions we
      LEFT JOIN execution_steps es ON we.id = es.execution_id
      WHERE we.id = $1
      GROUP BY we.id
    `;

    const result = await pool.query(executionQuery, [executionId]);

    if (result.rows.length === 0) {
      return null;
    }

    const execution = result.rows[0];

    // Filter out null steps
    const validSteps = execution.steps.filter(
      (step: ExecutionStep) => step.id !== null
    );

    return {
      ...execution,
      steps: validSteps,
    };
  } catch (error) {
    console.error("Failed to get execution with steps:", error);
    throw new Error("Failed to get execution");
  }
}

/**
 * Get latest execution for an automation
 */
export async function getLatestExecution(
  automationId: string
): Promise<Execution | null> {
  try {
    const result = await pool.query(
      `SELECT id, status, started_at, completed_at, created_at 
       FROM automation_executions 
       WHERE automation_id = $1 
       ORDER BY created_at DESC 
       LIMIT 1`,
      [automationId]
    );

    if (result.rows.length === 0) {
      return null;
    }

    return result.rows[0];
  } catch (error) {
    console.error("Failed to get latest execution:", error);
    throw new Error("Failed to get latest execution");
  }
}

export { pool };

// ============================================
// EXECUTION ENGINE DATABASE OPERATIONS
// ============================================

export interface WorkflowExecution {
  id: string;
  workflow_id: string;
  status: string;
  started_at: string | null;
  completed_at: string | null;
  error_message: string | null;
  created_at: string;
  nodes: Record<string, unknown>[];
  edges: Record<string, unknown>[];
  workflow_name: string;
}

/**
 * Get execution with workflow data by execution ID
 */
export async function getExecutionWithWorkflow(
  executionId: string
): Promise<WorkflowExecution | null> {
  try {
    const executionQuery = `
      SELECT we.*, w.nodes, w.edges, w.id as workflow_id, w.name as workflow_name
      FROM automation_executions we 
      JOIN automations w ON we.automation_id = w.id 
      WHERE we.id = $1
    `;
    const result = await pool.query(executionQuery, [executionId]);

    if (result.rows.length === 0) {
      return null;
    }

    return result.rows[0];
  } catch (error) {
    console.error("Failed to get execution with workflow:", error);
    throw new Error("Failed to get execution with workflow");
  }
}

/**
 * Update execution status to running
 */
export async function updateExecutionToRunning(
  executionId: string
): Promise<void> {
  try {
    await pool.query(
      "UPDATE automation_executions SET status = $1, started_at = NOW() WHERE id = $2",
      ["running", executionId]
    );
  } catch (error) {
    console.error("Failed to update execution to running:", error);
    throw new Error("Failed to update execution status");
  }
}

/**
 * Update execution status to completed
 */
export async function updateExecutionToCompleted(
  executionId: string
): Promise<void> {
  try {
    await pool.query(
      "UPDATE automation_executions SET status = $1, completed_at = NOW() WHERE id = $2",
      ["completed", executionId]
    );
  } catch (error) {
    console.error("Failed to update execution to completed:", error);
    throw new Error("Failed to update execution status");
  }
}

/**
 * Update execution status to failed
 */
export async function updateExecutionToFailed(
  executionId: string,
  errorMessage: string
): Promise<void> {
  try {
    await pool.query(
      "UPDATE automation_executions SET status = $1, completed_at = NOW(), error_message = $2 WHERE id = $3",
      ["failed", errorMessage, executionId]
    );
  } catch (error) {
    console.error("Failed to update execution to failed:", error);
    throw new Error("Failed to update execution status");
  }
}

/**
 * Create execution step record
 */
export async function createExecutionStep(
  executionId: string,
  nodeId: string
): Promise<string> {
  try {
    const stepResult = await pool.query(
      "INSERT INTO execution_steps (execution_id, node_id, status) VALUES ($1, $2, $3) RETURNING *",
      [executionId, nodeId, "pending"]
    );
    return stepResult.rows[0].id;
  } catch (error) {
    console.error("Failed to create execution step:", error);
    throw new Error("Failed to create execution step");
  }
}

/**
 * Update execution step to running
 */
export async function updateExecutionStepToRunning(
  stepId: string
): Promise<void> {
  try {
    await pool.query(
      "UPDATE execution_steps SET status = $1, started_at = NOW() WHERE id = $2",
      ["running", stepId]
    );
  } catch (error) {
    console.error("Failed to update execution step to running:", error);
    throw new Error("Failed to update execution step");
  }
}

/**
 * Update execution step to completed
 */
export async function updateExecutionStepToCompleted(
  stepId: string,
  result: unknown
): Promise<void> {
  try {
    await pool.query(
      "UPDATE execution_steps SET status = $1, completed_at = NOW(), result = $2 WHERE id = $3",
      ["completed", JSON.stringify(result), stepId]
    );
  } catch (error) {
    console.error("Failed to update execution step to completed:", error);
    throw new Error("Failed to update execution step");
  }
}

/**
 * Update execution step to failed
 */
export async function updateExecutionStepToFailed(
  stepId: string,
  errorMessage: string
): Promise<void> {
  try {
    await pool.query(
      "UPDATE execution_steps SET status = $1, completed_at = NOW(), error_message = $2 WHERE id = $3",
      ["failed", errorMessage, stepId]
    );
  } catch (error) {
    console.error("Failed to update execution step to failed:", error);
    throw new Error("Failed to update execution step");
  }
}

/**
 * Get next pending execution for processing
 */
export async function getNextPendingExecution(): Promise<string | null> {
  try {
    const result = await pool.query(
      "SELECT id FROM automation_executions WHERE status = 'pending' ORDER BY created_at ASC LIMIT 1"
    );

    if (result.rows.length === 0) {
      return null;
    }

    return result.rows[0].id;
  } catch (error) {
    console.error("Failed to get next pending execution:", error);
    throw new Error("Failed to get next pending execution");
  }
}

----- Content End -----

===== File: lib/integrations/utils.ts =====
Type: .ts
----- Content Start -----
// ============================================
// INTEGRATION FACTORY FUNCTION
// ============================================

import type { Integration, IntegrationSchema, SchemaField } from "./types";

export const createIntegration = (
  config: Omit<
    Integration,
    "colorClass" | "borderClass" | "selectedBorderClass"
  >
): Integration => {
  const categoryStyles = getCategoryStyles(config.category);

  return {
    ...config,
    ...categoryStyles,
  };
};

export const createCustomIntegration = (
  config: Omit<Integration, "version"> & { version?: string }
): Integration => {
  const categoryStyles = getCategoryStyles(config.category);

  return {
    version: "1.0.0",
    ...config,
    ...categoryStyles,
  };
};

export const createIntegrationSchema = (
  fields: SchemaField[],
  required: string[] = [],
  dependencies?: Record<string, string[]>
): IntegrationSchema => ({
  fields,
  required,
  dependencies,
});

export const createSchemaField = (config: SchemaField): SchemaField => config;

// ============================================
// CATEGORY-BASED STYLING
// ============================================

export const getCategoryStyles = (category: "trigger" | "action" | "logic") => {
  const styles = {
    trigger: {
      colorClass: "text-amber-600 dark:text-amber-400",
      borderClass:
        "border-amber-200 dark:border-amber-800 hover:border-amber-300 dark:hover:border-amber-700",
      selectedBorderClass:
        "border-amber-600 dark:border-amber-400 shadow-lg ring-1 ring-amber-500/20 dark:ring-amber-400/20",
    },
    action: {
      colorClass: "text-sky-600 dark:text-sky-400",
      borderClass:
        "border-sky-200 dark:border-sky-800 hover:border-sky-300 dark:hover:border-sky-700",
      selectedBorderClass:
        "border-sky-600 dark:border-sky-400 shadow-lg ring-1 ring-sky-500/20 dark:ring-sky-400/20",
    },
    logic: {
      colorClass: "text-violet-600 dark:text-violet-400",
      borderClass:
        "border-violet-200 dark:border-violet-800 hover:border-violet-300 dark:hover:border-violet-700",
      selectedBorderClass:
        "border-violet-600 dark:border-violet-400 shadow-lg ring-1 ring-violet-500/20 dark:ring-violet-400/20",
    },
  };

  return styles[category];
};

// ============================================
// RUNTIME VALIDATION HELPER
// ============================================

export function validateIntegrationOutput(
  integrationId: string,
  result: { success: boolean; data?: Record<string, unknown> }
): boolean {
  if (!result.success) return true; // Don't validate failed executions

  const data = result.data;
  if (!data) return false;

  // Basic validation - ensure timestamp exists
  if (!data.timestamp || typeof data.timestamp !== "string") {
    console.warn(
      `Integration ${integrationId} missing required timestamp field`
    );
    return false;
  }

  return true;
}

----- Content End -----

===== File: lib/integrations/templates.ts =====
Type: .ts
----- Content Start -----
export interface WorkflowTemplate {
  id: string;
  name: string;
  description: string;
  icon: string;
  nodes: Array<{
    id: string;
    type: string;
    position: { x: number; y: number };
    data: {
      label: string;
      subtype: string;
      icon: string;
      description: string;
      config?: Record<string, unknown>;
      colorClass?: string;
      borderClass?: string;
      selectedBorderClass?: string;
    };
  }>;
  edges: Array<{
    id: string;
    source: string;
    target: string;
    sourceHandle?: string;
  }>;
}

export const workflowTemplates: WorkflowTemplate[] = [
  {
    id: "manual-slack-notification",
    name: "Manual â†’ Slack",
    description: "Manually trigger and send Slack notification",
    icon: "play",
    nodes: [
      {
        id: "manual-1",
        type: "trigger",
        position: { x: 100, y: 100 },
        data: {
          label: "Manual Trigger",
          subtype: "manual_trigger",
          icon: "play",
          description: "Trigger workflow manually",
          colorClass: "text-amber-600 dark:text-amber-400",
          borderClass: "border-amber-200 dark:border-amber-800",
          selectedBorderClass: "border-amber-600 dark:border-amber-400",
        },
      },
      {
        id: "slack-1",
        type: "action",
        position: { x: 400, y: 100 },
        data: {
          label: "Send Slack Message",
          subtype: "slack_send_message",
          icon: "message-square",
          description: "Send a message to a Slack channel",
          config: {
            channel: "general",
            message:
              "Manual trigger activated! Workflow executed successfully.",
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },
    ],
    edges: [
      {
        id: "e1",
        source: "manual-1",
        target: "slack-1",
      },
    ],
  },
  {
    id: "schedule-email-reminder",
    name: "Daily Email Reminder",
    description: "Send scheduled email reminders",
    icon: "calendar",
    nodes: [
      {
        id: "schedule-1",
        type: "trigger",
        position: { x: 100, y: 100 },
        data: {
          label: "Schedule",
          subtype: "schedule_trigger",
          icon: "clock",
          description: "Run on a schedule",
          config: {
            schedule: "0 9 * * *", // 9 AM daily
            timezone: "UTC",
          },
          colorClass: "text-amber-600 dark:text-amber-400",
          borderClass: "border-amber-200 dark:border-amber-800",
          selectedBorderClass: "border-amber-600 dark:border-amber-400",
        },
      },
      {
        id: "email-1",
        type: "action",
        position: { x: 400, y: 100 },
        data: {
          label: "Send Email",
          subtype: "email_send",
          icon: "mail",
          description: "Send an email message",
          config: {
            to: "team@company.com",
            subject: "Daily Reminder",
            body: "Don't forget to check your tasks for today!",
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },
    ],
    edges: [
      {
        id: "e1",
        source: "schedule-1",
        target: "email-1",
      },
    ],
  },
  {
    id: "webhook-filter-slack",
    name: "Webhook â†’ Filter â†’ Slack",
    description: "Filter webhook data before sending to Slack",
    icon: "workflow",
    nodes: [
      {
        id: "webhook-1",
        type: "trigger",
        position: { x: 50, y: 100 },
        data: {
          label: "Webhook",
          subtype: "webhook_trigger",
          icon: "link",
          description: "Receive HTTP requests",
          colorClass: "text-amber-600 dark:text-amber-400",
          borderClass: "border-amber-200 dark:border-amber-800",
          selectedBorderClass: "border-amber-600 dark:border-amber-400",
        },
      },
      {
        id: "filter-1",
        type: "logic",
        position: { x: 300, y: 100 },
        data: {
          label: "Filter",
          subtype: "filter_condition",
          icon: "search",
          description: "Filter data conditionally",
          config: {
            field: "{{$node.webhook-1.data.body.status}}",
            operator: "equals",
            value: "active",
          },
          colorClass: "text-violet-600 dark:text-violet-400",
          borderClass: "border-violet-200 dark:border-violet-800",
          selectedBorderClass: "border-violet-600 dark:border-violet-400",
        },
      },
      {
        id: "slack-1",
        type: "action",
        position: { x: 550, y: 100 },
        data: {
          label: "Send Slack Message",
          subtype: "slack_send_message",
          icon: "message-square",
          description: "Send a message to a Slack channel",
          config: {
            channel: "alerts",
            message:
              "Active status detected: {{$node.webhook-1.data.body.message}}",
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },
    ],
    edges: [
      {
        id: "e1",
        source: "webhook-1",
        target: "filter-1",
      },
      {
        id: "e2",
        source: "filter-1",
        target: "slack-1",
      },
    ],
  },
  {
    id: "complex-data-processing",
    name: "Data Processing Pipeline",
    description:
      "Manual trigger â†’ Variable storage â†’ Data transformation â†’ AI processing â†’ Conditional branching â†’ Multiple notifications",
    icon: "workflow",
    nodes: [
      // Manual Trigger
      {
        id: "trigger-1",
        type: "trigger",
        position: { x: 50, y: 200 },
        data: {
          label: "Manual Trigger",
          subtype: "manual_trigger",
          icon: "hand",
          description: "Start the data processing pipeline",
          config: {
            triggerName: "Data Processing Pipeline",
          },
          colorClass: "text-amber-600 dark:text-amber-400",
          borderClass: "border-amber-200 dark:border-amber-800",
          selectedBorderClass: "border-amber-600 dark:border-amber-400",
        },
      },

      // Set Variable - Store initial data
      {
        id: "var-1",
        type: "action",
        position: { x: 300, y: 200 },
        data: {
          label: "Store User Data",
          subtype: "set_variable",
          icon: "database",
          description: "Store user information in variable",
          config: {
            variableName: "userData",
            value: {
              userId: 12345,
              name: "John Doe",
              email: "john.doe@example.com",
              department: "Engineering",
              priority: "high",
            },
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },

      // API Request - Fetch additional data
      {
        id: "api-1",
        type: "action",
        position: { x: 550, y: 200 },
        data: {
          label: "Fetch User Profile",
          subtype: "api_request",
          icon: "globe",
          description: "Get detailed user profile from API",
          config: {
            url: "https://jsonplaceholder.typicode.com/users/1",
            method: "GET",
            headers: '{"Authorization": "Bearer token123"}',
            body: '{"user_id": "{{$vars.userData}}"}',
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },

      // Transform Data - Process the API response
      {
        id: "transform-1",
        type: "logic",
        position: { x: 800, y: 200 },
        data: {
          label: "Process Profile Data",
          subtype: "transform_data",
          icon: "brain",
          description: "Transform and format user profile data",
          config: {
            inputData: "{{$node.api-1.data.response}}",
            transformation: "format_json",
            fieldPath: "email",
          },
          colorClass: "text-violet-600 dark:text-violet-400",
          borderClass: "border-violet-200 dark:border-violet-800",
          selectedBorderClass: "border-violet-600 dark:border-violet-400",
        },
      },

      // Set Variable - Store processed data
      {
        id: "var-2",
        type: "action",
        position: { x: 1050, y: 200 },
        data: {
          label: "Store Processed Data",
          subtype: "set_variable",
          icon: "database",
          description: "Save processed user profile",
          config: {
            variableName: "processedProfile",
            value: "{{$node.transform-1.data.result}}",
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },

      // AI Processing - Generate summary
      {
        id: "ai-1",
        type: "action",
        position: { x: 1300, y: 200 },
        data: {
          label: "Generate AI Summary",
          subtype: "ai",
          icon: "brain",
          description: "Create AI-generated user summary",
          config: {
            ai_mode: "llm",
            model: "gpt-4",
            prompt:
              "Create a professional summary for user: {{$vars.processedProfile}}. Focus on their role and key attributes.",
            max_tokens: 200,
            temperature: 0.7,
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },

      // Branch Condition - Check priority level
      {
        id: "branch-1",
        type: "logic",
        position: { x: 1550, y: 200 },
        data: {
          label: "Check Priority",
          subtype: "branch_condition",
          icon: "diamond",
          description: "Branch based on user priority level",
          config: {
            condition: "{{$vars.userData.priority}} === 'high'",
            trueLabel: "High Priority Path",
            falseLabel: "Standard Priority Path",
          },
          colorClass: "text-violet-600 dark:text-violet-400",
          borderClass: "border-violet-200 dark:border-violet-800",
          selectedBorderClass: "border-violet-600 dark:border-violet-400",
        },
      },

      // High Priority Path - Immediate Slack notification
      {
        id: "slack-high",
        type: "action",
        position: { x: 1400, y: 50 },
        data: {
          label: "Urgent Slack Alert",
          subtype: "slack_send_message",
          icon: "message-square",
          description: "Send urgent notification to Slack",
          config: {
            channel: "urgent-alerts",
            message:
              "ðŸš¨ HIGH PRIORITY USER PROCESSED ðŸš¨\n\nUser: {{$vars.userData.name}}\nDepartment: {{$vars.userData.department}}\n\nAI Summary:\n{{$node.ai-1.data.text}}\n\nProcessed at: {{$node.trigger-1.data.timestamp}}",
            username: "UrgentBot",
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },

      // Standard Priority Path - Regular email
      {
        id: "email-standard",
        type: "action",
        position: { x: 1700, y: 350 },
        data: {
          label: "Standard Email Report",
          subtype: "email_send",
          icon: "mail",
          description: "Send standard email report",
          config: {
            to: "admin@company.com",
            subject: "User Profile Processed - {{$vars.userData.name}}",
            body: "Hello Admin,\n\nA user profile has been processed:\n\nUser Details:\n- Name: {{$vars.userData.name}}\n- Email: {{$vars.userData.email}}\n- Department: {{$vars.userData.department}}\n\nAI Generated Summary:\n{{$node.ai-1.data.text}}\n\nProcessed Data:\n{{$vars.processedProfile}}\n\nBest regards,\nAutomation System",
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },

      // Delay before final notification
      {
        id: "delay-1",
        type: "action",
        position: { x: 1800, y: 200 },
        data: {
          label: "Wait 30 seconds",
          subtype: "delay",
          icon: "clock",
          description: "Brief delay before final notification",
          config: {
            amount: 30,
            unit: "seconds",
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },

      // Final API request - Log completion
      {
        id: "api-final",
        type: "action",
        position: { x: 2050, y: 200 },
        data: {
          label: "Log Completion",
          subtype: "api_request",
          icon: "globe",
          description: "Log pipeline completion to external system",
          config: {
            url: "https://api.example.com/logs",
            method: "POST",
            headers:
              '{"Content-Type": "application/json", "Authorization": "Bearer {{$vars.apiToken}}"}',
            body: JSON.stringify({
              event: "pipeline_completed",
              user_id: "{{$vars.userData.userId}}",
              user_name: "{{$vars.userData.name}}",
              priority: "{{$vars.userData.priority}}",
              ai_summary: "{{$node.ai-1.data.text}}",
              completion_time: "{{$node.delay-1.data.timestamp}}",
              notifications_sent: {
                slack: "{{$node.slack-high.data.messageId}}",
                email: "{{$node.email-standard.data.messageId}}",
              },
            }),
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },
    ],
    edges: [
      // Main flow
      { id: "e1", source: "trigger-1", target: "var-1" },
      { id: "e2", source: "var-1", target: "api-1" },
      { id: "e3", source: "api-1", target: "transform-1" },
      { id: "e4", source: "transform-1", target: "var-2" },
      { id: "e5", source: "var-2", target: "ai-1" },
      { id: "e6", source: "ai-1", target: "branch-1" },

      // Branch paths with conditional handles
      {
        id: "e7",
        source: "branch-1",
        sourceHandle: "true",
        target: "slack-high",
      },
      {
        id: "e8",
        source: "branch-1",
        sourceHandle: "false",
        target: "email-standard",
      },

      // Convergence to delay (both paths lead here)
      { id: "e9", source: "slack-high", target: "delay-1" },
      { id: "e10", source: "email-standard", target: "delay-1" },

      // Final step
      { id: "e11", source: "delay-1", target: "api-final" },
    ],
  },
];

----- Content End -----

===== File: lib/integrations/types.ts =====
Type: .ts
----- Content Start -----
// ============================================
// TYPE DEFINITIONS
// ============================================

export interface WorkflowContext {
  variables: Record<string, unknown>;
  nodeOutputs: Record<string, unknown>;
  executionId: string;
  userId?: string;
}

export interface IntegrationSchema {
  fields: SchemaField[];
  required: string[];
  dependencies?: Record<string, string[]>;
}

export interface SchemaField {
  key: string;
  type: "text" | "textarea" | "select" | "number" | "boolean" | "email" | "url";
  label: string;
  placeholder?: string;
  required?: boolean;
  supportExpressions?: boolean;
  options?:
    | Array<{ label: string; value: string }>
    | (() => Promise<Array<{ label: string; value: string }>>);
  validation?: (value: unknown) => string | null;
  dependsOn?: string;
}

export interface IntegrationExecutor {
  execute: (
    config: Record<string, unknown>,
    context: WorkflowContext
  ) => Promise<ExecutionResult>;
  validate?: (config: Record<string, unknown>) => ValidationResult;
}

export interface ExecutionResult extends Record<string, unknown> {
  success: boolean;
  data?: Record<string, unknown>;
  error?: string;
  metadata?: {
    nodeType: string;
    subtype: string;
    executionTime?: number;
    [key: string]: unknown;
  };
}

export interface ValidationResult {
  valid: boolean;
  errors: Record<string, string>;
}

export interface Integration {
  id: string;
  name: string;
  category: "trigger" | "action" | "logic";
  description: string;
  icon: string;
  version: string;

  // Visual styling (auto-generated based on category)
  colorClass?: string;
  borderClass?: string;
  selectedBorderClass?: string;

  // Integration logic
  schema: IntegrationSchema;
  executor: IntegrationExecutor;

  // Optional features
  auth?: {
    type: "oauth2" | "api_key" | "basic" | "none";
    required: boolean;
  };

  // For triggers only
  hasInputHandle?: boolean;
}

----- Content End -----

===== File: lib/integrations/registry.ts =====
Type: .ts
----- Content Start -----
import type {
  Integration,
  WorkflowContext,
  ExecutionResult,
  ValidationResult,
} from "./types";
import { validateIntegrationOutput } from "./utils";
import { parseExpression } from "../expression";

// Import all integrations
import { manualTrigger } from "./triggers/manual-trigger";
import { webhookTrigger } from "./triggers/webhook-trigger";
import { scheduleTrigger } from "./triggers/schedule-trigger";
import { slackSendMessage } from "./actions/slack-send-message";
import { setVariable } from "./actions/set-variable";
import { emailSend } from "./actions/email-send";
import { apiRequest } from "./actions/api-request";
import { delay } from "./actions/delay";
import { aiIntegration } from "./actions/ai";
import { filterCondition } from "./logic/filter-condition";
import { branchCondition } from "./logic/branch-condition";
import { transformData } from "./logic/transform-data";

// ============================================
// INTEGRATION REGISTRY CLASS
// ============================================

class IntegrationRegistry {
  private integrations = new Map<string, Integration>();

  constructor() {
    // Register all integrations
    this.registerIntegrations([
      // Triggers
      manualTrigger,
      webhookTrigger,
      scheduleTrigger,

      // Actions
      slackSendMessage,
      setVariable,
      emailSend,
      apiRequest,
      delay,
      aiIntegration,

      // Logic
      filterCondition,
      branchCondition,
      transformData,
    ]);
  }

  private registerIntegrations(integrations: Integration[]) {
    integrations.forEach((integration) => {
      this.integrations.set(integration.id, integration);
    });
  }

  register(integration: Integration) {
    this.integrations.set(integration.id, integration);
  }

  unregister(id: string) {
    return this.integrations.delete(id);
  }

  get(id: string): Integration | undefined {
    return this.integrations.get(id);
  }

  getByCategory(category: "trigger" | "action" | "logic"): Integration[] {
    return Array.from(this.integrations.values()).filter(
      (integration) => integration.category === category
    );
  }

  getAll(): Integration[] {
    return Array.from(this.integrations.values());
  }

  getTriggers(): Integration[] {
    return this.getByCategory("trigger");
  }

  getActions(): Integration[] {
    return this.getByCategory("action");
  }

  getLogic(): Integration[] {
    return this.getByCategory("logic");
  }

  // Search integrations by name, description, or category
  search(query: string): Integration[] {
    const lowercaseQuery = query.toLowerCase();
    return Array.from(this.integrations.values()).filter(
      (integration) =>
        integration.name.toLowerCase().includes(lowercaseQuery) ||
        integration.description.toLowerCase().includes(lowercaseQuery) ||
        integration.category.toLowerCase().includes(lowercaseQuery)
    );
  }

  // Get integrations with auth requirements
  getAuthRequired(): Integration[] {
    return Array.from(this.integrations.values()).filter(
      (integration) => integration.auth?.required
    );
  }

  // Get integrations by version
  getByVersion(version: string): Integration[] {
    return Array.from(this.integrations.values()).filter(
      (integration) => integration.version === version
    );
  }

  // Validate integration configuration
  validateConfig(
    integrationId: string,
    config: Record<string, unknown>
  ): ValidationResult {
    const integration = this.get(integrationId);
    if (!integration) {
      return {
        valid: false,
        errors: { integration: "Integration not found" },
      };
    }

    if (integration.executor.validate) {
      return integration.executor.validate(config);
    }

    // Basic validation based on schema
    const errors: Record<string, string> = {};
    integration.schema.required.forEach((field) => {
      if (!config[field]) {
        errors[field] = `${field} is required`;
      }
    });

    // Field-level validation
    integration.schema.fields.forEach((field) => {
      const value = config[field.key];
      if (field.validation && value !== undefined) {
        const validationError = field.validation(value);
        if (validationError) {
          errors[field.key] = validationError;
        }
      }
    });

    return {
      valid: Object.keys(errors).length === 0,
      errors,
    };
  }

  // Execute an integration
  async executeIntegration(
    integrationId: string,
    config: Record<string, unknown>,
    context: WorkflowContext
  ): Promise<ExecutionResult> {
    const integration = this.get(integrationId);
    if (!integration) {
      return {
        success: false,
        error: `Integration '${integrationId}' not found`,
        metadata: {
          nodeType: "unknown",
          subtype: integrationId,
        },
      };
    }

    // ----  NEW: interpolate expressions inside config (repeat until stable) ----
    const hydrate = (value: unknown): unknown => {
      const seen = new Set<string>();
      let out: unknown = value;
      while (typeof out === "string" && !seen.has(out)) {
        seen.add(out);
        // Branch-condition needs strings to be quoted _inside_ the JS expression
        const quote = integration.id === "branch_condition";
        out = parseExpression(out, context, quote);
      }
      if (Array.isArray(out)) return out.map(hydrate);
      if (out && typeof out === "object" && out !== null)
        return Object.fromEntries(
          Object.entries(out as Record<string, unknown>).map(([k, v]) => [
            k,
            hydrate(v),
          ])
        );
      return out;
    };
    const interpolatedConfig = hydrate(config) as Record<string, unknown>;

    try {
      const startTime = Date.now();
      const result = await integration.executor.execute(
        interpolatedConfig,
        context
      );
      const executionTime = Date.now() - startTime;

      // Add execution time to metadata
      if (result.metadata) {
        result.metadata.executionTime = executionTime;
      }

      // Validate output schema
      if (!validateIntegrationOutput(integrationId, result)) {
        console.warn(
          `Integration ${integrationId} returned invalid output schema`
        );
      }

      return result;
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
        metadata: {
          nodeType: integration.category,
          subtype: integrationId,
        },
      };
    }
  }

  // Get integration statistics
  getStats() {
    const integrations = this.getAll();
    return {
      total: integrations.length,
      triggers: this.getTriggers().length,
      actions: this.getActions().length,
      logic: this.getLogic().length,
      withAuth: this.getAuthRequired().length,
    };
  }
}

// Create and export the global registry instance
export const integrationRegistry = new IntegrationRegistry();

// Export the registry class for advanced usage
export { IntegrationRegistry };

----- Content End -----

===== File: lib/integrations/triggers/schedule-trigger.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from '../utils';
import type { Integration } from '../types';

export const scheduleTrigger: Integration = createIntegration({
  id: "schedule_trigger",
  name: "Schedule",
  category: "trigger",
  description: "Run on a schedule",
  icon: "clock",
  version: "1.0.0",

  hasInputHandle: false,

  schema: {
    fields: [
      {
        key: "schedule",
        type: "select",
        label: "Schedule",
        required: true,
        options: [
          { label: "Every minute", value: "* * * * *" },
          { label: "Every hour", value: "0 * * * *" },
          { label: "Every day", value: "0 0 * * *" },
          { label: "Every week", value: "0 0 * * 0" },
        ],
      },
      {
        key: "timezone",
        type: "select",
        label: "Timezone",
        required: false,
        options: [
          { label: "UTC", value: "UTC" },
          { label: "America/New_York", value: "America/New_York" },
          { label: "America/Los_Angeles", value: "America/Los_Angeles" },
        ],
      },
    ],
    required: ["schedule"],
  },

  executor: {
    async execute(config) {
      const timestamp = new Date().toISOString();
      return {
        success: true,
        data: {
          schedule: config.schedule as string,
          timezone: (config.timezone as string) || "UTC",
          timestamp,
        },
        metadata: { nodeType: "trigger", subtype: "schedule_trigger" },
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/triggers/webhook-trigger.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from '../utils';
import type { Integration } from '../types';

export const webhookTrigger: Integration = createIntegration({
  id: "webhook_trigger",
  name: "Webhook",
  category: "trigger",
  description: "Receive HTTP requests",
  icon: "link",
  version: "1.0.0",

  hasInputHandle: false,

  schema: {
    fields: [
      {
        key: "url",
        type: "url",
        label: "Webhook URL",
        placeholder: "https://...",
        required: true,
      },
      {
        key: "method",
        type: "select",
        label: "HTTP Method",
        required: true,
        options: [
          { label: "POST", value: "POST" },
          { label: "GET", value: "GET" },
          { label: "PUT", value: "PUT" },
        ],
      },
    ],
    required: ["url", "method"],
  },

  executor: {
    async execute() {
      const timestamp = new Date().toISOString();
      return {
        success: true,
        data: {
          method: "POST",
          headers: {
            "content-type": "application/json",
            "user-agent": "GitHub-Hookshot/abc123",
          },
          body: {
            event: "push",
            repository: { name: "my-app", owner: "johndoe" },
            commits: [
              { message: "Fix user login bug", author: "Jane Smith" },
            ],
          },
          timestamp,
        },
        metadata: { nodeType: "trigger", subtype: "webhook_trigger" },
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/triggers/manual-trigger.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from '../utils';
import type { Integration } from '../types';

export const manualTrigger: Integration = createIntegration({
  id: "manual_trigger",
  name: "Manual",
  category: "trigger",
  description: "Trigger manually",
  icon: "hand",
  version: "1.0.0",

  hasInputHandle: false,

  schema: {
    fields: [
      {
        key: "triggerName",
        type: "text",
        label: "Trigger Name",
        placeholder: "My Manual Trigger",
        required: false,
      },
    ],
    required: [],
  },

  executor: {
    async execute(config) {
      const timestamp = new Date().toISOString();
      return {
        success: true,
        data: {
          triggered: true,
          timestamp,
          triggerName: (config.triggerName as string) || "Manual Trigger",
        },
        metadata: { nodeType: "trigger", subtype: "manual_trigger" },
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/logic/transform-data.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import { parseExpression } from "../../expression";
import type { Integration, WorkflowContext } from "../types";

export const transformData: Integration = createIntegration({
  id: "transform_data",
  name: "Transform Data",
  category: "logic",
  description: "Transform and format data",
  icon: "brain",
  version: "1.0.0",

  schema: {
    fields: [
      {
        key: "inputData",
        type: "textarea",
        label: "Input Data",
        placeholder: "{{$node.previous-node.data}}",
        required: true,
        supportExpressions: true,
      },
      {
        key: "transformation",
        type: "select",
        label: "Transformation Type",
        required: true,
        options: [
          { label: "Format JSON", value: "format_json" },
          { label: "Extract Field", value: "extract_field" },
          { label: "Convert to String", value: "to_string" },
          { label: "Convert to Number", value: "to_number" },
        ],
      },
      {
        key: "fieldPath",
        type: "text",
        label: "Field Path (for extraction)",
        placeholder: "{{$node.webhook-1.data.user.email}}",
        required: false,
      },
    ],
    required: ["inputData", "transformation"],
  },

  executor: {
    async execute(config, context: WorkflowContext) {
      // Fix 1: Properly interpolate the inputData expression
      const inputData = parseExpression(config.inputData as string, context);
      const transformation = config.transformation as string;
      const timestamp = new Date().toISOString();

      let result;
      switch (transformation) {
        case "format_json":
          result = JSON.stringify(inputData, null, 2);
          break;
        case "extract_field":
          // Fix 2: Also interpolate field path
          const fieldPath = parseExpression(config.fieldPath as string, context);
          result = `Extracted: ${fieldPath}`;
          break;
        case "to_string":
          result = String(inputData);
          break;
        case "to_number":
          result = Number(inputData) || 0;
          break;
        default:
          result = inputData;
      }

      return {
        success: true,
        data: {
          input: inputData,
          transformation,
          result,
          timestamp,
        },
        metadata: { nodeType: "logic", subtype: "transform_data" },
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/logic/filter-condition.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from '../utils';
import type { Integration } from '../types';

export const filterCondition: Integration = createIntegration({
  id: "filter_condition",
  name: "Filter",
  category: "logic",
  description: "Filter data conditionally",
  icon: "search",
  version: "1.0.0",

  schema: {
    fields: [
      {
        key: "field",
        type: "text",
        label: "Field to Check",
        placeholder: "{{$node.webhook-1.data.status}}",
        required: true,
        supportExpressions: true,
      },
      {
        key: "operator",
        type: "select",
        label: "Condition",
        required: true,
        options: [
          { label: "equals", value: "equals" },
          { label: "does not equal", value: "not_equals" },
          { label: "contains", value: "contains" },
          { label: "is greater than", value: "greater_than" },
          { label: "is less than", value: "less_than" },
        ],
      },
      {
        key: "value",
        type: "text",
        label: "Comparison Value",
        placeholder: "active",
        required: true,
        supportExpressions: true,
      },
    ],
    required: ["field", "operator", "value"],
  },

  executor: {
    async execute(config) {
      const sampleValue = "active"; // Simulate checking a status field
      const conditionMet = sampleValue === config.value;
      const timestamp = new Date().toISOString();

      return {
        success: true,
        data: {
          field: config.field as string,
          operator: config.operator as string,
          expectedValue: config.value,
          actualValue: sampleValue,
          conditionMet,
          matchedRecords: conditionMet ? 42 : 0,
          timestamp,
        },
        metadata: { nodeType: "logic", subtype: "filter_condition" },
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/logic/branch-condition.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration, WorkflowContext } from "../types";
import { parseExpression } from "../../expression";

export const branchCondition: Integration = createIntegration({
  id: "branch_condition",
  name: "Branch",
  category: "logic",
  description: "Split workflow into multiple paths",
  icon: "diamond",
  version: "1.0.0",

  schema: {
    fields: [
      {
        key: "condition",
        type: "textarea",
        label: "Condition Expression",
        placeholder: "{{$node.trigger-1.data.status}} === 'active'",
        required: true,
        supportExpressions: true,
      },
      {
        key: "trueLabel",
        type: "text",
        label: "True Path Label",
        placeholder: "If condition is true",
        required: false,
      },
      {
        key: "falseLabel",
        type: "text",
        label: "False Path Label",
        placeholder: "If condition is false",
        required: false,
      },
    ],
    required: ["condition"],
  },

  executor: {
    async execute(config, ctx: WorkflowContext) {
      // The condition should already be interpolated by the registry
      const condition = config.condition as string;

      // Parse the condition to replace variables
      const interpolatedCondition = parseExpression(condition, ctx, true);

      let conditionResult = false;
      try {
        conditionResult = Function(
          `"use strict"; return (${interpolatedCondition});`
        )();
      } catch (error) {
        console.warn("Branch condition evaluation failed:", error);
      }

      const timestamp = new Date().toISOString();

      return {
        success: true,
        data: {
          condition: interpolatedCondition, // Show the actual evaluated condition
          result: conditionResult,
          path: conditionResult ? "true" : "false",
          timestamp,
        },
        metadata: { nodeType: "logic", subtype: "branch_condition" },
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/actions/slack-send-message.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from '../utils';
import type { Integration, ValidationResult } from '../types';

export const slackSendMessage: Integration = createIntegration({
  id: "slack_send_message",
  name: "Send Slack Message",
  category: "action",
  description: "Send a message to a Slack channel",
  icon: "message-square",
  version: "1.0.0",

  auth: {
    type: "oauth2",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "channel",
        type: "select",
        label: "Channel",
        placeholder: "#general",
        required: true,
        options: [
          { label: "#general", value: "general" },
          { label: "#random", value: "random" },
          { label: "#dev", value: "dev" },
        ],
      },
      {
        key: "message",
        type: "textarea",
        label: "Message",
        placeholder:
          "New deployment by {{$node.webhook-1.data.commits.0.author}}",
        required: true,
        supportExpressions: true,
      },
      {
        key: "username",
        type: "text",
        label: "Bot Username",
        placeholder: "WorkflowBot",
        required: false,
      },
    ],
    required: ["channel", "message"],
  },

  executor: {
    async execute(config) {
      await new Promise((resolve) => setTimeout(resolve, 800));
      const timestamp = new Date().toISOString();
      return {
        success: true,
        data: {
          messageId: "1234567890.123456",
          channel: config.channel as string,
          message: config.message as string,
          timestamp,
          user: "U123ABCDEF",
          permalink:
            "https://workspace.slack.com/archives/C123/p1609459200123456",
        },
        metadata: { nodeType: "action", subtype: "slack_send_message" },
      };
    },

    validate(config): ValidationResult {
      const errors: Record<string, string> = {};

      if (!config.channel) errors.channel = "Channel is required";
      if (!config.message) errors.message = "Message is required";

      return {
        valid: Object.keys(errors).length === 0,
        errors,
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/actions/delay.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from '../utils';
import type { Integration } from '../types';

export const delay: Integration = createIntegration({
  id: "delay",
  name: "Delay",
  category: "action",
  description: "Wait for a specified amount of time",
  icon: "clock",
  version: "1.0.0",

  schema: {
    fields: [
      {
        key: "amount",
        type: "number",
        label: "Delay Amount",
        placeholder: "5",
        required: true,
      },
      {
        key: "unit",
        type: "select",
        label: "Time Unit",
        required: true,
        options: [
          { label: "Seconds", value: "seconds" },
          { label: "Minutes", value: "minutes" },
          { label: "Hours", value: "hours" },
        ],
      },
    ],
    required: ["amount", "unit"],
  },

  executor: {
    async execute(config) {
      const amount = Number(config.amount) || 1;
      const unit = config.unit as string;

      let delayMs = amount * 1000; // default to seconds
      if (unit === "minutes") delayMs = amount * 60 * 1000;
      if (unit === "hours") delayMs = amount * 60 * 60 * 1000;

      // For demo purposes, we'll just simulate the delay
      await new Promise((resolve) =>
        setTimeout(resolve, Math.min(delayMs, 2000))
      );

      const timestamp = new Date().toISOString();
      return {
        success: true,
        data: {
          delayAmount: amount,
          delayUnit: unit,
          actualDelayMs: delayMs,
          timestamp,
        },
        metadata: { nodeType: "action", subtype: "delay" },
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/actions/api-request.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from '../utils';
import type { Integration } from '../types';

export const apiRequest: Integration = createIntegration({
  id: "api_request",
  name: "API Request",
  category: "action",
  description: "Make an HTTP API request",
  icon: "globe",
  version: "1.0.0",

  schema: {
    fields: [
      {
        key: "url",
        type: "url",
        label: "API Endpoint",
        placeholder: "https://api.example.com/endpoint",
        required: true,
      },
      {
        key: "method",
        type: "select",
        label: "HTTP Method",
        required: true,
        options: [
          { label: "GET", value: "GET" },
          { label: "POST", value: "POST" },
          { label: "PUT", value: "PUT" },
          { label: "DELETE", value: "DELETE" },
        ],
      },
      {
        key: "headers",
        type: "textarea",
        label: "Headers (JSON)",
        placeholder: '{"Authorization": "Bearer token"}',
        required: false,
      },
      {
        key: "body",
        type: "textarea",
        label: "Request Body (JSON)",
        placeholder:
          '{"user_id": "{{$node.webhook-1.data.user.id}}", "status": "{{$node.webhook-1.data.status}}"}',
        required: false,
        supportExpressions: true,
      },
    ],
    required: ["url", "method"],
  },

  executor: {
    async execute() {
      await new Promise((resolve) => setTimeout(resolve, 600));
      const timestamp = new Date().toISOString();
      return {
        success: true,
        data: {
          status: 200,
          statusText: "OK",
          headers: {
            "content-type": "application/json",
            "x-ratelimit-remaining": "4999",
          },
          response: {
            id: 12345,
            name: "John Doe",
            email: "john@example.com",
            created_at: "2024-12-01T10:30:00Z",
          },
          responseTime: "245ms",
          timestamp,
        },
        metadata: { nodeType: "action", subtype: "api_request" },
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/actions/ai.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const aiIntegration: Integration = createIntegration({
  id: "ai",
  name: "AI",
  category: "action",
  description: "LLM, image generation, text-to-speech, and speech-to-text",
  icon: "brain",
  version: "1.0.0",

  schema: {
    fields: [
      {
        key: "ai_mode",
        type: "select",
        label: "AI Mode",
        required: true,
        options: [
          { label: "Text Generation (LLM)", value: "llm" },
          { label: "Image Generation", value: "image" },
          { label: "Text to Speech", value: "tts" },
          { label: "Speech to Text", value: "stt" },
        ],
      },
      {
        key: "model",
        type: "select",
        label: "AI Model",
        required: true,
        options: [
          { label: "GPT-4", value: "gpt-4" },
          { label: "GPT-3.5 Turbo", value: "gpt-3.5-turbo" },
          { label: "Claude-3 Opus", value: "claude-3-opus" },
          { label: "Claude-3 Sonnet", value: "claude-3-sonnet" },
          { label: "DALL-E 3", value: "dall-e-3" },
          { label: "Midjourney", value: "midjourney" },
          { label: "Stable Diffusion", value: "stable-diffusion" },
          { label: "Whisper", value: "whisper" },
          { label: "ElevenLabs", value: "elevenlabs" },
        ],
      },
      {
        key: "prompt",
        type: "textarea",
        label: "Prompt/Input",
        placeholder:
          "Enter your prompt, text, or describe what you want to generate...",
        required: true,
        supportExpressions: true,
      },
      {
        key: "max_tokens",
        type: "number",
        label: "Max Tokens (LLM only)",
        placeholder: "1000",
        required: false,
      },
      {
        key: "temperature",
        type: "number",
        label: "Temperature/Creativity",
        placeholder: "0.7",
        required: false,
      },
      {
        key: "image_size",
        type: "select",
        label: "Image Size (Image generation only)",
        required: false,
        options: [
          { label: "1024x1024", value: "1024x1024" },
          { label: "1792x1024", value: "1792x1024" },
          { label: "1024x1792", value: "1024x1792" },
        ],
      },
      {
        key: "voice_id",
        type: "select",
        label: "Voice ID (TTS only)",
        required: false,
        options: [
          { label: "Rachel (Female)", value: "rachel" },
          { label: "Domingo (Male)", value: "domingo" },
          { label: "Bella (Female)", value: "bella" },
          { label: "Antoni (Male)", value: "antoni" },
        ],
      },
      {
        key: "language",
        type: "select",
        label: "Language (STT only)",
        required: false,
        options: [
          { label: "English", value: "en" },
          { label: "Spanish", value: "es" },
          { label: "French", value: "fr" },
          { label: "German", value: "de" },
          { label: "Japanese", value: "ja" },
        ],
      },
    ],
    required: ["ai_mode", "model", "prompt"],
  },

  executor: {
    async execute(config: Record<string, unknown>) {
      const {
        ai_mode,
        model,
        prompt,
        max_tokens,
        temperature,
        image_size,
        voice_id,
        language,
      } = config;

      // Simulate API call delay
      await new Promise((resolve) => setTimeout(resolve, 800));

      const timestamp = new Date().toISOString();
      const executionId = `ai_${Date.now()}_${Math.random()
        .toString(36)
        .substr(2, 9)}`;

      // Mock responses based on AI mode
      let response: Record<string, unknown> = {};

      switch (ai_mode) {
        case "llm":
          response = {
            text: `Here's a response to your prompt: "${prompt}"\n\nThis is a mock LLM response generated by ${model}. In a real implementation, this would be the actual AI-generated text based on your prompt. The response would be tailored to your specific request and would demonstrate the AI's understanding and capabilities.`,
            tokens_used: Math.floor(Math.random() * 500) + 100,
            finish_reason: "stop",
            model_used: model,
          };
          break;

        case "image":
          response = {
            image_url: `https://example.com/generated-images/${executionId}.png`,
            image_id: executionId,
            prompt: prompt,
            size: image_size || "1024x1024",
            model_used: model,
            generation_time: "2.3s",
          };
          break;

        case "tts":
          response = {
            audio_url: `https://example.com/generated-audio/${executionId}.mp3`,
            audio_id: executionId,
            text: prompt,
            voice_used: voice_id || "rachel",
            duration: "3.2s",
            sample_rate: "44100Hz",
          };
          break;

        case "stt":
          response = {
            text: "This is a mock transcription of the provided audio. In a real implementation, this would be the actual transcribed text from the audio file.",
            confidence: 0.95,
            language: language || "en",
            duration: "5.1s",
            words: 12,
          };
          break;
      }

      return {
        success: true,
        data: {
          ...response,
          execution_id: executionId,
          timestamp,
          ai_mode,
          model,
          prompt,
          config: {
            max_tokens,
            temperature,
            image_size,
            voice_id,
            language,
          },
        },
        metadata: {
          nodeType: "action",
          subtype: "ai",
          aiMode: ai_mode,
          model: model,
        },
      };
    },

    validate(config: Record<string, unknown>) {
      const errors: Record<string, string> = {};

      if (!config.ai_mode) {
        errors.ai_mode = "AI mode is required";
      }

      if (!config.model) {
        errors.model = "Model is required";
      }

      if (!config.prompt) {
        errors.prompt = "Prompt is required";
      }

      // Validate model compatibility with AI mode
      if (config.ai_mode && config.model) {
        const aiMode = config.ai_mode as string;
        const model = config.model as string;

        const validModels = {
          llm: ["gpt-4", "gpt-3.5-turbo", "claude-3-opus", "claude-3-sonnet"],
          image: ["dall-e-3", "midjourney", "stable-diffusion"],
          tts: ["elevenlabs"],
          stt: ["whisper"],
        };

        if (
          validModels[aiMode as keyof typeof validModels] &&
          !validModels[aiMode as keyof typeof validModels].includes(model)
        ) {
          errors.model = `Model ${model} is not compatible with ${aiMode} mode`;
        }
      }

      return {
        valid: Object.keys(errors).length === 0,
        errors,
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/actions/email-send.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const emailSend: Integration = createIntegration({
  id: "email_send",
  name: "Send Email",
  category: "action",
  description: "Send an email message",
  icon: "mail",
  version: "1.0.0",

  auth: {
    type: "api_key",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "to",
        type: "email",
        label: "To Email",
        placeholder: "user@example.com",
        required: true,
      },
      {
        key: "subject",
        type: "text",
        label: "Subject",
        placeholder: "Email subject",
        required: true,
        supportExpressions: true,
      },
      {
        key: "body",
        type: "textarea",
        label: "Body",
        placeholder:
          "Hello {{$node.webhook-1.data.user.name}}, your order {{$node.webhook-1.data.order.id}} has been shipped!",
        required: true,
        supportExpressions: true,
      },
    ],
    required: ["to", "subject", "body"],
  },

  executor: {
    async execute(config) {
      await new Promise((resolve) => setTimeout(resolve, 1200));
      const timestamp = new Date().toISOString();
      return {
        success: true,
        data: {
          messageId: "<20241201120000.abc123@smtp.gmail.com>",
          to: config.to as string,
          subject: config.subject as string,
          status: "sent",
          deliveryTime: "2.3s",
          provider: "SendGrid",
          timestamp,
        },
        metadata: { nodeType: "action", subtype: "email_send" },
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/actions/set-variable.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration, ValidationResult, WorkflowContext } from "../types";

export const setVariable: Integration = createIntegration({
  id: "set_variable",
  name: "Set Variable",
  category: "action",
  description: "Store data in a variable",
  icon: "database",
  version: "1.0.0",

  schema: {
    fields: [
      {
        key: "variableName",
        type: "text",
        label: "Variable Name",
        placeholder: "myVariable",
        required: true,
        validation: (value: unknown) => {
          if (
            typeof value !== "string" ||
            !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(value)
          ) {
            return "Variable name must start with letter or underscore and contain only letters, numbers, and underscores";
          }
          return null;
        },
      },
      {
        key: "value",
        type: "textarea",
        label: "Value",
        placeholder: "Enter value or reference data...",
        required: true,
        supportExpressions: true,
      },
    ],
    required: ["variableName", "value"],
  },

  executor: {
    async execute(config, context: WorkflowContext) {
      if (config.variableName) {
        let val: unknown = config.value;
        /* If user pasted JSON, keep it as an object so {{$vars.x.y}} works */
        if (typeof val === "string") {
          try {
            val = JSON.parse(val);
          } catch {
            /* ignore */
          }
        }
        context.variables[config.variableName as string] = val;
      }

      const timestamp = new Date().toISOString();
      return {
        success: true,
        data: {
          variableName: config.variableName as string,
          value: config.value,
          timestamp,
        },
        metadata: { nodeType: "action", subtype: "set_variable" },
      };
    },

    validate(config): ValidationResult {
      const errors: Record<string, string> = {};

      if (!config.variableName) {
        errors.variableName = "Variable name is required";
      } else if (
        !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(config.variableName as string)
      ) {
        errors.variableName = "Invalid variable name format";
      }

      if (!config.value) {
        errors.value = "Value is required";
      }

      return {
        valid: Object.keys(errors).length === 0,
        errors,
      };
    },
  },
});

----- Content End -----

