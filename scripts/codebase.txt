===== File: lib/expression.ts =====
Type: .ts
----- Content Start -----
export interface WorkflowContext {
  variables: Record<string, unknown>;
  nodeOutputs: Record<string, unknown>;
}

function getNestedValue(obj: unknown, path: string): unknown {
  return path
    .split(".")
    .reduce(
      (acc, key) =>
        acc && typeof acc === "object" && key in acc
          ? (acc as Record<string, unknown>)[key]
          : undefined,
      obj
    );
}

/**
 * Interpolate {{ ‚Ä¶ }} placeholders.
 *   ‚Ä¢ quoteStrings = false  ‚Üí bare values (for Slack, e-mail, etc.)
 *   ‚Ä¢ quoteStrings = true   ‚Üí strings are JSON-quoted (for eval)
 */
export function parseExpression(
  str: unknown,
  ctx: WorkflowContext,
  quoteStrings = false
): unknown {
  if (typeof str !== "string") return str;

  return str.replace(/\{\{([^}]+)\}\}/g, (match, expr) => {
    const trimmed = expr.trim();

    // Debug logging
    console.log(`üîç Parsing expression: ${trimmed}`);

    // ---------------- $node ----------------
    if (trimmed.startsWith("$node.")) {
      const [, nodeId, ...rest] = trimmed.split(".");
      const nodeOutput = ctx.nodeOutputs[nodeId];
      console.log(`üìä Node ${nodeId} output:`, nodeOutput);

      if (!nodeOutput) {
        console.warn(`‚ö†Ô∏è Node output not found for: ${nodeId}`);
        return match; // Return original if not found
      }

      const value = getNestedValue(nodeOutput, rest.join("."));
      console.log(`‚úÖ Resolved value:`, value);
      return serialise(value, quoteStrings);
    }

    // ---------------- $vars ----------------
    if (trimmed.startsWith("$vars.")) {
      const [, varName, ...rest] = trimmed.split(".");
      const base = ctx.variables[varName];
      console.log(`üìù Variable ${varName}:`, base);

      if (base === undefined) {
        console.warn(`‚ö†Ô∏è Variable not found: ${varName}`);
        return match;
      }

      const value =
        rest.length === 0 ? base : getNestedValue(base, rest.join("."));
      return serialise(value, quoteStrings);
    }

    console.warn(`‚ùå Unknown expression pattern: ${trimmed}`);
    return match; // leave untouched
  });
}

function serialise(v: unknown, quoteStrings: boolean): string {
  if (v === undefined || v === null) return "";
  if (typeof v === "string") {
    // When quoteStrings === true we want a JS string literal
    //   high  ‚Üí  'high'
    //   foo's ‚Üí  'foo\'s'
    return quoteStrings ? `'${String(v).replace(/'/g, "\\'")}'` : v;
  }
  if (typeof v === "number" || typeof v === "boolean") return String(v);
  return JSON.stringify(v); // objects / arrays
}

----- Content End -----

===== File: lib/execution-engine.ts =====
Type: .ts
----- Content Start -----
import {
  getExecutionWithWorkflow,
  updateExecutionToRunning,
  updateExecutionToCompleted,
  updateExecutionToFailed,
  createExecutionStep,
  updateExecutionStepToRunning,
  updateExecutionStepToCompleted,
  updateExecutionStepToFailed,
  getNextPendingExecution,
} from "./db";
import { integrationRegistry } from "./integrations/registry";
import type { WorkflowContext } from "./integrations/types";

interface WorkflowNode {
  id: string;
  type: string;
  data: {
    label: string;
    subtype?: string;
    config?: Record<string, unknown>;
  };
}

interface WorkflowEdge {
  id: string;
  source: string;
  target: string;
  sourceHandle?: string; // Add this to identify which output handle (true/false)
}

export class ExecutionEngine {
  private branchDecisions: Map<string, boolean> = new Map(); // Track branch decisions

  async executeWorkflow(executionId: string) {
    try {
      // Get execution and workflow data
      const execution = await getExecutionWithWorkflow(executionId);
      if (!execution) {
        const error = new Error("Execution not found");
        throw error;
      }

      const nodes: WorkflowNode[] =
        execution.nodes as unknown as WorkflowNode[];
      const edges: WorkflowEdge[] =
        execution.edges as unknown as WorkflowEdge[];

      // Update status to running
      await updateExecutionToRunning(executionId);

      const context: WorkflowContext = {
        variables: {},
        nodeOutputs: {},
        executionId,
      };

      // Reset branch decisions for each execution
      this.branchDecisions.clear();

      // Get execution order (topological sort)
      const executionOrder = this.getExecutionOrder(nodes, edges);

      // Execute nodes in order with conditional path support
      for (const nodeId of executionOrder) {
        const node = nodes.find((n) => n.id === nodeId);
        if (!node) {
          continue;
        }

        // Check if this node should be skipped based on branch conditions
        if (this.shouldSkipNode(nodeId, nodes, edges)) {
          console.log(`Skipping node ${nodeId} due to branch condition`);
          continue;
        }

        await this.executeNode(node, context, executionId);
      }

      // Mark as completed
      await updateExecutionToCompleted(executionId);
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : "Unknown error";

      // Mark as failed
      await updateExecutionToFailed(executionId, errorMessage);
      throw error;
    }
  }

  private shouldSkipNode(
    nodeId: string,
    nodes: WorkflowNode[],
    edges: WorkflowEdge[]
  ): boolean {
    // Find all edges leading to this node
    const incomingEdges = edges.filter((e) => e.target === nodeId);

    for (const edge of incomingEdges) {
      const sourceNode = nodes.find((n) => n.id === edge.source);
      if (!sourceNode) continue;

      // Check if source is a branch node
      if (sourceNode.data.subtype === "branch_condition") {
        const branchResult = this.branchDecisions.get(sourceNode.id);
        if (branchResult === undefined) continue; // Branch not yet executed

        // Check if this edge matches the branch result
        const isTrue =
          edge.sourceHandle === "true" || edge.id.includes("-true-");
        const isFalse =
          edge.sourceHandle === "false" || edge.id.includes("-false-");

        if ((isTrue && !branchResult) || (isFalse && branchResult)) {
          return true; // Skip this node
        }
      }
    }

    return false;
  }

  private async executeNode(
    node: WorkflowNode,
    context: WorkflowContext,
    executionId: string
  ) {
    const nodeId = node.id;

    // Create execution step record
    const stepId = await createExecutionStep(executionId, nodeId);

    // Set to running BEFORE execution
    await updateExecutionStepToRunning(stepId);

    try {
      // Execute the node
      const result = await this.simulateNodeExecution(node, context);

      // Store branch decisions
      if (
        node.data.subtype === "branch_condition" &&
        "data" in result &&
        result.data
      ) {
        const branchData = result.data as Record<string, unknown>;
        if (branchData.result !== undefined) {
          this.branchDecisions.set(node.id, branchData.result as boolean);
        }
      }

      // Store result in context
      context.nodeOutputs[nodeId] = result;

      // Update step as completed
      await updateExecutionStepToCompleted(stepId, result);
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : "Unknown error";

      // Update step as failed
      await updateExecutionStepToFailed(stepId, errorMessage);
      throw error;
    }
  }

  private async simulateNodeExecution(
    node: WorkflowNode,
    context: WorkflowContext
  ) {
    const config = node.data.config || {};
    const integrationId = node.data.subtype;

    if (!integrationId) {
      return {
        success: false,
        error: "No integration subtype specified for node",
        metadata: { nodeType: "unknown" },
      };
    }

    try {
      // Use the integration registry to execute the node
      const result = await integrationRegistry.executeIntegration(
        integrationId,
        config,
        context
      );

      return result;
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
        metadata: { nodeType: integrationId },
      };
    }
  }

  private getExecutionOrder(
    nodes: WorkflowNode[],
    edges: WorkflowEdge[]
  ): string[] {
    const adjacencyList: Record<string, string[]> = {};
    const inDegree: Record<string, number> = {};

    // Initialize
    nodes.forEach((node) => {
      adjacencyList[node.id] = [];
      inDegree[node.id] = 0;
    });

    // Build graph
    edges.forEach((edge) => {
      adjacencyList[edge.source].push(edge.target);
      inDegree[edge.target]++;
    });

    // Topological sort
    const queue: string[] = [];
    const result: string[] = [];

    Object.keys(inDegree).forEach((nodeId) => {
      if (inDegree[nodeId] === 0) {
        queue.push(nodeId);
      }
    });

    while (queue.length > 0) {
      const nodeId = queue.shift()!;
      result.push(nodeId);

      adjacencyList[nodeId].forEach((neighbor) => {
        inDegree[neighbor]--;
        if (inDegree[neighbor] === 0) {
          queue.push(neighbor);
        }
      });
    }

    if (result.length !== nodes.length) {
      throw new Error("Workflow contains cycles");
    }

    return result;
  }
}

export class QueueProcessor {
  private isProcessing = false;
  private engine = new ExecutionEngine();
  private processingCount = 0;

  async start() {
    if (this.isProcessing) return;
    this.isProcessing = true;

    while (this.isProcessing) {
      try {
        await this.processNextExecution();
        await new Promise((resolve) => setTimeout(resolve, 1000)); // Wait 1 second
      } catch (error) {
        console.error("Queue processing error:", error);
        await new Promise((resolve) => setTimeout(resolve, 5000)); // Wait 5 seconds on error
      }
    }
  }

  stop() {
    this.isProcessing = false;
  }

  private async processNextExecution() {
    const executionId = await getNextPendingExecution();

    if (executionId) {
      this.processingCount++;
      await this.engine.executeWorkflow(executionId);
      this.processingCount--;
    }
  }
}

----- Content End -----

===== File: lib/db.ts =====
Type: .ts
----- Content Start -----
import { Pool } from "pg";

if (!process.env.DATABASE_URL) {
  throw new Error("DATABASE_URL environment variable is not set");
}

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: { rejectUnauthorized: false },
  max: 10,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 10000,
});

// Test the connection
pool.on("connect", () => {
  console.log("‚úÖ Connected to PostgreSQL database");
});

pool.on("error", (err) => {
  console.error("‚ùå PostgreSQL connection error:", err);
});

// SQL table creation script
const createTablesSQL = `
CREATE TABLE IF NOT EXISTS automations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  nodes JSONB NOT NULL,
  edges JSONB NOT NULL,
  status VARCHAR(20) DEFAULT 'active',
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS automation_executions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  automation_id UUID REFERENCES automations(id) ON DELETE CASCADE,
  status VARCHAR(20) DEFAULT 'pending',
  started_at TIMESTAMP DEFAULT NOW(),
  completed_at TIMESTAMP,
  context JSONB DEFAULT '{}',
  error_message TEXT,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS execution_steps (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  execution_id UUID REFERENCES automation_executions(id) ON DELETE CASCADE,
  node_id VARCHAR(255) NOT NULL,
  status VARCHAR(20) DEFAULT 'pending',
  result JSONB,
  started_at TIMESTAMP,
  completed_at TIMESTAMP,
  error_message TEXT,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS scheduled_automations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  automation_id UUID REFERENCES automations(id) ON DELETE CASCADE,
  cron_expression VARCHAR(100) NOT NULL,
  timezone VARCHAR(50) DEFAULT 'UTC',
  last_run TIMESTAMP,
  next_run TIMESTAMP NOT NULL,
  active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_automation_executions_automation_id ON automation_executions(automation_id);
CREATE INDEX IF NOT EXISTS idx_automation_executions_status ON automation_executions(status);
CREATE INDEX IF NOT EXISTS idx_execution_steps_execution_id ON execution_steps(execution_id);
CREATE INDEX IF NOT EXISTS idx_scheduled_automations_next_run ON scheduled_automations(next_run, active);
`;

/**
 * Initialize database schema
 * Creates all necessary tables and indexes if they don't exist
 */
export async function initializeDatabase() {
  try {
    await pool.query(createTablesSQL);
    console.log("‚úÖ Database tables created/verified");
    return true;
  } catch (error) {
    console.error("‚ùå Failed to initialize database:", error);
    throw error;
  }
}

// ============================================
// AUTOMATION DATABASE OPERATIONS
// ============================================

export interface Automation {
  id: string;
  name: string;
  nodes: Record<string, unknown>[];
  edges: Record<string, unknown>[];
  status: string;
  created_at: string;
  updated_at: string;
}

/**
 * Get all automations ordered by most recently updated
 */
export async function getAllAutomations(): Promise<Automation[]> {
  try {
    const result = await pool.query(
      "SELECT * FROM automations ORDER BY updated_at DESC"
    );
    return result.rows;
  } catch (error) {
    console.error("Failed to fetch automations:", error);
    throw new Error("Failed to fetch automations");
  }
}

/**
 * Create a new automation
 */
export async function createAutomation(
  name: string,
  nodes: Record<string, unknown>[],
  edges: Record<string, unknown>[]
): Promise<Automation> {
  try {
    const result = await pool.query(
      "INSERT INTO automations (name, nodes, edges) VALUES ($1, $2, $3) RETURNING *",
      [name, JSON.stringify(nodes), JSON.stringify(edges)]
    );
    return result.rows[0];
  } catch (error) {
    console.error("Failed to create automation:", error);
    throw new Error("Failed to create automation");
  }
}

/**
 * Update an existing automation
 */
export async function updateAutomation(
  id: string,
  name: string,
  nodes: Record<string, unknown>[],
  edges: Record<string, unknown>[]
): Promise<Automation> {
  try {
    const result = await pool.query(
      "UPDATE automations SET name = $1, nodes = $2, edges = $3, updated_at = NOW() WHERE id = $4 RETURNING *",
      [name, JSON.stringify(nodes), JSON.stringify(edges), id]
    );

    if (result.rows.length === 0) {
      throw new Error("Automation not found");
    }

    return result.rows[0];
  } catch (error) {
    console.error("Failed to update automation:", error);
    throw error;
  }
}

/**
 * Update automation status
 */
export async function updateAutomationStatus(
  id: string,
  status: string
): Promise<Automation> {
  try {
    const result = await pool.query(
      "UPDATE automations SET status = $1, updated_at = NOW() WHERE id = $2 RETURNING *",
      [status, id]
    );

    if (result.rows.length === 0) {
      throw new Error("Automation not found");
    }

    return result.rows[0];
  } catch (error) {
    console.error("Failed to update automation status:", error);
    throw error;
  }
}

/**
 * Delete an automation
 */
export async function deleteAutomation(id: string): Promise<void> {
  try {
    const result = await pool.query(
      "DELETE FROM automations WHERE id = $1 RETURNING *",
      [id]
    );

    if (result.rows.length === 0) {
      throw new Error("Automation not found");
    }
  } catch (error) {
    console.error("Failed to delete automation:", error);
    throw error;
  }
}

// ============================================
// EXECUTION DATABASE OPERATIONS
// ============================================

export interface ExecutionStep {
  id: string | null;
  node_id: string;
  status: string;
  result: string | number | boolean | object | null;
  started_at: string | null;
  completed_at: string | null;
  error_message: string | null;
}

export interface Execution {
  id: string;
  automation_id: string;
  status: string;
  started_at: string;
  completed_at: string | null;
  context: Record<string, unknown>;
  error_message: string | null;
  created_at: string;
  steps?: ExecutionStep[];
}

/**
 * Create a new execution record
 */
export async function createExecution(
  automationId: string
): Promise<Execution> {
  try {
    const result = await pool.query(
      "INSERT INTO automation_executions (automation_id, status) VALUES ($1, $2) RETURNING *",
      [automationId, "pending"]
    );
    return result.rows[0];
  } catch (error) {
    console.error("Failed to create execution:", error);
    throw new Error("Failed to create execution");
  }
}

/**
 * Get execution with steps by execution ID
 */
export async function getExecutionWithSteps(
  executionId: string
): Promise<Execution | null> {
  try {
    const executionQuery = `
      SELECT 
        we.*,
        json_agg(
          json_build_object(
            'id', es.id,
            'node_id', es.node_id,
            'status', es.status,
            'result', es.result,
            'started_at', es.started_at,
            'completed_at', es.completed_at,
            'error_message', es.error_message
          ) ORDER BY es.created_at
        ) as steps
      FROM automation_executions we
      LEFT JOIN execution_steps es ON we.id = es.execution_id
      WHERE we.id = $1
      GROUP BY we.id
    `;

    const result = await pool.query(executionQuery, [executionId]);

    if (result.rows.length === 0) {
      return null;
    }

    const execution = result.rows[0];

    // Filter out null steps
    const validSteps = execution.steps.filter(
      (step: ExecutionStep) => step.id !== null
    );

    return {
      ...execution,
      steps: validSteps,
    };
  } catch (error) {
    console.error("Failed to get execution with steps:", error);
    throw new Error("Failed to get execution");
  }
}

/**
 * Get latest execution for an automation
 */
export async function getLatestExecution(
  automationId: string
): Promise<Execution | null> {
  try {
    const result = await pool.query(
      `SELECT id, status, started_at, completed_at, created_at 
       FROM automation_executions 
       WHERE automation_id = $1 
       ORDER BY created_at DESC 
       LIMIT 1`,
      [automationId]
    );

    if (result.rows.length === 0) {
      return null;
    }

    return result.rows[0];
  } catch (error) {
    console.error("Failed to get latest execution:", error);
    throw new Error("Failed to get latest execution");
  }
}

export { pool };

// ============================================
// EXECUTION ENGINE DATABASE OPERATIONS
// ============================================

export interface WorkflowExecution {
  id: string;
  workflow_id: string;
  status: string;
  started_at: string | null;
  completed_at: string | null;
  error_message: string | null;
  created_at: string;
  nodes: Record<string, unknown>[];
  edges: Record<string, unknown>[];
  workflow_name: string;
}

/**
 * Get execution with workflow data by execution ID
 */
export async function getExecutionWithWorkflow(
  executionId: string
): Promise<WorkflowExecution | null> {
  try {
    const executionQuery = `
      SELECT we.*, w.nodes, w.edges, w.id as workflow_id, w.name as workflow_name
      FROM automation_executions we 
      JOIN automations w ON we.automation_id = w.id 
      WHERE we.id = $1
    `;
    const result = await pool.query(executionQuery, [executionId]);

    if (result.rows.length === 0) {
      return null;
    }

    return result.rows[0];
  } catch (error) {
    console.error("Failed to get execution with workflow:", error);
    throw new Error("Failed to get execution with workflow");
  }
}

/**
 * Update execution status to running
 */
export async function updateExecutionToRunning(
  executionId: string
): Promise<void> {
  try {
    await pool.query(
      "UPDATE automation_executions SET status = $1, started_at = NOW() WHERE id = $2",
      ["running", executionId]
    );
  } catch (error) {
    console.error("Failed to update execution to running:", error);
    throw new Error("Failed to update execution status");
  }
}

/**
 * Update execution status to completed
 */
export async function updateExecutionToCompleted(
  executionId: string
): Promise<void> {
  try {
    await pool.query(
      "UPDATE automation_executions SET status = $1, completed_at = NOW() WHERE id = $2",
      ["completed", executionId]
    );
  } catch (error) {
    console.error("Failed to update execution to completed:", error);
    throw new Error("Failed to update execution status");
  }
}

/**
 * Update execution status to failed
 */
export async function updateExecutionToFailed(
  executionId: string,
  errorMessage: string
): Promise<void> {
  try {
    await pool.query(
      "UPDATE automation_executions SET status = $1, completed_at = NOW(), error_message = $2 WHERE id = $3",
      ["failed", errorMessage, executionId]
    );
  } catch (error) {
    console.error("Failed to update execution to failed:", error);
    throw new Error("Failed to update execution status");
  }
}

/**
 * Create execution step record
 */
export async function createExecutionStep(
  executionId: string,
  nodeId: string
): Promise<string> {
  try {
    const stepResult = await pool.query(
      "INSERT INTO execution_steps (execution_id, node_id, status) VALUES ($1, $2, $3) RETURNING *",
      [executionId, nodeId, "pending"]
    );
    return stepResult.rows[0].id;
  } catch (error) {
    console.error("Failed to create execution step:", error);
    throw new Error("Failed to create execution step");
  }
}

/**
 * Update execution step to running
 */
export async function updateExecutionStepToRunning(
  stepId: string
): Promise<void> {
  try {
    await pool.query(
      "UPDATE execution_steps SET status = $1, started_at = NOW() WHERE id = $2",
      ["running", stepId]
    );
  } catch (error) {
    console.error("Failed to update execution step to running:", error);
    throw new Error("Failed to update execution step");
  }
}

/**
 * Update execution step to completed
 */
export async function updateExecutionStepToCompleted(
  stepId: string,
  result: unknown
): Promise<void> {
  try {
    await pool.query(
      "UPDATE execution_steps SET status = $1, completed_at = NOW(), result = $2 WHERE id = $3",
      ["completed", JSON.stringify(result), stepId]
    );
  } catch (error) {
    console.error("Failed to update execution step to completed:", error);
    throw new Error("Failed to update execution step");
  }
}

/**
 * Update execution step to failed
 */
export async function updateExecutionStepToFailed(
  stepId: string,
  errorMessage: string
): Promise<void> {
  try {
    await pool.query(
      "UPDATE execution_steps SET status = $1, completed_at = NOW(), error_message = $2 WHERE id = $3",
      ["failed", errorMessage, stepId]
    );
  } catch (error) {
    console.error("Failed to update execution step to failed:", error);
    throw new Error("Failed to update execution step");
  }
}

/**
 * Get next pending execution for processing
 */
export async function getNextPendingExecution(): Promise<string | null> {
  try {
    const result = await pool.query(
      "SELECT id FROM automation_executions WHERE status = 'pending' ORDER BY created_at ASC LIMIT 1"
    );

    if (result.rows.length === 0) {
      return null;
    }

    return result.rows[0].id;
  } catch (error) {
    console.error("Failed to get next pending execution:", error);
    throw new Error("Failed to get next pending execution");
  }
}

----- Content End -----

===== File: lib/integrations/utils.ts =====
Type: .ts
----- Content Start -----
// ============================================
// INTEGRATION FACTORY FUNCTION
// ============================================

import type { Integration, IntegrationSchema, SchemaField } from "./types";

export const createIntegration = (
  config: Omit<
    Integration,
    "colorClass" | "borderClass" | "selectedBorderClass"
  >
): Integration => {
  const categoryStyles = getCategoryStyles(config.category);

  return {
    ...config,
    ...categoryStyles,
  };
};

export const createCustomIntegration = (
  config: Omit<Integration, "version"> & { version?: string }
): Integration => {
  const categoryStyles = getCategoryStyles(config.category);

  return {
    version: "1.0.0",
    ...config,
    ...categoryStyles,
  };
};

export const createIntegrationSchema = (
  fields: SchemaField[],
  required: string[] = [],
  dependencies?: Record<string, string[]>
): IntegrationSchema => ({
  fields,
  required,
  dependencies,
});

export const createSchemaField = (config: SchemaField): SchemaField => config;

// ============================================
// CATEGORY-BASED STYLING
// ============================================

export const getCategoryStyles = (category: "trigger" | "action" | "logic") => {
  const styles = {
    trigger: {
      colorClass: "text-amber-600 dark:text-amber-400",
      borderClass:
        "border-amber-200 dark:border-amber-800 hover:border-amber-300 dark:hover:border-amber-700",
      selectedBorderClass:
        "border-amber-600 dark:border-amber-400 shadow-lg ring-1 ring-amber-500/20 dark:ring-amber-400/20",
    },
    action: {
      colorClass: "text-sky-600 dark:text-sky-400",
      borderClass:
        "border-sky-200 dark:border-sky-800 hover:border-sky-300 dark:hover:border-sky-700",
      selectedBorderClass:
        "border-sky-600 dark:border-sky-400 shadow-lg ring-1 ring-sky-500/20 dark:ring-sky-400/20",
    },
    logic: {
      colorClass: "text-violet-600 dark:text-violet-400",
      borderClass:
        "border-violet-200 dark:border-violet-800 hover:border-violet-300 dark:hover:border-violet-700",
      selectedBorderClass:
        "border-violet-600 dark:border-violet-400 shadow-lg ring-1 ring-violet-500/20 dark:ring-violet-400/20",
    },
  };

  return styles[category];
};

// ============================================
// RUNTIME VALIDATION HELPER
// ============================================

export function validateIntegrationOutput(
  integrationId: string,
  result: { success: boolean; data?: Record<string, unknown> }
): boolean {
  if (!result.success) return true; // Don't validate failed executions

  const data = result.data;
  if (!data) return false;

  // Basic validation - ensure timestamp exists
  if (!data.timestamp || typeof data.timestamp !== "string") {
    console.warn(
      `Integration ${integrationId} missing required timestamp field`
    );
    return false;
  }

  return true;
}

----- Content End -----

===== File: lib/integrations/templates.ts =====
Type: .ts
----- Content Start -----
export interface WorkflowTemplate {
  id: string;
  name: string;
  description: string;
  icon: string;
  nodes: Array<{
    id: string;
    type: string;
    position: { x: number; y: number };
    data: {
      label: string;
      subtype: string;
      icon: string;
      description: string;
      config?: Record<string, unknown>;
      colorClass?: string;
      borderClass?: string;
      selectedBorderClass?: string;
    };
  }>;
  edges: Array<{
    id: string;
    source: string;
    target: string;
    sourceHandle?: string;
  }>;
}

export const workflowTemplates: WorkflowTemplate[] = [
  {
    id: "manual-slack-notification",
    name: "Manual ‚Üí Slack",
    description: "Manually trigger and send Slack notification",
    icon: "play",
    nodes: [
      {
        id: "manual-1",
        type: "trigger",
        position: { x: 100, y: 100 },
        data: {
          label: "Manual Trigger",
          subtype: "manual_trigger",
          icon: "play",
          description: "Trigger workflow manually",
          colorClass: "text-amber-600 dark:text-amber-400",
          borderClass: "border-amber-200 dark:border-amber-800",
          selectedBorderClass: "border-amber-600 dark:border-amber-400",
        },
      },
      {
        id: "slack-1",
        type: "action",
        position: { x: 400, y: 100 },
        data: {
          label: "Send Slack Message",
          subtype: "slack_send_message",
          icon: "message-square",
          description: "Send a message to a Slack channel",
          config: {
            channel: "general",
            message:
              "Manual trigger activated! Workflow executed successfully.",
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },
    ],
    edges: [
      {
        id: "e1",
        source: "manual-1",
        target: "slack-1",
      },
    ],
  },
  {
    id: "schedule-email-reminder",
    name: "Daily Email Reminder",
    description: "Send scheduled email reminders",
    icon: "calendar",
    nodes: [
      {
        id: "schedule-1",
        type: "trigger",
        position: { x: 100, y: 100 },
        data: {
          label: "Schedule",
          subtype: "schedule_trigger",
          icon: "clock",
          description: "Run on a schedule",
          config: {
            schedule: "0 9 * * *", // 9 AM daily
            timezone: "UTC",
          },
          colorClass: "text-amber-600 dark:text-amber-400",
          borderClass: "border-amber-200 dark:border-amber-800",
          selectedBorderClass: "border-amber-600 dark:border-amber-400",
        },
      },
      {
        id: "email-1",
        type: "action",
        position: { x: 400, y: 100 },
        data: {
          label: "Send Email",
          subtype: "email_send",
          icon: "mail",
          description: "Send an email message",
          config: {
            to: "team@company.com",
            subject: "Daily Reminder",
            body: "Don't forget to check your tasks for today!",
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },
    ],
    edges: [
      {
        id: "e1",
        source: "schedule-1",
        target: "email-1",
      },
    ],
  },
  {
    id: "webhook-filter-slack",
    name: "Webhook ‚Üí Filter ‚Üí Slack",
    description: "Filter webhook data before sending to Slack",
    icon: "workflow",
    nodes: [
      {
        id: "webhook-1",
        type: "trigger",
        position: { x: 50, y: 100 },
        data: {
          label: "Webhook",
          subtype: "webhook_trigger",
          icon: "link",
          description: "Receive HTTP requests",
          colorClass: "text-amber-600 dark:text-amber-400",
          borderClass: "border-amber-200 dark:border-amber-800",
          selectedBorderClass: "border-amber-600 dark:border-amber-400",
        },
      },
      {
        id: "filter-1",
        type: "logic",
        position: { x: 300, y: 100 },
        data: {
          label: "Filter",
          subtype: "filter_condition",
          icon: "search",
          description: "Filter data conditionally",
          config: {
            field: "{{$node.webhook-1.data.body.status}}",
            operator: "equals",
            value: "active",
          },
          colorClass: "text-violet-600 dark:text-violet-400",
          borderClass: "border-violet-200 dark:border-violet-800",
          selectedBorderClass: "border-violet-600 dark:border-violet-400",
        },
      },
      {
        id: "slack-1",
        type: "action",
        position: { x: 550, y: 100 },
        data: {
          label: "Send Slack Message",
          subtype: "slack_send_message",
          icon: "message-square",
          description: "Send a message to a Slack channel",
          config: {
            channel: "alerts",
            message:
              "Active status detected: {{$node.webhook-1.data.body.message}}",
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },
    ],
    edges: [
      {
        id: "e1",
        source: "webhook-1",
        target: "filter-1",
      },
      {
        id: "e2",
        source: "filter-1",
        target: "slack-1",
      },
    ],
  },
  {
    id: "complex-data-processing",
    name: "Data Processing Pipeline",
    description:
      "Manual trigger ‚Üí Variable storage ‚Üí Data transformation ‚Üí AI processing ‚Üí Conditional branching ‚Üí Multiple notifications",
    icon: "workflow",
    nodes: [
      // Manual Trigger
      {
        id: "trigger-1",
        type: "trigger",
        position: { x: 50, y: 200 },
        data: {
          label: "Manual Trigger",
          subtype: "manual_trigger",
          icon: "hand",
          description: "Start the data processing pipeline",
          config: {
            triggerName: "Data Processing Pipeline",
          },
          colorClass: "text-amber-600 dark:text-amber-400",
          borderClass: "border-amber-200 dark:border-amber-800",
          selectedBorderClass: "border-amber-600 dark:border-amber-400",
        },
      },

      // Set Variable - Store initial data
      {
        id: "var-1",
        type: "action",
        position: { x: 300, y: 200 },
        data: {
          label: "Store User Data",
          subtype: "set_variable",
          icon: "database",
          description: "Store user information in variable",
          config: {
            variableName: "userData",
            value: {
              userId: 12345,
              name: "John Doe",
              email: "john.doe@example.com",
              department: "Engineering",
              priority: "high",
            },
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },

      // API Request - Fetch additional data
      {
        id: "api-1",
        type: "action",
        position: { x: 550, y: 200 },
        data: {
          label: "Fetch User Profile",
          subtype: "api_request",
          icon: "globe",
          description: "Get detailed user profile from API",
          config: {
            url: "https://jsonplaceholder.typicode.com/users/1",
            method: "GET",
            headers: '{"Authorization": "Bearer token123"}',
            body: '{"user_id": "{{$vars.userData}}"}',
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },

      // Transform Data - Process the API response
      {
        id: "transform-1",
        type: "logic",
        position: { x: 800, y: 200 },
        data: {
          label: "Process Profile Data",
          subtype: "transform_data",
          icon: "brain",
          description: "Transform and format user profile data",
          config: {
            inputData: "{{$node.api-1.data.response}}",
            transformation: "format_json",
            fieldPath: "email",
          },
          colorClass: "text-violet-600 dark:text-violet-400",
          borderClass: "border-violet-200 dark:border-violet-800",
          selectedBorderClass: "border-violet-600 dark:border-violet-400",
        },
      },

      // Set Variable - Store processed data
      {
        id: "var-2",
        type: "action",
        position: { x: 1050, y: 200 },
        data: {
          label: "Store Processed Data",
          subtype: "set_variable",
          icon: "database",
          description: "Save processed user profile",
          config: {
            variableName: "processedProfile",
            value: "{{$node.transform-1.data.result}}",
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },

      // AI Processing - Generate summary
      {
        id: "ai-1",
        type: "action",
        position: { x: 1300, y: 200 },
        data: {
          label: "Generate AI Summary",
          subtype: "ai",
          icon: "brain",
          description: "Create AI-generated user summary",
          config: {
            ai_mode: "llm",
            model: "gpt-4",
            prompt:
              "Create a professional summary for user: {{$vars.processedProfile}}. Focus on their role and key attributes.",
            max_tokens: 200,
            temperature: 0.7,
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },

      // Branch Condition - Check priority level
      {
        id: "branch-1",
        type: "logic",
        position: { x: 1550, y: 200 },
        data: {
          label: "Check Priority",
          subtype: "branch_condition",
          icon: "diamond",
          description: "Branch based on user priority level",
          config: {
            condition: "{{$vars.userData.priority}} === 'high'",
            trueLabel: "High Priority Path",
            falseLabel: "Standard Priority Path",
          },
          colorClass: "text-violet-600 dark:text-violet-400",
          borderClass: "border-violet-200 dark:border-violet-800",
          selectedBorderClass: "border-violet-600 dark:border-violet-400",
        },
      },

      // High Priority Path - Immediate Slack notification
      {
        id: "slack-high",
        type: "action",
        position: { x: 1400, y: 50 },
        data: {
          label: "Urgent Slack Alert",
          subtype: "slack_send_message",
          icon: "message-square",
          description: "Send urgent notification to Slack",
          config: {
            channel: "urgent-alerts",
            message:
              "üö® HIGH PRIORITY USER PROCESSED üö®\n\nUser: {{$vars.userData.name}}\nDepartment: {{$vars.userData.department}}\n\nAI Summary:\n{{$node.ai-1.data.text}}\n\nProcessed at: {{$node.trigger-1.data.timestamp}}",
            username: "UrgentBot",
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },

      // Standard Priority Path - Regular email
      {
        id: "email-standard",
        type: "action",
        position: { x: 1700, y: 350 },
        data: {
          label: "Standard Email Report",
          subtype: "email_send",
          icon: "mail",
          description: "Send standard email report",
          config: {
            to: "admin@company.com",
            subject: "User Profile Processed - {{$vars.userData.name}}",
            body: "Hello Admin,\n\nA user profile has been processed:\n\nUser Details:\n- Name: {{$vars.userData.name}}\n- Email: {{$vars.userData.email}}\n- Department: {{$vars.userData.department}}\n\nAI Generated Summary:\n{{$node.ai-1.data.text}}\n\nProcessed Data:\n{{$vars.processedProfile}}\n\nBest regards,\nAutomation System",
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },

      // Delay before final notification
      {
        id: "delay-1",
        type: "action",
        position: { x: 1800, y: 200 },
        data: {
          label: "Wait 30 seconds",
          subtype: "delay",
          icon: "clock",
          description: "Brief delay before final notification",
          config: {
            amount: 30,
            unit: "seconds",
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },

      // Final API request - Log completion
      {
        id: "api-final",
        type: "action",
        position: { x: 2050, y: 200 },
        data: {
          label: "Log Completion",
          subtype: "api_request",
          icon: "globe",
          description: "Log pipeline completion to external system",
          config: {
            url: "https://api.example.com/logs",
            method: "POST",
            headers:
              '{"Content-Type": "application/json", "Authorization": "Bearer {{$vars.apiToken}}"}',
            body: JSON.stringify({
              event: "pipeline_completed",
              user_id: "{{$vars.userData.userId}}",
              user_name: "{{$vars.userData.name}}",
              priority: "{{$vars.userData.priority}}",
              ai_summary: "{{$node.ai-1.data.text}}",
              completion_time: "{{$node.delay-1.data.timestamp}}",
              notifications_sent: {
                slack: "{{$node.slack-high.data.messageId}}",
                email: "{{$node.email-standard.data.messageId}}",
              },
            }),
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },
    ],
    edges: [
      // Main flow
      { id: "e1", source: "trigger-1", target: "var-1" },
      { id: "e2", source: "var-1", target: "api-1" },
      { id: "e3", source: "api-1", target: "transform-1" },
      { id: "e4", source: "transform-1", target: "var-2" },
      { id: "e5", source: "var-2", target: "ai-1" },
      { id: "e6", source: "ai-1", target: "branch-1" },

      // Branch paths with conditional handles
      {
        id: "e7",
        source: "branch-1",
        sourceHandle: "true",
        target: "slack-high",
      },
      {
        id: "e8",
        source: "branch-1",
        sourceHandle: "false",
        target: "email-standard",
      },

      // Convergence to delay (both paths lead here)
      { id: "e9", source: "slack-high", target: "delay-1" },
      { id: "e10", source: "email-standard", target: "delay-1" },

      // Final step
      { id: "e11", source: "delay-1", target: "api-final" },
    ],
  },
];

----- Content End -----

===== File: lib/integrations/types.ts =====
Type: .ts
----- Content Start -----
// ============================================
// TYPE DEFINITIONS
// ============================================

export interface WorkflowContext {
  variables: Record<string, unknown>;
  nodeOutputs: Record<string, unknown>;
  executionId: string;
  userId?: string;
}

export interface IntegrationSchema {
  fields: SchemaField[];
  required: string[];
  dependencies?: Record<string, string[]>;
}

export interface SchemaField {
  key: string;
  type: "text" | "textarea" | "select" | "number" | "boolean" | "email" | "url";
  label: string;
  placeholder?: string;
  required?: boolean;
  supportExpressions?: boolean;
  options?:
    | Array<{ label: string; value: string }>
    | (() => Promise<Array<{ label: string; value: string }>>);
  validation?: (value: unknown) => string | null;
  dependsOn?: string;
}

export interface IntegrationExecutor {
  execute: (
    config: Record<string, unknown>,
    context: WorkflowContext
  ) => Promise<ExecutionResult>;
  validate?: (config: Record<string, unknown>) => ValidationResult;
}

export interface ExecutionResult extends Record<string, unknown> {
  success: boolean;
  data?: Record<string, unknown>;
  error?: string;
  metadata?: {
    nodeType: string;
    subtype: string;
    executionTime?: number;
    [key: string]: unknown;
  };
}

export interface ValidationResult {
  valid: boolean;
  errors: Record<string, string>;
}

export interface Integration {
  id: string;
  name: string;
  category: "trigger" | "action" | "logic";
  description: string;
  icon: string;
  version: string;

  // Visual styling (auto-generated based on category)
  colorClass?: string;
  borderClass?: string;
  selectedBorderClass?: string;

  // Integration logic
  schema: IntegrationSchema;
  executor: IntegrationExecutor;

  // Optional features
  auth?: {
    type: "oauth2" | "api_key" | "basic" | "none";
    required: boolean;
  };

  // For triggers only
  hasInputHandle?: boolean;
}

----- Content End -----

===== File: lib/integrations/registry.ts =====
Type: .ts
----- Content Start -----
import type {
  Integration,
  WorkflowContext,
  ExecutionResult,
  ValidationResult,
} from "./types";
import { validateIntegrationOutput } from "./utils";
import { parseExpression } from "../expression";

// Import all integrations
import { manualTrigger } from "./triggers/manual-trigger";
import { webhookTrigger } from "./triggers/webhook-trigger";
import { scheduleTrigger } from "./triggers/schedule-trigger";
import { slackSendMessage } from "./actions/slack-send-message";
import { setVariable } from "./actions/set-variable";
import { emailSend } from "./actions/email-send";
import { apiRequest } from "./actions/api-request";
import { delay } from "./actions/delay";
import { aiIntegration } from "./actions/ai";
import { filterCondition } from "./logic/filter-condition";
import { branchCondition } from "./logic/branch-condition";
import { transformData } from "./logic/transform-data";

// ============================================
// INTEGRATION REGISTRY CLASS
// ============================================

class IntegrationRegistry {
  private integrations = new Map<string, Integration>();

  constructor() {
    // Register all integrations
    this.registerIntegrations([
      // Triggers
      manualTrigger,
      webhookTrigger,
      scheduleTrigger,

      // Actions
      slackSendMessage,
      setVariable,
      emailSend,
      apiRequest,
      delay,
      aiIntegration,

      // Logic
      filterCondition,
      branchCondition,
      transformData,
    ]);
  }

  private registerIntegrations(integrations: Integration[]) {
    integrations.forEach((integration) => {
      this.integrations.set(integration.id, integration);
    });
  }

  register(integration: Integration) {
    this.integrations.set(integration.id, integration);
  }

  unregister(id: string) {
    return this.integrations.delete(id);
  }

  get(id: string): Integration | undefined {
    return this.integrations.get(id);
  }

  getByCategory(category: "trigger" | "action" | "logic"): Integration[] {
    return Array.from(this.integrations.values()).filter(
      (integration) => integration.category === category
    );
  }

  getAll(): Integration[] {
    return Array.from(this.integrations.values());
  }

  getTriggers(): Integration[] {
    return this.getByCategory("trigger");
  }

  getActions(): Integration[] {
    return this.getByCategory("action");
  }

  getLogic(): Integration[] {
    return this.getByCategory("logic");
  }

  // Search integrations by name, description, or category
  search(query: string): Integration[] {
    const lowercaseQuery = query.toLowerCase();
    return Array.from(this.integrations.values()).filter(
      (integration) =>
        integration.name.toLowerCase().includes(lowercaseQuery) ||
        integration.description.toLowerCase().includes(lowercaseQuery) ||
        integration.category.toLowerCase().includes(lowercaseQuery)
    );
  }

  // Get integrations with auth requirements
  getAuthRequired(): Integration[] {
    return Array.from(this.integrations.values()).filter(
      (integration) => integration.auth?.required
    );
  }

  // Get integrations by version
  getByVersion(version: string): Integration[] {
    return Array.from(this.integrations.values()).filter(
      (integration) => integration.version === version
    );
  }

  // Validate integration configuration
  validateConfig(
    integrationId: string,
    config: Record<string, unknown>
  ): ValidationResult {
    const integration = this.get(integrationId);
    if (!integration) {
      return {
        valid: false,
        errors: { integration: "Integration not found" },
      };
    }

    if (integration.executor.validate) {
      return integration.executor.validate(config);
    }

    // Basic validation based on schema
    const errors: Record<string, string> = {};
    integration.schema.required.forEach((field) => {
      if (!config[field]) {
        errors[field] = `${field} is required`;
      }
    });

    // Field-level validation
    integration.schema.fields.forEach((field) => {
      const value = config[field.key];
      if (field.validation && value !== undefined) {
        const validationError = field.validation(value);
        if (validationError) {
          errors[field.key] = validationError;
        }
      }
    });

    return {
      valid: Object.keys(errors).length === 0,
      errors,
    };
  }

  // Execute an integration
  async executeIntegration(
    integrationId: string,
    config: Record<string, unknown>,
    context: WorkflowContext
  ): Promise<ExecutionResult> {
    const integration = this.get(integrationId);
    if (!integration) {
      return {
        success: false,
        error: `Integration '${integrationId}' not found`,
        metadata: {
          nodeType: "unknown",
          subtype: integrationId,
        },
      };
    }

    // ----  NEW: interpolate expressions inside config (repeat until stable) ----
    const hydrate = (value: unknown): unknown => {
      const seen = new Set<string>();
      let out: unknown = value;
      while (typeof out === "string" && !seen.has(out)) {
        seen.add(out);
        // Branch-condition needs strings to be quoted _inside_ the JS expression
        const quote = integration.id === "branch_condition";
        out = parseExpression(out, context, quote);
      }
      if (Array.isArray(out)) return out.map(hydrate);
      if (out && typeof out === "object" && out !== null)
        return Object.fromEntries(
          Object.entries(out as Record<string, unknown>).map(([k, v]) => [
            k,
            hydrate(v),
          ])
        );
      return out;
    };
    const interpolatedConfig = hydrate(config) as Record<string, unknown>;

    try {
      const startTime = Date.now();
      const result = await integration.executor.execute(
        interpolatedConfig,
        context
      );
      const executionTime = Date.now() - startTime;

      // Add execution time to metadata
      if (result.metadata) {
        result.metadata.executionTime = executionTime;
      }

      // Validate output schema
      if (!validateIntegrationOutput(integrationId, result)) {
        console.warn(
          `Integration ${integrationId} returned invalid output schema`
        );
      }

      return result;
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
        metadata: {
          nodeType: integration.category,
          subtype: integrationId,
        },
      };
    }
  }

  // Get integration statistics
  getStats() {
    const integrations = this.getAll();
    return {
      total: integrations.length,
      triggers: this.getTriggers().length,
      actions: this.getActions().length,
      logic: this.getLogic().length,
      withAuth: this.getAuthRequired().length,
    };
  }
}

// Create and export the global registry instance
export const integrationRegistry = new IntegrationRegistry();

// Export the registry class for advanced usage
export { IntegrationRegistry };

----- Content End -----

===== File: lib/integrations/triggers/schedule-trigger.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from '../utils';
import type { Integration } from '../types';

export const scheduleTrigger: Integration = createIntegration({
  id: "schedule_trigger",
  name: "Schedule",
  category: "trigger",
  description: "Run on a schedule",
  icon: "clock",
  version: "1.0.0",

  hasInputHandle: false,

  schema: {
    fields: [
      {
        key: "schedule",
        type: "select",
        label: "Schedule",
        required: true,
        options: [
          { label: "Every minute", value: "* * * * *" },
          { label: "Every hour", value: "0 * * * *" },
          { label: "Every day", value: "0 0 * * *" },
          { label: "Every week", value: "0 0 * * 0" },
        ],
      },
      {
        key: "timezone",
        type: "select",
        label: "Timezone",
        required: false,
        options: [
          { label: "UTC", value: "UTC" },
          { label: "America/New_York", value: "America/New_York" },
          { label: "America/Los_Angeles", value: "America/Los_Angeles" },
        ],
      },
    ],
    required: ["schedule"],
  },

  executor: {
    async execute(config) {
      const timestamp = new Date().toISOString();
      return {
        success: true,
        data: {
          schedule: config.schedule as string,
          timezone: (config.timezone as string) || "UTC",
          timestamp,
        },
        metadata: { nodeType: "trigger", subtype: "schedule_trigger" },
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/triggers/webhook-trigger.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from '../utils';
import type { Integration } from '../types';

export const webhookTrigger: Integration = createIntegration({
  id: "webhook_trigger",
  name: "Webhook",
  category: "trigger",
  description: "Receive HTTP requests",
  icon: "link",
  version: "1.0.0",

  hasInputHandle: false,

  schema: {
    fields: [
      {
        key: "url",
        type: "url",
        label: "Webhook URL",
        placeholder: "https://...",
        required: true,
      },
      {
        key: "method",
        type: "select",
        label: "HTTP Method",
        required: true,
        options: [
          { label: "POST", value: "POST" },
          { label: "GET", value: "GET" },
          { label: "PUT", value: "PUT" },
        ],
      },
    ],
    required: ["url", "method"],
  },

  executor: {
    async execute() {
      const timestamp = new Date().toISOString();
      return {
        success: true,
        data: {
          method: "POST",
          headers: {
            "content-type": "application/json",
            "user-agent": "GitHub-Hookshot/abc123",
          },
          body: {
            event: "push",
            repository: { name: "my-app", owner: "johndoe" },
            commits: [
              { message: "Fix user login bug", author: "Jane Smith" },
            ],
          },
          timestamp,
        },
        metadata: { nodeType: "trigger", subtype: "webhook_trigger" },
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/triggers/manual-trigger.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from '../utils';
import type { Integration } from '../types';

export const manualTrigger: Integration = createIntegration({
  id: "manual_trigger",
  name: "Manual",
  category: "trigger",
  description: "Trigger manually",
  icon: "hand",
  version: "1.0.0",

  hasInputHandle: false,

  schema: {
    fields: [
      {
        key: "triggerName",
        type: "text",
        label: "Trigger Name",
        placeholder: "My Manual Trigger",
        required: false,
      },
    ],
    required: [],
  },

  executor: {
    async execute(config) {
      const timestamp = new Date().toISOString();
      return {
        success: true,
        data: {
          triggered: true,
          timestamp,
          triggerName: (config.triggerName as string) || "Manual Trigger",
        },
        metadata: { nodeType: "trigger", subtype: "manual_trigger" },
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/logic/transform-data.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import { parseExpression } from "../../expression";
import type { Integration, WorkflowContext } from "../types";

export const transformData: Integration = createIntegration({
  id: "transform_data",
  name: "Transform Data",
  category: "logic",
  description: "Transform and format data",
  icon: "brain",
  version: "1.0.0",

  schema: {
    fields: [
      {
        key: "inputData",
        type: "textarea",
        label: "Input Data",
        placeholder: "{{$node.previous-node.data}}",
        required: true,
        supportExpressions: true,
      },
      {
        key: "transformation",
        type: "select",
        label: "Transformation Type",
        required: true,
        options: [
          { label: "Format JSON", value: "format_json" },
          { label: "Extract Field", value: "extract_field" },
          { label: "Convert to String", value: "to_string" },
          { label: "Convert to Number", value: "to_number" },
        ],
      },
      {
        key: "fieldPath",
        type: "text",
        label: "Field Path (for extraction)",
        placeholder: "{{$node.webhook-1.data.user.email}}",
        required: false,
      },
    ],
    required: ["inputData", "transformation"],
  },

  executor: {
    async execute(config, context: WorkflowContext) {
      // Fix 1: Properly interpolate the inputData expression
      const inputData = parseExpression(config.inputData as string, context);
      const transformation = config.transformation as string;
      const timestamp = new Date().toISOString();

      let result;
      switch (transformation) {
        case "format_json":
          result = JSON.stringify(inputData, null, 2);
          break;
        case "extract_field":
          // Fix 2: Also interpolate field path
          const fieldPath = parseExpression(config.fieldPath as string, context);
          result = `Extracted: ${fieldPath}`;
          break;
        case "to_string":
          result = String(inputData);
          break;
        case "to_number":
          result = Number(inputData) || 0;
          break;
        default:
          result = inputData;
      }

      return {
        success: true,
        data: {
          input: inputData,
          transformation,
          result,
          timestamp,
        },
        metadata: { nodeType: "logic", subtype: "transform_data" },
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/logic/filter-condition.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from '../utils';
import type { Integration } from '../types';

export const filterCondition: Integration = createIntegration({
  id: "filter_condition",
  name: "Filter",
  category: "logic",
  description: "Filter data conditionally",
  icon: "search",
  version: "1.0.0",

  schema: {
    fields: [
      {
        key: "field",
        type: "text",
        label: "Field to Check",
        placeholder: "{{$node.webhook-1.data.status}}",
        required: true,
        supportExpressions: true,
      },
      {
        key: "operator",
        type: "select",
        label: "Condition",
        required: true,
        options: [
          { label: "equals", value: "equals" },
          { label: "does not equal", value: "not_equals" },
          { label: "contains", value: "contains" },
          { label: "is greater than", value: "greater_than" },
          { label: "is less than", value: "less_than" },
        ],
      },
      {
        key: "value",
        type: "text",
        label: "Comparison Value",
        placeholder: "active",
        required: true,
        supportExpressions: true,
      },
    ],
    required: ["field", "operator", "value"],
  },

  executor: {
    async execute(config) {
      const sampleValue = "active"; // Simulate checking a status field
      const conditionMet = sampleValue === config.value;
      const timestamp = new Date().toISOString();

      return {
        success: true,
        data: {
          field: config.field as string,
          operator: config.operator as string,
          expectedValue: config.value,
          actualValue: sampleValue,
          conditionMet,
          matchedRecords: conditionMet ? 42 : 0,
          timestamp,
        },
        metadata: { nodeType: "logic", subtype: "filter_condition" },
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/logic/branch-condition.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration, WorkflowContext } from "../types";
import { parseExpression } from "../../expression";

export const branchCondition: Integration = createIntegration({
  id: "branch_condition",
  name: "Branch",
  category: "logic",
  description: "Split workflow into multiple paths",
  icon: "diamond",
  version: "1.0.0",

  schema: {
    fields: [
      {
        key: "condition",
        type: "textarea",
        label: "Condition Expression",
        placeholder: "{{$node.trigger-1.data.status}} === 'active'",
        required: true,
        supportExpressions: true,
      },
      {
        key: "trueLabel",
        type: "text",
        label: "True Path Label",
        placeholder: "If condition is true",
        required: false,
      },
      {
        key: "falseLabel",
        type: "text",
        label: "False Path Label",
        placeholder: "If condition is false",
        required: false,
      },
    ],
    required: ["condition"],
  },

  executor: {
    async execute(config, ctx: WorkflowContext) {
      // The condition should already be interpolated by the registry
      const condition = config.condition as string;

      // Parse the condition to replace variables
      const interpolatedCondition = parseExpression(condition, ctx, true);

      let conditionResult = false;
      try {
        conditionResult = Function(
          `"use strict"; return (${interpolatedCondition});`
        )();
      } catch (error) {
        console.warn("Branch condition evaluation failed:", error);
      }

      const timestamp = new Date().toISOString();

      return {
        success: true,
        data: {
          condition: interpolatedCondition, // Show the actual evaluated condition
          result: conditionResult,
          path: conditionResult ? "true" : "false",
          timestamp,
        },
        metadata: { nodeType: "logic", subtype: "branch_condition" },
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/actions/slack-send-message.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from '../utils';
import type { Integration, ValidationResult } from '../types';

export const slackSendMessage: Integration = createIntegration({
  id: "slack_send_message",
  name: "Send Slack Message",
  category: "action",
  description: "Send a message to a Slack channel",
  icon: "message-square",
  version: "1.0.0",

  auth: {
    type: "oauth2",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "channel",
        type: "select",
        label: "Channel",
        placeholder: "#general",
        required: true,
        options: [
          { label: "#general", value: "general" },
          { label: "#random", value: "random" },
          { label: "#dev", value: "dev" },
        ],
      },
      {
        key: "message",
        type: "textarea",
        label: "Message",
        placeholder:
          "New deployment by {{$node.webhook-1.data.commits.0.author}}",
        required: true,
        supportExpressions: true,
      },
      {
        key: "username",
        type: "text",
        label: "Bot Username",
        placeholder: "WorkflowBot",
        required: false,
      },
    ],
    required: ["channel", "message"],
  },

  executor: {
    async execute(config) {
      await new Promise((resolve) => setTimeout(resolve, 800));
      const timestamp = new Date().toISOString();
      return {
        success: true,
        data: {
          messageId: "1234567890.123456",
          channel: config.channel as string,
          message: config.message as string,
          timestamp,
          user: "U123ABCDEF",
          permalink:
            "https://workspace.slack.com/archives/C123/p1609459200123456",
        },
        metadata: { nodeType: "action", subtype: "slack_send_message" },
      };
    },

    validate(config): ValidationResult {
      const errors: Record<string, string> = {};

      if (!config.channel) errors.channel = "Channel is required";
      if (!config.message) errors.message = "Message is required";

      return {
        valid: Object.keys(errors).length === 0,
        errors,
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/actions/delay.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from '../utils';
import type { Integration } from '../types';

export const delay: Integration = createIntegration({
  id: "delay",
  name: "Delay",
  category: "action",
  description: "Wait for a specified amount of time",
  icon: "clock",
  version: "1.0.0",

  schema: {
    fields: [
      {
        key: "amount",
        type: "number",
        label: "Delay Amount",
        placeholder: "5",
        required: true,
      },
      {
        key: "unit",
        type: "select",
        label: "Time Unit",
        required: true,
        options: [
          { label: "Seconds", value: "seconds" },
          { label: "Minutes", value: "minutes" },
          { label: "Hours", value: "hours" },
        ],
      },
    ],
    required: ["amount", "unit"],
  },

  executor: {
    async execute(config) {
      const amount = Number(config.amount) || 1;
      const unit = config.unit as string;

      let delayMs = amount * 1000; // default to seconds
      if (unit === "minutes") delayMs = amount * 60 * 1000;
      if (unit === "hours") delayMs = amount * 60 * 60 * 1000;

      // For demo purposes, we'll just simulate the delay
      await new Promise((resolve) =>
        setTimeout(resolve, Math.min(delayMs, 2000))
      );

      const timestamp = new Date().toISOString();
      return {
        success: true,
        data: {
          delayAmount: amount,
          delayUnit: unit,
          actualDelayMs: delayMs,
          timestamp,
        },
        metadata: { nodeType: "action", subtype: "delay" },
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/actions/api-request.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from '../utils';
import type { Integration } from '../types';

export const apiRequest: Integration = createIntegration({
  id: "api_request",
  name: "API Request",
  category: "action",
  description: "Make an HTTP API request",
  icon: "globe",
  version: "1.0.0",

  schema: {
    fields: [
      {
        key: "url",
        type: "url",
        label: "API Endpoint",
        placeholder: "https://api.example.com/endpoint",
        required: true,
      },
      {
        key: "method",
        type: "select",
        label: "HTTP Method",
        required: true,
        options: [
          { label: "GET", value: "GET" },
          { label: "POST", value: "POST" },
          { label: "PUT", value: "PUT" },
          { label: "DELETE", value: "DELETE" },
        ],
      },
      {
        key: "headers",
        type: "textarea",
        label: "Headers (JSON)",
        placeholder: '{"Authorization": "Bearer token"}',
        required: false,
      },
      {
        key: "body",
        type: "textarea",
        label: "Request Body (JSON)",
        placeholder:
          '{"user_id": "{{$node.webhook-1.data.user.id}}", "status": "{{$node.webhook-1.data.status}}"}',
        required: false,
        supportExpressions: true,
      },
    ],
    required: ["url", "method"],
  },

  executor: {
    async execute() {
      await new Promise((resolve) => setTimeout(resolve, 600));
      const timestamp = new Date().toISOString();
      return {
        success: true,
        data: {
          status: 200,
          statusText: "OK",
          headers: {
            "content-type": "application/json",
            "x-ratelimit-remaining": "4999",
          },
          response: {
            id: 12345,
            name: "John Doe",
            email: "john@example.com",
            created_at: "2024-12-01T10:30:00Z",
          },
          responseTime: "245ms",
          timestamp,
        },
        metadata: { nodeType: "action", subtype: "api_request" },
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/actions/ai.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const aiIntegration: Integration = createIntegration({
  id: "ai",
  name: "AI",
  category: "action",
  description: "LLM, image generation, text-to-speech, and speech-to-text",
  icon: "brain",
  version: "1.0.0",

  schema: {
    fields: [
      {
        key: "ai_mode",
        type: "select",
        label: "AI Mode",
        required: true,
        options: [
          { label: "Text Generation (LLM)", value: "llm" },
          { label: "Image Generation", value: "image" },
          { label: "Text to Speech", value: "tts" },
          { label: "Speech to Text", value: "stt" },
        ],
      },
      {
        key: "model",
        type: "select",
        label: "AI Model",
        required: true,
        options: [
          { label: "GPT-4", value: "gpt-4" },
          { label: "GPT-3.5 Turbo", value: "gpt-3.5-turbo" },
          { label: "Claude-3 Opus", value: "claude-3-opus" },
          { label: "Claude-3 Sonnet", value: "claude-3-sonnet" },
          { label: "DALL-E 3", value: "dall-e-3" },
          { label: "Midjourney", value: "midjourney" },
          { label: "Stable Diffusion", value: "stable-diffusion" },
          { label: "Whisper", value: "whisper" },
          { label: "ElevenLabs", value: "elevenlabs" },
        ],
      },
      {
        key: "prompt",
        type: "textarea",
        label: "Prompt/Input",
        placeholder:
          "Enter your prompt, text, or describe what you want to generate...",
        required: true,
        supportExpressions: true,
      },
      {
        key: "max_tokens",
        type: "number",
        label: "Max Tokens (LLM only)",
        placeholder: "1000",
        required: false,
      },
      {
        key: "temperature",
        type: "number",
        label: "Temperature/Creativity",
        placeholder: "0.7",
        required: false,
      },
      {
        key: "image_size",
        type: "select",
        label: "Image Size (Image generation only)",
        required: false,
        options: [
          { label: "1024x1024", value: "1024x1024" },
          { label: "1792x1024", value: "1792x1024" },
          { label: "1024x1792", value: "1024x1792" },
        ],
      },
      {
        key: "voice_id",
        type: "select",
        label: "Voice ID (TTS only)",
        required: false,
        options: [
          { label: "Rachel (Female)", value: "rachel" },
          { label: "Domingo (Male)", value: "domingo" },
          { label: "Bella (Female)", value: "bella" },
          { label: "Antoni (Male)", value: "antoni" },
        ],
      },
      {
        key: "language",
        type: "select",
        label: "Language (STT only)",
        required: false,
        options: [
          { label: "English", value: "en" },
          { label: "Spanish", value: "es" },
          { label: "French", value: "fr" },
          { label: "German", value: "de" },
          { label: "Japanese", value: "ja" },
        ],
      },
    ],
    required: ["ai_mode", "model", "prompt"],
  },

  executor: {
    async execute(config: Record<string, unknown>) {
      const {
        ai_mode,
        model,
        prompt,
        max_tokens,
        temperature,
        image_size,
        voice_id,
        language,
      } = config;

      // Simulate API call delay
      await new Promise((resolve) => setTimeout(resolve, 800));

      const timestamp = new Date().toISOString();
      const executionId = `ai_${Date.now()}_${Math.random()
        .toString(36)
        .substr(2, 9)}`;

      // Mock responses based on AI mode
      let response: Record<string, unknown> = {};

      switch (ai_mode) {
        case "llm":
          response = {
            text: `Here's a response to your prompt: "${prompt}"\n\nThis is a mock LLM response generated by ${model}. In a real implementation, this would be the actual AI-generated text based on your prompt. The response would be tailored to your specific request and would demonstrate the AI's understanding and capabilities.`,
            tokens_used: Math.floor(Math.random() * 500) + 100,
            finish_reason: "stop",
            model_used: model,
          };
          break;

        case "image":
          response = {
            image_url: `https://example.com/generated-images/${executionId}.png`,
            image_id: executionId,
            prompt: prompt,
            size: image_size || "1024x1024",
            model_used: model,
            generation_time: "2.3s",
          };
          break;

        case "tts":
          response = {
            audio_url: `https://example.com/generated-audio/${executionId}.mp3`,
            audio_id: executionId,
            text: prompt,
            voice_used: voice_id || "rachel",
            duration: "3.2s",
            sample_rate: "44100Hz",
          };
          break;

        case "stt":
          response = {
            text: "This is a mock transcription of the provided audio. In a real implementation, this would be the actual transcribed text from the audio file.",
            confidence: 0.95,
            language: language || "en",
            duration: "5.1s",
            words: 12,
          };
          break;
      }

      return {
        success: true,
        data: {
          ...response,
          execution_id: executionId,
          timestamp,
          ai_mode,
          model,
          prompt,
          config: {
            max_tokens,
            temperature,
            image_size,
            voice_id,
            language,
          },
        },
        metadata: {
          nodeType: "action",
          subtype: "ai",
          aiMode: ai_mode,
          model: model,
        },
      };
    },

    validate(config: Record<string, unknown>) {
      const errors: Record<string, string> = {};

      if (!config.ai_mode) {
        errors.ai_mode = "AI mode is required";
      }

      if (!config.model) {
        errors.model = "Model is required";
      }

      if (!config.prompt) {
        errors.prompt = "Prompt is required";
      }

      // Validate model compatibility with AI mode
      if (config.ai_mode && config.model) {
        const aiMode = config.ai_mode as string;
        const model = config.model as string;

        const validModels = {
          llm: ["gpt-4", "gpt-3.5-turbo", "claude-3-opus", "claude-3-sonnet"],
          image: ["dall-e-3", "midjourney", "stable-diffusion"],
          tts: ["elevenlabs"],
          stt: ["whisper"],
        };

        if (
          validModels[aiMode as keyof typeof validModels] &&
          !validModels[aiMode as keyof typeof validModels].includes(model)
        ) {
          errors.model = `Model ${model} is not compatible with ${aiMode} mode`;
        }
      }

      return {
        valid: Object.keys(errors).length === 0,
        errors,
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/actions/email-send.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const emailSend: Integration = createIntegration({
  id: "email_send",
  name: "Send Email",
  category: "action",
  description: "Send an email message",
  icon: "mail",
  version: "1.0.0",

  auth: {
    type: "api_key",
    required: true,
  },

  schema: {
    fields: [
      {
        key: "to",
        type: "email",
        label: "To Email",
        placeholder: "user@example.com",
        required: true,
      },
      {
        key: "subject",
        type: "text",
        label: "Subject",
        placeholder: "Email subject",
        required: true,
        supportExpressions: true,
      },
      {
        key: "body",
        type: "textarea",
        label: "Body",
        placeholder:
          "Hello {{$node.webhook-1.data.user.name}}, your order {{$node.webhook-1.data.order.id}} has been shipped!",
        required: true,
        supportExpressions: true,
      },
    ],
    required: ["to", "subject", "body"],
  },

  executor: {
    async execute(config) {
      await new Promise((resolve) => setTimeout(resolve, 1200));
      const timestamp = new Date().toISOString();
      return {
        success: true,
        data: {
          messageId: "<20241201120000.abc123@smtp.gmail.com>",
          to: config.to as string,
          subject: config.subject as string,
          status: "sent",
          deliveryTime: "2.3s",
          provider: "SendGrid",
          timestamp,
        },
        metadata: { nodeType: "action", subtype: "email_send" },
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/actions/set-variable.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration, ValidationResult, WorkflowContext } from "../types";

export const setVariable: Integration = createIntegration({
  id: "set_variable",
  name: "Set Variable",
  category: "action",
  description: "Store data in a variable",
  icon: "database",
  version: "1.0.0",

  schema: {
    fields: [
      {
        key: "variableName",
        type: "text",
        label: "Variable Name",
        placeholder: "myVariable",
        required: true,
        validation: (value: unknown) => {
          if (
            typeof value !== "string" ||
            !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(value)
          ) {
            return "Variable name must start with letter or underscore and contain only letters, numbers, and underscores";
          }
          return null;
        },
      },
      {
        key: "value",
        type: "textarea",
        label: "Value",
        placeholder: "Enter value or reference data...",
        required: true,
        supportExpressions: true,
      },
    ],
    required: ["variableName", "value"],
  },

  executor: {
    async execute(config, context: WorkflowContext) {
      if (config.variableName) {
        let val: unknown = config.value;
        /* If user pasted JSON, keep it as an object so {{$vars.x.y}} works */
        if (typeof val === "string") {
          try {
            val = JSON.parse(val);
          } catch {
            /* ignore */
          }
        }
        context.variables[config.variableName as string] = val;
      }

      const timestamp = new Date().toISOString();
      return {
        success: true,
        data: {
          variableName: config.variableName as string,
          value: config.value,
          timestamp,
        },
        metadata: { nodeType: "action", subtype: "set_variable" },
      };
    },

    validate(config): ValidationResult {
      const errors: Record<string, string> = {};

      if (!config.variableName) {
        errors.variableName = "Variable name is required";
      } else if (
        !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(config.variableName as string)
      ) {
        errors.variableName = "Invalid variable name format";
      }

      if (!config.value) {
        errors.value = "Value is required";
      }

      return {
        valid: Object.keys(errors).length === 0,
        errors,
      };
    },
  },
});

----- Content End -----

