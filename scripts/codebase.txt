===== File: lib/expression.ts =====
Type: .ts
----- Content Start -----
export interface WorkflowContext {
  variables: Record<string, unknown>;
  nodeOutputs: Record<string, unknown>;
}

function getNestedValue(obj: unknown, path: string): unknown {
  return path
    .split(".")
    .reduce(
      (acc, key) =>
        acc && typeof acc === "object" && key in acc
          ? (acc as Record<string, unknown>)[key]
          : undefined,
      obj
    );
}

/**
 * Interpolate {{ ‚Ä¶ }} placeholders.
 *   ‚Ä¢ quoteStrings = false  ‚Üí bare values (for Slack, e-mail, etc.)
 *   ‚Ä¢ quoteStrings = true   ‚Üí strings are JSON-quoted (for eval)
 */
export function parseExpression(
  str: unknown,
  ctx: WorkflowContext,
  quoteStrings = false
): unknown {
  if (typeof str !== "string") return str;

  return str.replace(/\{\{([^}]+)\}\}/g, (match, expr) => {
    const trimmed = expr.trim();

    // Debug logging
    console.log(`üîç Parsing expression: ${trimmed}`);

    // ---------------- $node ----------------
    if (trimmed.startsWith("$node.")) {
      const [, nodeId, ...rest] = trimmed.split(".");
      const nodeOutput = ctx.nodeOutputs[nodeId];
      console.log(`üìä Node ${nodeId} output:`, nodeOutput);

      if (!nodeOutput) {
        console.warn(`‚ö†Ô∏è Node output not found for: ${nodeId}`);
        return match; // Return original if not found
      }

      const value = getNestedValue(nodeOutput, rest.join("."));
      console.log(`‚úÖ Resolved value:`, value);
      return serialise(value, quoteStrings);
    }

    // ---------------- $vars ----------------
    if (trimmed.startsWith("$vars.")) {
      const [, varName, ...rest] = trimmed.split(".");
      const base = ctx.variables[varName];
      console.log(`üìù Variable ${varName}:`, base);

      if (base === undefined) {
        console.warn(`‚ö†Ô∏è Variable not found: ${varName}`);
        return match;
      }

      const value =
        rest.length === 0 ? base : getNestedValue(base, rest.join("."));
      return serialise(value, quoteStrings);
    }

    console.warn(`‚ùå Unknown expression pattern: ${trimmed}`);
    return match; // leave untouched
  });
}

function serialise(v: unknown, quoteStrings: boolean): string {
  if (v === undefined || v === null) return "";
  if (typeof v === "string") {
    // When quoteStrings === true we want a JS string literal
    //   high  ‚Üí  'high'
    //   foo's ‚Üí  'foo\'s'
    return quoteStrings ? `'${String(v).replace(/'/g, "\\'")}'` : v;
  }
  if (typeof v === "number" || typeof v === "boolean") return String(v);
  return JSON.stringify(v); // objects / arrays
}

----- Content End -----

===== File: lib/execution-engine.ts =====
Type: .ts
----- Content Start -----
import {
  getExecutionWithWorkflow,
  updateExecutionToRunning,
  updateExecutionToCompleted,
  updateExecutionToFailed,
  createExecutionStep,
  updateExecutionStepToRunning,
  updateExecutionStepToCompleted,
  updateExecutionStepToFailed,
  getNextPendingExecution,
} from "./db";
import { integrationRegistry } from "./integrations/registry";
import type { WorkflowContext } from "./integrations/types";

interface WorkflowNode {
  id: string;
  type: string;
  data: {
    label: string;
    subtype?: string;
    config?: Record<string, unknown>;
  };
}

interface WorkflowEdge {
  id: string;
  source: string;
  target: string;
  sourceHandle?: string; // Add this to identify which output handle (true/false)
}

export class ExecutionEngine {
  private branchDecisions: Map<string, boolean> = new Map(); // Track branch decisions

  async executeWorkflow(executionId: string) {
    try {
      // Get execution and workflow data
      const execution = await getExecutionWithWorkflow(executionId);
      if (!execution) {
        const error = new Error("Execution not found");
        throw error;
      }

      const nodes: WorkflowNode[] =
        execution.nodes as unknown as WorkflowNode[];
      const edges: WorkflowEdge[] =
        execution.edges as unknown as WorkflowEdge[];

      // Update status to running
      await updateExecutionToRunning(executionId);

      const context: WorkflowContext = {
        variables: {},
        nodeOutputs: {},
        executionId,
      };

      // Reset branch decisions for each execution
      this.branchDecisions.clear();

      // Get execution order (topological sort)
      const executionOrder = this.getExecutionOrder(nodes, edges);

      // Execute nodes in order with conditional path support
      for (const nodeId of executionOrder) {
        const node = nodes.find((n) => n.id === nodeId);
        if (!node) {
          continue;
        }

        // Check if this node should be skipped based on branch conditions
        if (this.shouldSkipNode(nodeId, nodes, edges)) {
          console.log(`Skipping node ${nodeId} due to branch condition`);
          continue;
        }

        await this.executeNode(node, context, executionId);
      }

      // Mark as completed
      await updateExecutionToCompleted(executionId);
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : "Unknown error";

      // Mark as failed
      await updateExecutionToFailed(executionId, errorMessage);
      throw error;
    }
  }

  private shouldSkipNode(
    nodeId: string,
    nodes: WorkflowNode[],
    edges: WorkflowEdge[]
  ): boolean {
    // Find all edges leading to this node
    const incomingEdges = edges.filter((e) => e.target === nodeId);

    for (const edge of incomingEdges) {
      const sourceNode = nodes.find((n) => n.id === edge.source);
      if (!sourceNode) continue;

      // Check if source is a branch node
      if (sourceNode.data.subtype === "branch_condition") {
        const branchResult = this.branchDecisions.get(sourceNode.id);
        if (branchResult === undefined) continue; // Branch not yet executed

        // Check if this edge matches the branch result
        const isTrue =
          edge.sourceHandle === "true" || edge.id.includes("-true-");
        const isFalse =
          edge.sourceHandle === "false" || edge.id.includes("-false-");

        if ((isTrue && !branchResult) || (isFalse && branchResult)) {
          return true; // Skip this node
        }
      }
    }

    return false;
  }

  private async executeNode(
    node: WorkflowNode,
    context: WorkflowContext,
    executionId: string
  ) {
    const nodeId = node.id;

    // Create execution step record
    const stepId = await createExecutionStep(executionId, nodeId);

    // Set to running BEFORE execution
    await updateExecutionStepToRunning(stepId);

    try {
      // Execute the node
      const result = await this.simulateNodeExecution(node, context);

      // Store branch decisions
      if (
        node.data.subtype === "branch_condition" &&
        "data" in result &&
        result.data
      ) {
        const branchData = result.data as Record<string, unknown>;
        if (branchData.result !== undefined) {
          this.branchDecisions.set(node.id, branchData.result as boolean);
        }
      }

      // Store result in context
      context.nodeOutputs[nodeId] = result;

      // Update step as completed
      await updateExecutionStepToCompleted(stepId, result);
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : "Unknown error";

      // Update step as failed
      await updateExecutionStepToFailed(stepId, errorMessage);
      throw error;
    }
  }

  private async simulateNodeExecution(
    node: WorkflowNode,
    context: WorkflowContext
  ) {
    const config = node.data.config || {};
    const integrationId = node.data.subtype;

    if (!integrationId) {
      return {
        success: false,
        error: "No integration subtype specified for node",
        metadata: { nodeType: "unknown" },
      };
    }

    try {
      // Use the integration registry to execute the node
      const result = await integrationRegistry.executeIntegration(
        integrationId,
        config,
        context
      );

      return result;
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
        metadata: { nodeType: integrationId },
      };
    }
  }

  private getExecutionOrder(
    nodes: WorkflowNode[],
    edges: WorkflowEdge[]
  ): string[] {
    const adjacencyList: Record<string, string[]> = {};
    const inDegree: Record<string, number> = {};

    // Initialize
    nodes.forEach((node) => {
      adjacencyList[node.id] = [];
      inDegree[node.id] = 0;
    });

    // Build graph
    edges.forEach((edge) => {
      adjacencyList[edge.source].push(edge.target);
      inDegree[edge.target]++;
    });

    // Topological sort
    const queue: string[] = [];
    const result: string[] = [];

    Object.keys(inDegree).forEach((nodeId) => {
      if (inDegree[nodeId] === 0) {
        queue.push(nodeId);
      }
    });

    while (queue.length > 0) {
      const nodeId = queue.shift()!;
      result.push(nodeId);

      adjacencyList[nodeId].forEach((neighbor) => {
        inDegree[neighbor]--;
        if (inDegree[neighbor] === 0) {
          queue.push(neighbor);
        }
      });
    }

    if (result.length !== nodes.length) {
      throw new Error("Workflow contains cycles");
    }

    return result;
  }
}

export class QueueProcessor {
  private isProcessing = false;
  private engine = new ExecutionEngine();
  private processingCount = 0;

  async start() {
    if (this.isProcessing) return;
    this.isProcessing = true;

    while (this.isProcessing) {
      try {
        await this.processNextExecution();
        await new Promise((resolve) => setTimeout(resolve, 1000)); // Wait 1 second
      } catch (error) {
        console.error("Queue processing error:", error);
        await new Promise((resolve) => setTimeout(resolve, 5000)); // Wait 5 seconds on error
      }
    }
  }

  stop() {
    this.isProcessing = false;
  }

  private async processNextExecution() {
    const executionId = await getNextPendingExecution();

    if (executionId) {
      this.processingCount++;
      await this.engine.executeWorkflow(executionId);
      this.processingCount--;
    }
  }
}

----- Content End -----

===== File: lib/db.ts =====
Type: .ts
----- Content Start -----
import { Pool } from "pg";

if (!process.env.DATABASE_URL) {
  throw new Error("DATABASE_URL environment variable is not set");
}

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: { rejectUnauthorized: false },
  max: 10,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 10000,
});

// Test the connection
pool.on("connect", () => {
  console.log("‚úÖ Connected to PostgreSQL database");
});

pool.on("error", (err) => {
  console.error("‚ùå PostgreSQL connection error:", err);
});

// SQL table creation script
const createTablesSQL = `
CREATE TABLE IF NOT EXISTS automations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  nodes JSONB NOT NULL,
  edges JSONB NOT NULL,
  status VARCHAR(20) DEFAULT 'active',
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS automation_executions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  automation_id UUID REFERENCES automations(id) ON DELETE CASCADE,
  status VARCHAR(20) DEFAULT 'pending',
  started_at TIMESTAMP DEFAULT NOW(),
  completed_at TIMESTAMP,
  context JSONB DEFAULT '{}',
  error_message TEXT,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS execution_steps (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  execution_id UUID REFERENCES automation_executions(id) ON DELETE CASCADE,
  node_id VARCHAR(255) NOT NULL,
  status VARCHAR(20) DEFAULT 'pending',
  result JSONB,
  started_at TIMESTAMP,
  completed_at TIMESTAMP,
  error_message TEXT,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS scheduled_automations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  automation_id UUID REFERENCES automations(id) ON DELETE CASCADE,
  cron_expression VARCHAR(100) NOT NULL,
  timezone VARCHAR(50) DEFAULT 'UTC',
  last_run TIMESTAMP,
  next_run TIMESTAMP NOT NULL,
  active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_automation_executions_automation_id ON automation_executions(automation_id);
CREATE INDEX IF NOT EXISTS idx_automation_executions_status ON automation_executions(status);
CREATE INDEX IF NOT EXISTS idx_execution_steps_execution_id ON execution_steps(execution_id);
CREATE INDEX IF NOT EXISTS idx_scheduled_automations_next_run ON scheduled_automations(next_run, active);
`;

/**
 * Initialize database schema
 * Creates all necessary tables and indexes if they don't exist
 */
export async function initializeDatabase() {
  try {
    await pool.query(createTablesSQL);
    console.log("‚úÖ Database tables created/verified");
    return true;
  } catch (error) {
    console.error("‚ùå Failed to initialize database:", error);
    throw error;
  }
}

// ============================================
// AUTOMATION DATABASE OPERATIONS
// ============================================

export interface Automation {
  id: string;
  name: string;
  nodes: Record<string, unknown>[];
  edges: Record<string, unknown>[];
  status: string;
  created_at: string;
  updated_at: string;
}

/**
 * Get all automations ordered by most recently updated
 */
export async function getAllAutomations(): Promise<Automation[]> {
  try {
    const result = await pool.query(
      "SELECT * FROM automations ORDER BY updated_at DESC"
    );
    return result.rows;
  } catch (error) {
    console.error("Failed to fetch automations:", error);
    throw new Error("Failed to fetch automations");
  }
}

/**
 * Create a new automation
 */
export async function createAutomation(
  name: string,
  nodes: Record<string, unknown>[],
  edges: Record<string, unknown>[]
): Promise<Automation> {
  try {
    const result = await pool.query(
      "INSERT INTO automations (name, nodes, edges) VALUES ($1, $2, $3) RETURNING *",
      [name, JSON.stringify(nodes), JSON.stringify(edges)]
    );
    return result.rows[0];
  } catch (error) {
    console.error("Failed to create automation:", error);
    throw new Error("Failed to create automation");
  }
}

/**
 * Update an existing automation
 */
export async function updateAutomation(
  id: string,
  name: string,
  nodes: Record<string, unknown>[],
  edges: Record<string, unknown>[]
): Promise<Automation> {
  try {
    const result = await pool.query(
      "UPDATE automations SET name = $1, nodes = $2, edges = $3, updated_at = NOW() WHERE id = $4 RETURNING *",
      [name, JSON.stringify(nodes), JSON.stringify(edges), id]
    );

    if (result.rows.length === 0) {
      throw new Error("Automation not found");
    }

    return result.rows[0];
  } catch (error) {
    console.error("Failed to update automation:", error);
    throw error;
  }
}

/**
 * Update automation status
 */
export async function updateAutomationStatus(
  id: string,
  status: string
): Promise<Automation> {
  try {
    const result = await pool.query(
      "UPDATE automations SET status = $1, updated_at = NOW() WHERE id = $2 RETURNING *",
      [status, id]
    );

    if (result.rows.length === 0) {
      throw new Error("Automation not found");
    }

    return result.rows[0];
  } catch (error) {
    console.error("Failed to update automation status:", error);
    throw error;
  }
}

/**
 * Delete an automation
 */
export async function deleteAutomation(id: string): Promise<void> {
  try {
    const result = await pool.query(
      "DELETE FROM automations WHERE id = $1 RETURNING *",
      [id]
    );

    if (result.rows.length === 0) {
      throw new Error("Automation not found");
    }
  } catch (error) {
    console.error("Failed to delete automation:", error);
    throw error;
  }
}

// ============================================
// EXECUTION DATABASE OPERATIONS
// ============================================

export interface ExecutionStep {
  id: string | null;
  node_id: string;
  status: string;
  result: string | number | boolean | object | null;
  started_at: string | null;
  completed_at: string | null;
  error_message: string | null;
}

export interface Execution {
  id: string;
  automation_id: string;
  status: string;
  started_at: string;
  completed_at: string | null;
  context: Record<string, unknown>;
  error_message: string | null;
  created_at: string;
  steps?: ExecutionStep[];
}

/**
 * Create a new execution record
 */
export async function createExecution(
  automationId: string
): Promise<Execution> {
  try {
    const result = await pool.query(
      "INSERT INTO automation_executions (automation_id, status) VALUES ($1, $2) RETURNING *",
      [automationId, "pending"]
    );
    return result.rows[0];
  } catch (error) {
    console.error("Failed to create execution:", error);
    throw new Error("Failed to create execution");
  }
}

/**
 * Get execution with steps by execution ID
 */
export async function getExecutionWithSteps(
  executionId: string
): Promise<Execution | null> {
  try {
    const executionQuery = `
      SELECT 
        we.*,
        json_agg(
          json_build_object(
            'id', es.id,
            'node_id', es.node_id,
            'status', es.status,
            'result', es.result,
            'started_at', es.started_at,
            'completed_at', es.completed_at,
            'error_message', es.error_message
          ) ORDER BY es.created_at
        ) as steps
      FROM automation_executions we
      LEFT JOIN execution_steps es ON we.id = es.execution_id
      WHERE we.id = $1
      GROUP BY we.id
    `;

    const result = await pool.query(executionQuery, [executionId]);

    if (result.rows.length === 0) {
      return null;
    }

    const execution = result.rows[0];

    // Filter out null steps
    const validSteps = execution.steps.filter(
      (step: ExecutionStep) => step.id !== null
    );

    return {
      ...execution,
      steps: validSteps,
    };
  } catch (error) {
    console.error("Failed to get execution with steps:", error);
    throw new Error("Failed to get execution");
  }
}

/**
 * Get latest execution for an automation
 */
export async function getLatestExecution(
  automationId: string
): Promise<Execution | null> {
  try {
    const result = await pool.query(
      `SELECT id, status, started_at, completed_at, created_at 
       FROM automation_executions 
       WHERE automation_id = $1 
       ORDER BY created_at DESC 
       LIMIT 1`,
      [automationId]
    );

    if (result.rows.length === 0) {
      return null;
    }

    return result.rows[0];
  } catch (error) {
    console.error("Failed to get latest execution:", error);
    throw new Error("Failed to get latest execution");
  }
}

export { pool };

// ============================================
// EXECUTION ENGINE DATABASE OPERATIONS
// ============================================

export interface WorkflowExecution {
  id: string;
  workflow_id: string;
  status: string;
  started_at: string | null;
  completed_at: string | null;
  error_message: string | null;
  created_at: string;
  nodes: Record<string, unknown>[];
  edges: Record<string, unknown>[];
  workflow_name: string;
}

/**
 * Get execution with workflow data by execution ID
 */
export async function getExecutionWithWorkflow(
  executionId: string
): Promise<WorkflowExecution | null> {
  try {
    const executionQuery = `
      SELECT we.*, w.nodes, w.edges, w.id as workflow_id, w.name as workflow_name
      FROM automation_executions we 
      JOIN automations w ON we.automation_id = w.id 
      WHERE we.id = $1
    `;
    const result = await pool.query(executionQuery, [executionId]);

    if (result.rows.length === 0) {
      return null;
    }

    return result.rows[0];
  } catch (error) {
    console.error("Failed to get execution with workflow:", error);
    throw new Error("Failed to get execution with workflow");
  }
}

/**
 * Update execution status to running
 */
export async function updateExecutionToRunning(
  executionId: string
): Promise<void> {
  try {
    await pool.query(
      "UPDATE automation_executions SET status = $1, started_at = NOW() WHERE id = $2",
      ["running", executionId]
    );
  } catch (error) {
    console.error("Failed to update execution to running:", error);
    throw new Error("Failed to update execution status");
  }
}

/**
 * Update execution status to completed
 */
export async function updateExecutionToCompleted(
  executionId: string
): Promise<void> {
  try {
    await pool.query(
      "UPDATE automation_executions SET status = $1, completed_at = NOW() WHERE id = $2",
      ["completed", executionId]
    );
  } catch (error) {
    console.error("Failed to update execution to completed:", error);
    throw new Error("Failed to update execution status");
  }
}

/**
 * Update execution status to failed
 */
export async function updateExecutionToFailed(
  executionId: string,
  errorMessage: string
): Promise<void> {
  try {
    await pool.query(
      "UPDATE automation_executions SET status = $1, completed_at = NOW(), error_message = $2 WHERE id = $3",
      ["failed", errorMessage, executionId]
    );
  } catch (error) {
    console.error("Failed to update execution to failed:", error);
    throw new Error("Failed to update execution status");
  }
}

/**
 * Create execution step record
 */
export async function createExecutionStep(
  executionId: string,
  nodeId: string
): Promise<string> {
  try {
    const stepResult = await pool.query(
      "INSERT INTO execution_steps (execution_id, node_id, status) VALUES ($1, $2, $3) RETURNING *",
      [executionId, nodeId, "pending"]
    );
    return stepResult.rows[0].id;
  } catch (error) {
    console.error("Failed to create execution step:", error);
    throw new Error("Failed to create execution step");
  }
}

/**
 * Update execution step to running
 */
export async function updateExecutionStepToRunning(
  stepId: string
): Promise<void> {
  try {
    await pool.query(
      "UPDATE execution_steps SET status = $1, started_at = NOW() WHERE id = $2",
      ["running", stepId]
    );
  } catch (error) {
    console.error("Failed to update execution step to running:", error);
    throw new Error("Failed to update execution step");
  }
}

/**
 * Update execution step to completed
 */
export async function updateExecutionStepToCompleted(
  stepId: string,
  result: unknown
): Promise<void> {
  try {
    await pool.query(
      "UPDATE execution_steps SET status = $1, completed_at = NOW(), result = $2 WHERE id = $3",
      ["completed", JSON.stringify(result), stepId]
    );
  } catch (error) {
    console.error("Failed to update execution step to completed:", error);
    throw new Error("Failed to update execution step");
  }
}

/**
 * Update execution step to failed
 */
export async function updateExecutionStepToFailed(
  stepId: string,
  errorMessage: string
): Promise<void> {
  try {
    await pool.query(
      "UPDATE execution_steps SET status = $1, completed_at = NOW(), error_message = $2 WHERE id = $3",
      ["failed", errorMessage, stepId]
    );
  } catch (error) {
    console.error("Failed to update execution step to failed:", error);
    throw new Error("Failed to update execution step");
  }
}

/**
 * Get next pending execution for processing
 */
export async function getNextPendingExecution(): Promise<string | null> {
  try {
    const result = await pool.query(
      "SELECT id FROM automation_executions WHERE status = 'pending' ORDER BY created_at ASC LIMIT 1"
    );

    if (result.rows.length === 0) {
      return null;
    }

    return result.rows[0].id;
  } catch (error) {
    console.error("Failed to get next pending execution:", error);
    throw new Error("Failed to get next pending execution");
  }
}

----- Content End -----

===== File: lib/integrations/utils.ts =====
Type: .ts
----- Content Start -----
// ============================================
// INTEGRATION FACTORY FUNCTION
// ============================================

import type { Integration, IntegrationSchema, SchemaField } from "./types";

export const createIntegration = (
  config: Omit<
    Integration,
    "colorClass" | "borderClass" | "selectedBorderClass"
  >
): Integration => {
  const categoryStyles = getCategoryStyles(config.category);

  return {
    ...config,
    ...categoryStyles,
  };
};

export const createCustomIntegration = (
  config: Omit<Integration, "version"> & { version?: string }
): Integration => {
  const categoryStyles = getCategoryStyles(config.category);

  return {
    version: "1.0.0",
    ...config,
    ...categoryStyles,
  };
};

export const createIntegrationSchema = (
  fields: SchemaField[],
  required: string[] = [],
  dependencies?: Record<string, string[]>
): IntegrationSchema => ({
  fields,
  required,
  dependencies,
});

export const createSchemaField = (config: SchemaField): SchemaField => config;

// ============================================
// CATEGORY-BASED STYLING
// ============================================

export const getCategoryStyles = (category: "trigger" | "action" | "logic") => {
  const styles = {
    trigger: {
      colorClass: "text-amber-600 dark:text-amber-400",
      borderClass:
        "border-amber-200 dark:border-amber-800 hover:border-amber-300 dark:hover:border-amber-700",
      selectedBorderClass:
        "border-amber-600 dark:border-amber-400 shadow-lg ring-1 ring-amber-500/20 dark:ring-amber-400/20",
    },
    action: {
      colorClass: "text-sky-600 dark:text-sky-400",
      borderClass:
        "border-sky-200 dark:border-sky-800 hover:border-sky-300 dark:hover:border-sky-700",
      selectedBorderClass:
        "border-sky-600 dark:border-sky-400 shadow-lg ring-1 ring-sky-500/20 dark:ring-sky-400/20",
    },
    logic: {
      colorClass: "text-violet-600 dark:text-violet-400",
      borderClass:
        "border-violet-200 dark:border-violet-800 hover:border-violet-300 dark:hover:border-violet-700",
      selectedBorderClass:
        "border-violet-600 dark:border-violet-400 shadow-lg ring-1 ring-violet-500/20 dark:ring-violet-400/20",
    },
  };

  return styles[category];
};

// ============================================
// RUNTIME VALIDATION HELPER
// ============================================

export function validateIntegrationOutput(
  integrationId: string,
  result: { success: boolean; data?: Record<string, unknown> }
): boolean {
  if (!result.success) return true; // Don't validate failed executions

  const data = result.data;
  if (!data) return false;

  // Basic validation - ensure timestamp exists
  if (!data.timestamp || typeof data.timestamp !== "string") {
    console.warn(
      `Integration ${integrationId} missing required timestamp field`
    );
    return false;
  }

  return true;
}

----- Content End -----

===== File: lib/integrations/templates.ts =====
Type: .ts
----- Content Start -----
export interface WorkflowTemplate {
  id: string;
  name: string;
  description: string;
  icon: string;
  nodes: Array<{
    id: string;
    type: string;
    position: { x: number; y: number };
    data: {
      label: string;
      subtype: string;
      icon: string;
      description: string;
      config?: Record<string, unknown>;
      colorClass?: string;
      borderClass?: string;
      selectedBorderClass?: string;
    };
  }>;
  edges: Array<{
    id: string;
    source: string;
    target: string;
    sourceHandle?: string;
  }>;
}

export const workflowTemplates: WorkflowTemplate[] = [
  {
    id: "manual-slack-notification",
    name: "Manual ‚Üí Slack",
    description: "Manually trigger and send Slack notification",
    icon: "play",
    nodes: [
      {
        id: "manual-1",
        type: "trigger",
        position: { x: 100, y: 100 },
        data: {
          label: "Manual Trigger",
          subtype: "manual_trigger",
          icon: "play",
          description: "Trigger workflow manually",
          colorClass: "text-amber-600 dark:text-amber-400",
          borderClass: "border-amber-200 dark:border-amber-800",
          selectedBorderClass: "border-amber-600 dark:border-amber-400",
        },
      },
      {
        id: "slack-1",
        type: "action",
        position: { x: 400, y: 100 },
        data: {
          label: "Send Slack Message",
          subtype: "slack_send_message",
          icon: "message-square",
          description: "Send a message to a Slack channel",
          config: {
            channel: "general",
            message:
              "Manual trigger activated! Workflow executed successfully.",
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },
    ],
    edges: [
      {
        id: "e1",
        source: "manual-1",
        target: "slack-1",
      },
    ],
  },
  {
    id: "schedule-email-reminder",
    name: "Daily Email Reminder",
    description: "Send scheduled email reminders",
    icon: "calendar",
    nodes: [
      {
        id: "schedule-1",
        type: "trigger",
        position: { x: 100, y: 100 },
        data: {
          label: "Schedule",
          subtype: "schedule_trigger",
          icon: "clock",
          description: "Run on a schedule",
          config: {
            schedule: "0 9 * * *", // 9 AM daily
            timezone: "UTC",
          },
          colorClass: "text-amber-600 dark:text-amber-400",
          borderClass: "border-amber-200 dark:border-amber-800",
          selectedBorderClass: "border-amber-600 dark:border-amber-400",
        },
      },
      {
        id: "email-1",
        type: "action",
        position: { x: 400, y: 100 },
        data: {
          label: "Send Email",
          subtype: "email_send",
          icon: "mail",
          description: "Send an email message",
          config: {
            to: "team@company.com",
            subject: "Daily Reminder",
            body: "Don't forget to check your tasks for today!",
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },
    ],
    edges: [
      {
        id: "e1",
        source: "schedule-1",
        target: "email-1",
      },
    ],
  },
  {
    id: "webhook-filter-slack",
    name: "Webhook ‚Üí Filter ‚Üí Slack",
    description: "Filter webhook data before sending to Slack",
    icon: "workflow",
    nodes: [
      {
        id: "webhook-1",
        type: "trigger",
        position: { x: 50, y: 100 },
        data: {
          label: "Webhook",
          subtype: "webhook_trigger",
          icon: "link",
          description: "Receive HTTP requests",
          colorClass: "text-amber-600 dark:text-amber-400",
          borderClass: "border-amber-200 dark:border-amber-800",
          selectedBorderClass: "border-amber-600 dark:border-amber-400",
        },
      },
      {
        id: "filter-1",
        type: "logic",
        position: { x: 300, y: 100 },
        data: {
          label: "Filter",
          subtype: "filter_condition",
          icon: "search",
          description: "Filter data conditionally",
          config: {
            field: "{{$node.webhook-1.data.body.status}}",
            operator: "equals",
            value: "active",
          },
          colorClass: "text-violet-600 dark:text-violet-400",
          borderClass: "border-violet-200 dark:border-violet-800",
          selectedBorderClass: "border-violet-600 dark:border-violet-400",
        },
      },
      {
        id: "slack-1",
        type: "action",
        position: { x: 550, y: 100 },
        data: {
          label: "Send Slack Message",
          subtype: "slack_send_message",
          icon: "message-square",
          description: "Send a message to a Slack channel",
          config: {
            channel: "alerts",
            message:
              "Active status detected: {{$node.webhook-1.data.body.message}}",
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },
    ],
    edges: [
      {
        id: "e1",
        source: "webhook-1",
        target: "filter-1",
      },
      {
        id: "e2",
        source: "filter-1",
        target: "slack-1",
      },
    ],
  },
  {
    id: "complex-data-processing",
    name: "Data Processing Pipeline",
    description:
      "Manual trigger ‚Üí Variable storage ‚Üí Data transformation ‚Üí AI processing ‚Üí Conditional branching ‚Üí Multiple notifications",
    icon: "workflow",
    nodes: [
      // Manual Trigger
      {
        id: "trigger-1",
        type: "trigger",
        position: { x: 50, y: 200 },
        data: {
          label: "Manual Trigger",
          subtype: "manual_trigger",
          icon: "hand",
          description: "Start the data processing pipeline",
          config: {
            triggerName: "Data Processing Pipeline",
          },
          colorClass: "text-amber-600 dark:text-amber-400",
          borderClass: "border-amber-200 dark:border-amber-800",
          selectedBorderClass: "border-amber-600 dark:border-amber-400",
        },
      },

      // Set Variable - Store initial data
      {
        id: "var-1",
        type: "action",
        position: { x: 300, y: 200 },
        data: {
          label: "Store User Data",
          subtype: "set_variable",
          icon: "database",
          description: "Store user information in variable",
          config: {
            variableName: "userData",
            value: {
              userId: 12345,
              name: "John Doe",
              email: "john.doe@example.com",
              department: "Engineering",
              priority: "high",
            },
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },

      // API Request - Fetch additional data
      {
        id: "api-1",
        type: "action",
        position: { x: 550, y: 200 },
        data: {
          label: "Fetch User Profile",
          subtype: "api_request",
          icon: "globe",
          description: "Get detailed user profile from API",
          config: {
            url: "https://jsonplaceholder.typicode.com/users/1",
            method: "GET",
            headers: '{"Authorization": "Bearer token123"}',
            body: '{"user_id": "{{$vars.userData}}"}',
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },

      // Transform Data - Process the API response
      {
        id: "transform-1",
        type: "logic",
        position: { x: 800, y: 200 },
        data: {
          label: "Process Profile Data",
          subtype: "transform_data",
          icon: "brain",
          description: "Transform and format user profile data",
          config: {
            inputData: "{{$node.api-1.data.response}}",
            transformation: "format_json",
            fieldPath: "email",
          },
          colorClass: "text-violet-600 dark:text-violet-400",
          borderClass: "border-violet-200 dark:border-violet-800",
          selectedBorderClass: "border-violet-600 dark:border-violet-400",
        },
      },

      // Set Variable - Store processed data
      {
        id: "var-2",
        type: "action",
        position: { x: 1050, y: 200 },
        data: {
          label: "Store Processed Data",
          subtype: "set_variable",
          icon: "database",
          description: "Save processed user profile",
          config: {
            variableName: "processedProfile",
            value: "{{$node.transform-1.data.result}}",
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },

      // AI Processing - Generate summary
      {
        id: "ai-1",
        type: "action",
        position: { x: 1300, y: 200 },
        data: {
          label: "Generate AI Summary",
          subtype: "ai",
          icon: "brain",
          description: "Create AI-generated user summary",
          config: {
            ai_mode: "llm",
            model: "gpt-4",
            prompt:
              "Create a professional summary for user: {{$vars.processedProfile}}. Focus on their role and key attributes.",
            max_tokens: 200,
            temperature: 0.7,
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },

      // Branch Condition - Check priority level
      {
        id: "branch-1",
        type: "logic",
        position: { x: 1550, y: 200 },
        data: {
          label: "Check Priority",
          subtype: "branch_condition",
          icon: "diamond",
          description: "Branch based on user priority level",
          config: {
            condition: "{{$vars.userData.priority}} === 'high'",
            trueLabel: "High Priority Path",
            falseLabel: "Standard Priority Path",
          },
          colorClass: "text-violet-600 dark:text-violet-400",
          borderClass: "border-violet-200 dark:border-violet-800",
          selectedBorderClass: "border-violet-600 dark:border-violet-400",
        },
      },

      // High Priority Path - Immediate Slack notification
      {
        id: "slack-high",
        type: "action",
        position: { x: 1400, y: 50 },
        data: {
          label: "Urgent Slack Alert",
          subtype: "slack_send_message",
          icon: "message-square",
          description: "Send urgent notification to Slack",
          config: {
            channel: "urgent-alerts",
            message:
              "üö® HIGH PRIORITY USER PROCESSED üö®\n\nUser: {{$vars.userData.name}}\nDepartment: {{$vars.userData.department}}\n\nAI Summary:\n{{$node.ai-1.data.text}}\n\nProcessed at: {{$node.trigger-1.data.timestamp}}",
            username: "UrgentBot",
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },

      // Standard Priority Path - Regular email
      {
        id: "email-standard",
        type: "action",
        position: { x: 1700, y: 350 },
        data: {
          label: "Standard Email Report",
          subtype: "email_send",
          icon: "mail",
          description: "Send standard email report",
          config: {
            to: "admin@company.com",
            subject: "User Profile Processed - {{$vars.userData.name}}",
            body: "Hello Admin,\n\nA user profile has been processed:\n\nUser Details:\n- Name: {{$vars.userData.name}}\n- Email: {{$vars.userData.email}}\n- Department: {{$vars.userData.department}}\n\nAI Generated Summary:\n{{$node.ai-1.data.text}}\n\nProcessed Data:\n{{$vars.processedProfile}}\n\nBest regards,\nAutomation System",
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },

      // Delay before final notification
      {
        id: "delay-1",
        type: "action",
        position: { x: 1800, y: 200 },
        data: {
          label: "Wait 30 seconds",
          subtype: "delay",
          icon: "clock",
          description: "Brief delay before final notification",
          config: {
            amount: 30,
            unit: "seconds",
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },

      // Final API request - Log completion
      {
        id: "api-final",
        type: "action",
        position: { x: 2050, y: 200 },
        data: {
          label: "Log Completion",
          subtype: "api_request",
          icon: "globe",
          description: "Log pipeline completion to external system",
          config: {
            url: "https://api.example.com/logs",
            method: "POST",
            headers:
              '{"Content-Type": "application/json", "Authorization": "Bearer {{$vars.apiToken}}"}',
            body: JSON.stringify({
              event: "pipeline_completed",
              user_id: "{{$vars.userData.userId}}",
              user_name: "{{$vars.userData.name}}",
              priority: "{{$vars.userData.priority}}",
              ai_summary: "{{$node.ai-1.data.text}}",
              completion_time: "{{$node.delay-1.data.timestamp}}",
              notifications_sent: {
                slack: "{{$node.slack-high.data.messageId}}",
                email: "{{$node.email-standard.data.messageId}}",
              },
            }),
          },
          colorClass: "text-sky-600 dark:text-sky-400",
          borderClass: "border-sky-200 dark:border-sky-800",
          selectedBorderClass: "border-sky-600 dark:border-sky-400",
        },
      },
    ],
    edges: [
      // Main flow
      { id: "e1", source: "trigger-1", target: "var-1" },
      { id: "e2", source: "var-1", target: "api-1" },
      { id: "e3", source: "api-1", target: "transform-1" },
      { id: "e4", source: "transform-1", target: "var-2" },
      { id: "e5", source: "var-2", target: "ai-1" },
      { id: "e6", source: "ai-1", target: "branch-1" },

      // Branch paths with conditional handles
      {
        id: "e7",
        source: "branch-1",
        sourceHandle: "true",
        target: "slack-high",
      },
      {
        id: "e8",
        source: "branch-1",
        sourceHandle: "false",
        target: "email-standard",
      },

      // Convergence to delay (both paths lead here)
      { id: "e9", source: "slack-high", target: "delay-1" },
      { id: "e10", source: "email-standard", target: "delay-1" },

      // Final step
      { id: "e11", source: "delay-1", target: "api-final" },
    ],
  },
];

----- Content End -----

===== File: lib/integrations/types.ts =====
Type: .ts
----- Content Start -----
// ============================================
// TYPE DEFINITIONS
// ============================================

export interface WorkflowContext {
  variables: Record<string, unknown>;
  nodeOutputs: Record<string, unknown>;
  executionId: string;
  userId?: string;
}

export interface IntegrationSchema {
  fields: SchemaField[];
  required: string[];
  dependencies?: Record<string, string[]>;
}

export interface SchemaField {
  key: string;
  type: "text" | "textarea" | "select" | "number" | "boolean" | "email" | "url";
  label: string;
  placeholder?: string;
  required?: boolean;
  supportExpressions?: boolean;
  options?:
    | Array<{ label: string; value: string }>
    | (() => Promise<Array<{ label: string; value: string }>>);
  validation?: (value: unknown) => string | null;
  dependsOn?: string;
}

export interface IntegrationExecutor {
  execute: (
    config: Record<string, unknown>,
    context: WorkflowContext
  ) => Promise<ExecutionResult>;
  validate?: (config: Record<string, unknown>) => ValidationResult;
}

export interface ExecutionResult extends Record<string, unknown> {
  success: boolean;
  data?: Record<string, unknown>;
  error?: string;
  metadata?: {
    nodeType: string;
    subtype: string;
    executionTime?: number;
    [key: string]: unknown;
  };
}

export interface ValidationResult {
  valid: boolean;
  errors: Record<string, string>;
}

export interface Integration {
  id: string;
  name: string;
  category: "trigger" | "action" | "logic";
  description: string;
  icon: string;
  version: string;

  // Visual styling (auto-generated based on category)
  colorClass?: string;
  borderClass?: string;
  selectedBorderClass?: string;

  // Integration logic
  schema: IntegrationSchema;
  executor: IntegrationExecutor;

  // Optional features
  auth?: {
    type: "oauth2" | "api_key" | "basic" | "none";
    required: boolean;
  };

  // For triggers only
  hasInputHandle?: boolean;
}

----- Content End -----

===== File: lib/integrations/registry.ts =====
Type: .ts
----- Content Start -----
import type {
  Integration,
  WorkflowContext,
  ExecutionResult,
  ValidationResult,
} from "./types";
import { validateIntegrationOutput } from "./utils";
import { parseExpression } from "../expression";

// Import all integrations
import { manualTrigger } from "./triggers/manual-trigger";
import { webhookTrigger } from "./triggers/webhook-trigger";
import { scheduleTrigger } from "./triggers/schedule-trigger";

// New Triggers
import { emailTrigger } from "./triggers/email-trigger";
import { formTrigger } from "./triggers/form-trigger";
import { databaseTrigger } from "./triggers/database-trigger";
import { fileWatcherTrigger } from "./triggers/file-watcher-trigger";
import { slackSendMessage } from "./actions/slack-send-message";
import { setVariable } from "./actions/set-variable";
import { emailSend } from "./actions/email-send";
import { apiRequest } from "./actions/api-request";
import { delay } from "./actions/delay";
import { aiIntegration } from "./actions/ai";
import { filterCondition } from "./logic/filter-condition";
import { branchCondition } from "./logic/branch-condition";
import { transformData } from "./logic/transform-data";

// New Logic Nodes
import { iteratorLoop } from "./logic/iterator-loop";
import { switchCase } from "./logic/switch-case";
import { dataValidator } from "./logic/data-validator";
import { aggregator } from "./logic/aggregator";
import { router } from "./logic/router";

// Communication & Messaging
import { discordSendMessage } from "./actions/discord-send-message";
import { teamsSendMessage } from "./actions/teams-send-message";
import { telegramSendMessage } from "./actions/telegram-send-message";

// Databases & Storage
import { postgresInsert } from "./actions/postgres-insert";
import { sheetsAppendRow } from "./actions/sheets-append-row";
import { airtableCreateRecord } from "./actions/airtable-create-record";
import { googleSheetsAppend } from "./actions/google-sheets-append";
import { databaseInsert } from "./actions/database-insert";
import { databaseSelect } from "./actions/database-select";

// Payments & Finance
import { stripeCreatePayment } from "./actions/stripe-create-payment";
import { paypalSendPayment } from "./actions/paypal-send-payment";

// CRM & Sales
import { hubspotCreateContact } from "./actions/hubspot-create-contact";
import { salesforceCreateLead } from "./actions/salesforce-create-lead";

// Project Management
import { asanaCreateTask } from "./actions/asana-create-task";
import { trelloCreateCard } from "./actions/trello-create-card";

// Cloud Storage
import { s3UploadFile } from "./actions/s3-upload-file";
import { driveUploadFile } from "./actions/drive-upload-file";

// Email Marketing
import { mailchimpAddSubscriber } from "./actions/mailchimp-add-subscriber";
import { sendgridSendEmail } from "./actions/sendgrid-send-email";

// Social Media
import { twitterPostTweet } from "./actions/twitter-post-tweet";
import { linkedinCreatePost } from "./actions/linkedin-create-post";

// Development Tools
import { githubCreateIssue } from "./actions/github-create-issue";
import { jiraCreateIssue } from "./actions/jira-create-issue";

// Business Tools
import { zoomCreateMeeting } from "./actions/zoom-create-meeting";
import { notionCreatePage } from "./actions/notion-create-page";

// Additional Integrations
import { smsSend } from "./actions/sms-send";
import { redisSet } from "./actions/redis-set";
import { cloudinaryUploadImage } from "./actions/cloudinary-upload-image";

// Calendar & Scheduling
import { googleCalendarCreateEvent } from "./actions/google-calendar-create-event";
import { calendlyCreateBooking } from "./actions/calendly-create-booking";
import { outlookCalendarCreateEvent } from "./actions/outlook-calendar-create-event";

// File Processing & Data
import { csvParser } from "./actions/csv-parser";
import { pdfGenerator } from "./actions/pdf-generator";
import { imageProcessor } from "./actions/image-processor";

// Authentication & Security
import { jwtTokenGenerator } from "./actions/jwt-token-generator";
import { passwordGenerator } from "./actions/password-generator";

// Real Monitoring & Observability
import { httpMonitor } from "./actions/http-monitor";
import { logParser } from "./actions/log-parser";

// Advanced Logic
import { jsonPathExtractor } from "./logic/json-path-extractor";
import { templateEngine } from "./logic/template-engine";

// Communication Upgrades
import { whatsappSendMessage } from "./actions/whatsapp-send-message";

// E-commerce & Payments
import { shopifyCreateProduct } from "./actions/shopify-create-product";

// ============================================
// INTEGRATION REGISTRY CLASS
// ============================================

class IntegrationRegistry {
  private integrations = new Map<string, Integration>();

  constructor() {
    // Register all integrations
    this.registerIntegrations([
      // Triggers
      manualTrigger,
      webhookTrigger,
      scheduleTrigger,
      emailTrigger,
      formTrigger,
      databaseTrigger,
      fileWatcherTrigger,

      // Actions
      slackSendMessage,
      setVariable,
      emailSend,
      apiRequest,
      delay,
      aiIntegration,

      // Communication & Messaging
      discordSendMessage,
      teamsSendMessage,
      telegramSendMessage,

      // Databases & Storage
      postgresInsert,
      sheetsAppendRow,
      airtableCreateRecord,
      googleSheetsAppend,
      databaseInsert,
      databaseSelect,

      // Payments & Finance
      stripeCreatePayment,
      paypalSendPayment,

      // CRM & Sales
      hubspotCreateContact,
      salesforceCreateLead,

      // Project Management
      asanaCreateTask,
      trelloCreateCard,

      // Cloud Storage
      s3UploadFile,
      driveUploadFile,

      // Email Marketing
      mailchimpAddSubscriber,
      sendgridSendEmail,

      // Social Media
      twitterPostTweet,
      linkedinCreatePost,

      // Development Tools
      githubCreateIssue,
      jiraCreateIssue,

      // Business Tools
      zoomCreateMeeting,
      notionCreatePage,

      // Additional Integrations
      smsSend,
      redisSet,
      cloudinaryUploadImage,

      // Calendar & Scheduling
      googleCalendarCreateEvent,
      calendlyCreateBooking,
      outlookCalendarCreateEvent,

      // File Processing & Data
      csvParser,
      pdfGenerator,
      imageProcessor,

      // Authentication & Security
      jwtTokenGenerator,
      passwordGenerator,

      // Real Monitoring & Observability
      httpMonitor,
      logParser,

      // Advanced Logic
      jsonPathExtractor,
      templateEngine,

      // Communication Upgrades
      whatsappSendMessage,

      // E-commerce & Payments
      shopifyCreateProduct,

      // Logic
      filterCondition,
      branchCondition,
      transformData,
      iteratorLoop,
      switchCase,
      dataValidator,
      aggregator,
      router,
    ]);
  }

  private registerIntegrations(integrations: Integration[]) {
    integrations.forEach((integration) => {
      this.integrations.set(integration.id, integration);
    });
  }

  register(integration: Integration) {
    this.integrations.set(integration.id, integration);
  }

  unregister(id: string) {
    return this.integrations.delete(id);
  }

  get(id: string): Integration | undefined {
    return this.integrations.get(id);
  }

  getByCategory(category: "trigger" | "action" | "logic"): Integration[] {
    return Array.from(this.integrations.values()).filter(
      (integration) => integration.category === category
    );
  }

  getAll(): Integration[] {
    return Array.from(this.integrations.values());
  }

  getTriggers(): Integration[] {
    return this.getByCategory("trigger");
  }

  getActions(): Integration[] {
    return this.getByCategory("action");
  }

  getLogic(): Integration[] {
    return this.getByCategory("logic");
  }

  // Search integrations by name, description, or category
  search(query: string): Integration[] {
    const lowercaseQuery = query.toLowerCase();
    return Array.from(this.integrations.values()).filter(
      (integration) =>
        integration.name.toLowerCase().includes(lowercaseQuery) ||
        integration.description.toLowerCase().includes(lowercaseQuery) ||
        integration.category.toLowerCase().includes(lowercaseQuery)
    );
  }

  // Get integrations with auth requirements
  getAuthRequired(): Integration[] {
    return Array.from(this.integrations.values()).filter(
      (integration) => integration.auth?.required
    );
  }

  // Get integrations by version
  getByVersion(version: string): Integration[] {
    return Array.from(this.integrations.values()).filter(
      (integration) => integration.version === version
    );
  }

  // Validate integration configuration
  validateConfig(
    integrationId: string,
    config: Record<string, unknown>
  ): ValidationResult {
    const integration = this.get(integrationId);
    if (!integration) {
      return {
        valid: false,
        errors: { integration: "Integration not found" },
      };
    }

    if (integration.executor.validate) {
      return integration.executor.validate(config);
    }

    // Basic validation based on schema
    const errors: Record<string, string> = {};
    integration.schema.required.forEach((field) => {
      if (!config[field]) {
        errors[field] = `${field} is required`;
      }
    });

    // Field-level validation
    integration.schema.fields.forEach((field) => {
      const value = config[field.key];
      if (field.validation && value !== undefined) {
        const validationError = field.validation(value);
        if (validationError) {
          errors[field.key] = validationError;
        }
      }
    });

    return {
      valid: Object.keys(errors).length === 0,
      errors,
    };
  }

  // Execute an integration
  async executeIntegration(
    integrationId: string,
    config: Record<string, unknown>,
    context: WorkflowContext
  ): Promise<ExecutionResult> {
    const integration = this.get(integrationId);
    if (!integration) {
      return {
        success: false,
        error: `Integration '${integrationId}' not found`,
        metadata: {
          nodeType: "unknown",
          subtype: integrationId,
        },
      };
    }

    // ----  NEW: interpolate expressions inside config (repeat until stable) ----
    const hydrate = (value: unknown): unknown => {
      const seen = new Set<string>();
      let out: unknown = value;
      while (typeof out === "string" && !seen.has(out)) {
        seen.add(out);
        // Branch-condition needs strings to be quoted _inside_ the JS expression
        const quote = integration.id === "branch_condition";
        out = parseExpression(out, context, quote);
      }
      if (Array.isArray(out)) return out.map(hydrate);
      if (out && typeof out === "object" && out !== null)
        return Object.fromEntries(
          Object.entries(out as Record<string, unknown>).map(([k, v]) => [
            k,
            hydrate(v),
          ])
        );
      return out;
    };
    const interpolatedConfig = hydrate(config) as Record<string, unknown>;

    try {
      const startTime = Date.now();
      const result = await integration.executor.execute(
        interpolatedConfig,
        context
      );
      const executionTime = Date.now() - startTime;

      // Add execution time to metadata
      if (result.metadata) {
        result.metadata.executionTime = executionTime;
      }

      // Validate output schema
      if (!validateIntegrationOutput(integrationId, result)) {
        console.warn(
          `Integration ${integrationId} returned invalid output schema`
        );
      }

      return result;
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
        metadata: {
          nodeType: integration.category,
          subtype: integrationId,
        },
      };
    }
  }

  // Get integration statistics
  getStats() {
    const integrations = this.getAll();
    return {
      total: integrations.length,
      triggers: this.getTriggers().length,
      actions: this.getActions().length,
      logic: this.getLogic().length,
      withAuth: this.getAuthRequired().length,
    };
  }
}

// Create and export the global registry instance
export const integrationRegistry = new IntegrationRegistry();

// Export the registry class for advanced usage
export { IntegrationRegistry };

----- Content End -----

===== File: lib/integrations/triggers/manual-trigger.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from '../utils';
import type { Integration } from '../types';

export const manualTrigger: Integration = createIntegration({
  id: "manual_trigger",
  name: "Manual",
  category: "trigger",
  description: "Trigger manually",
  icon: "hand",
  version: "1.0.0",

  hasInputHandle: false,

  schema: {
    fields: [
      {
        key: "triggerName",
        type: "text",
        label: "Trigger Name",
        placeholder: "My Manual Trigger",
        required: false,
      },
    ],
    required: [],
  },

  executor: {
    async execute(config) {
      const timestamp = new Date().toISOString();
      return {
        success: true,
        data: {
          triggered: true,
          timestamp,
          triggerName: (config.triggerName as string) || "Manual Trigger",
        },
        metadata: { nodeType: "trigger", subtype: "manual_trigger" },
      };
    },
  },
}); 
----- Content End -----

===== File: lib/integrations/logic/branch-condition.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration, WorkflowContext } from "../types";
import { parseExpression } from "../../expression";

export const branchCondition: Integration = createIntegration({
  id: "branch_condition",
  name: "Branch",
  category: "logic",
  description: "Split workflow into multiple paths",
  icon: "diamond",
  version: "1.0.0",

  schema: {
    fields: [
      {
        key: "condition",
        type: "textarea",
        label: "Condition Expression",
        placeholder: "{{$node.trigger-1.data.status}} === 'active'",
        required: true,
        supportExpressions: true,
      },
      {
        key: "trueLabel",
        type: "text",
        label: "True Path Label",
        placeholder: "If condition is true",
        required: false,
      },
      {
        key: "falseLabel",
        type: "text",
        label: "False Path Label",
        placeholder: "If condition is false",
        required: false,
      },
    ],
    required: ["condition"],
  },

  executor: {
    async execute(config, ctx: WorkflowContext) {
      // The condition should already be interpolated by the registry
      const condition = config.condition as string;

      // Parse the condition to replace variables
      const interpolatedCondition = parseExpression(condition, ctx, true);

      let conditionResult = false;
      try {
        conditionResult = Function(
          `"use strict"; return (${interpolatedCondition});`
        )();
      } catch (error) {
        console.warn("Branch condition evaluation failed:", error);
      }

      const timestamp = new Date().toISOString();

      return {
        success: true,
        data: {
          condition: interpolatedCondition, // Show the actual evaluated condition
          result: conditionResult,
          path: conditionResult ? "true" : "false",
          timestamp,
        },
        metadata: { nodeType: "logic", subtype: "branch_condition" },
      };
    },
  },
});

----- Content End -----

===== File: lib/integrations/actions/api-request.ts =====
Type: .ts
----- Content Start -----
import { createIntegration } from "../utils";
import type { Integration } from "../types";

export const apiRequest: Integration = createIntegration({
  id: "api_request",
  name: "API Request",
  category: "action",
  description: "Make an HTTP API request",
  icon: "globe",
  version: "1.0.0",

  schema: {
    fields: [
      {
        key: "url",
        type: "url",
        label: "API Endpoint",
        placeholder: "https://api.example.com/endpoint",
        required: true,
      },
      {
        key: "method",
        type: "select",
        label: "HTTP Method",
        required: true,
        options: [
          { label: "GET", value: "GET" },
          { label: "POST", value: "POST" },
          { label: "PUT", value: "PUT" },
          { label: "DELETE", value: "DELETE" },
        ],
      },
      {
        key: "headers",
        type: "textarea",
        label: "Headers (JSON)",
        placeholder: '{"Authorization": "Bearer token"}',
        required: false,
      },
      {
        key: "body",
        type: "textarea",
        label: "Request Body (JSON)",
        placeholder:
          '{"user_id": "{{$node.webhook-1.data.user.id}}", "status": "{{$node.webhook-1.data.status}}"}',
        required: false,
        supportExpressions: true,
      },
    ],
    required: ["url", "method"],
  },

  executor: {
    async execute() {
      await new Promise((resolve) => setTimeout(resolve, 600));
      const timestamp = new Date().toISOString();
      return {
        success: true,
        data: {
          status: 200,
          statusText: "OK",
          headers: {
            "content-type": "application/json",
            "x-ratelimit-remaining": "4999",
          },
          response: {
            id: 12345,
            name: "John Doe",
            email: "john@example.com",
            created_at: "2024-12-01T10:30:00Z",
          },
          responseTime: "245ms",
          timestamp,
        },
        metadata: { nodeType: "action", subtype: "api_request" },
      };
    },
  },
});

----- Content End -----

===== File: app/layout.tsx =====
Type: .tsx
----- Content Start -----
import type { Metadata } from "next";
import {
  Geist,
  Geist_Mono,
  Poppins,
  Inter,
  Roboto,
  Open_Sans,
  Montserrat,
  Outfit,
  Albert_Sans,
  Plus_Jakarta_Sans,
  DM_Sans,
  Manrope,
  Space_Grotesk,
  JetBrains_Mono,
} from "next/font/google";
import "./globals.css";
import { ThemeProvider } from "next-themes";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

const poppins = Poppins({
  variable: "--font-poppins",
  subsets: ["latin"],
  weight: ["400", "500", "600", "700"],
});

const inter = Inter({
  variable: "--font-inter",
  subsets: ["latin"],
});

const roboto = Roboto({
  variable: "--font-roboto",
  subsets: ["latin"],
  weight: ["400", "500", "700"],
});

const openSans = Open_Sans({
  variable: "--font-open-sans",
  subsets: ["latin"],
  weight: ["400", "500", "600", "700"],
});

const montserrat = Montserrat({
  variable: "--font-montserrat",
  subsets: ["latin"],
  weight: ["400", "500", "600", "700"],
});

const outfit = Outfit({
  variable: "--font-outfit",
  subsets: ["latin"],
  weight: ["400", "500", "600", "700"],
});

const albertSans = Albert_Sans({
  variable: "--font-albert-sans",
  subsets: ["latin"],
  weight: ["400", "500", "600", "700"],
});

const plusJakartaSans = Plus_Jakarta_Sans({
  variable: "--font-plus-jakarta-sans",
  subsets: ["latin"],
  weight: ["400", "500", "600", "700"],
});

const dmSans = DM_Sans({
  variable: "--font-dm-sans",
  subsets: ["latin"],
  weight: ["400", "500", "600", "700"],
});

const manrope = Manrope({
  variable: "--font-manrope",
  subsets: ["latin"],
  weight: ["400", "500", "600", "700"],
});

const spaceGrotesk = Space_Grotesk({
  variable: "--font-space-grotesk",
  subsets: ["latin"],
  weight: ["400", "500", "600", "700"],
});

const jetbrainsMono = JetBrains_Mono({
  variable: "--font-jetbrains-mono",
  subsets: ["latin"],
  weight: ["400", "500", "600", "700"],
});

export const metadata: Metadata = {
  title: "Agent Maker",
  description: "Automations and Workflows for your business",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <head>
        <script
          dangerouslySetInnerHTML={{
            __html: `
              (function() {
                try {
                  var theme = localStorage.getItem('theme');
                  if (!theme) {
                    theme = 'dark';
                  }
                  if (theme === 'system') {
                    theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
                  }
                  
                  var themeColor = theme === 'dark' ? '#0a0a0a' : '#ffffff';
                  var meta = document.createElement('meta');
                  meta.name = 'theme-color';
                  meta.content = themeColor;
                  document.head.appendChild(meta);
                } catch (e) {}
              })();
            `,
          }}
        />
      </head>
      <body
        className={`${geistSans.variable} ${geistMono.variable} ${poppins.variable} ${inter.variable} ${roboto.variable} ${openSans.variable} ${montserrat.variable} ${outfit.variable} ${albertSans.variable} ${plusJakartaSans.variable} ${dmSans.variable} ${manrope.variable} ${spaceGrotesk.variable} ${jetbrainsMono.variable} antialiased`}
      >
        <ThemeProvider attribute="class" defaultTheme="dark" enableSystem>
          {children}
        </ThemeProvider>
      </body>
    </html>
  );
}

----- Content End -----

===== File: app/page.tsx =====
Type: .tsx
----- Content Start -----
"use client";

import { useState, useEffect } from "react";
import Link from "next/link";
import { useThemeToggle } from "../hooks/useThemeToggle";
import {
  Plus,
  Edit,
  Trash2,
  Clock,
  Zap,
  User,
  Mail,
  Globe,
} from "lucide-react";

// ============================================
// TYPE DEFINITIONS
// ============================================

interface NodeData {
  subtype?: string;
  description?: string;
  label?: string;
}

interface Node {
  type: string;
  data?: NodeData;
}

interface Automation {
  id: string;
  name: string;
  nodes: Node[];
  edges: Record<string, unknown>[];
  status: string;
  created_at: string;
  updated_at: string;
}

// ============================================
// UTILITY FUNCTIONS
// ============================================

const getTriggerIcon = (nodes: Node[]) => {
  // Find the first trigger node to determine the trigger type
  const triggerNode = nodes.find(
    (node) =>
      node.type === "trigger" ||
      (node.data?.subtype && node.data.subtype.includes("_trigger"))
  );

  if (!triggerNode) return <Zap className="w-4 h-4" />;

  const subtype = triggerNode.data?.subtype;
  switch (subtype) {
    case "webhook_trigger":
      return <Globe className="w-4 h-4" />;
    case "schedule_trigger":
      return <Clock className="w-4 h-4" />;
    case "email_trigger":
      return <Mail className="w-4 h-4" />;
    case "manual_trigger":
      return <User className="w-4 h-4" />;
    default:
      return <Zap className="w-4 h-4" />;
  }
};

const getAutomationDescription = (nodes: Node[]) => {
  if (nodes.length === 0) return "No nodes configured";

  const actionNodes = nodes.filter(
    (node) =>
      node.type === "action" ||
      (node.data?.subtype && !node.data.subtype.includes("_trigger"))
  );

  if (actionNodes.length === 0) return "No actions configured";

  const firstAction = actionNodes[0];
  return (
    firstAction.data?.description ||
    firstAction.data?.label ||
    "Action configured"
  );
};

// ============================================
// MAIN COMPONENT
// ============================================

export default function Home() {
  const { theme, toggleTheme, mounted } = useThemeToggle();
  const [automations, setAutomations] = useState<Automation[]>([]);
  const [loading, setLoading] = useState(true);
  const [activeTab, setActiveTab] = useState<
    "automations" | "integrations" | "settings" | "docs"
  >("automations");

  // Fetch automations on component mount
  useEffect(() => {
    const fetchAutomations = async () => {
      try {
        const response = await fetch("/api/automations");
        if (response.ok) {
          const data = await response.json();
          setAutomations(data);
        }
      } catch (error) {
        console.error("Failed to fetch automations:", error);
      } finally {
        setLoading(false);
      }
    };
    fetchAutomations();
  }, []);

  // Sort automations by last updated
  const sortedAutomations = automations.sort(
    (a, b) =>
      new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime()
  );

  const handleDeleteAutomation = async (id: string) => {
    if (!window.confirm("Are you sure you want to delete this automation?"))
      return;

    try {
      const response = await fetch(`/api/automations?id=${id}`, {
        method: "DELETE",
      });
      if (response.ok) {
        setAutomations((prev) =>
          prev.filter((automation) => automation.id !== id)
        );
      }
    } catch (error) {
      console.error("Failed to delete automation:", error);
    }
  };

  const handleToggleAutomation = async (id: string, currentStatus: string) => {
    const newStatus = currentStatus === "active" ? "inactive" : "active";

    try {
      const response = await fetch(`/api/automations?id=${id}`, {
        method: "PATCH",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ status: newStatus }),
      });
      if (response.ok) {
        setAutomations((prev) =>
          prev.map((automation) =>
            automation.id === id
              ? { ...automation, status: newStatus }
              : automation
          )
        );
      }
    } catch (error) {
      console.error("Failed to toggle automation:", error);
    }
  };

  return (
    <div className="min-h-screen bg-[var(--background)]">
      {/* TOP BAR */}
      <div className="bg-[var(--card)] border-b border-[var(--border)] px-6 py-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-8">
            {/* Logo */}
            <h1 className="text-2xl font-semibold text-[var(--foreground)] tracking-wide">
              {"[Agent Maker]"}
            </h1>
          </div>

          {/* Action Buttons */}
          <div className="flex items-center gap-3">
            {mounted && (
              <button
                onClick={toggleTheme}
                className="p-2 text-[var(--foreground)] hover:bg-[var(--muted)] rounded-lg transition-colors"
                aria-label="Toggle theme"
              >
                {theme === "dark" ? (
                  <svg
                    className="w-5 h-5"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth={2}
                      d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"
                    />
                  </svg>
                ) : (
                  <svg
                    className="w-5 h-5"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth={2}
                      d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"
                    />
                  </svg>
                )}
              </button>
            )}

            {!loading && sortedAutomations.length > 0 && (
              <Link
                href="/editor"
                className="inline-flex items-center gap-2 px-4 py-2 bg-[var(--primary)] text-[var(--primary-foreground)] rounded-lg hover:bg-[var(--primary)]/90 transition-colors text-sm font-medium"
              >
                <Plus className="w-4 h-4" />
                New Automation
              </Link>
            )}
          </div>
        </div>
      </div>

      {/* TAB NAVIGATION */}
      <div className="border-b border-[var(--border)]">
        <div className="px-6">
          <div className="flex space-x-8">
            <button
              onClick={() => setActiveTab("automations")}
              className={`py-4 px-1 border-b-2 font-medium text-sm transition-colors ${
                activeTab === "automations"
                  ? "border-[var(--primary)] text-[var(--primary)]"
                  : "border-transparent text-[var(--muted-foreground)] hover:text-[var(--foreground)]"
              }`}
            >
              Automations
            </button>
            <button
              onClick={() => setActiveTab("integrations")}
              className={`py-4 px-1 border-b-2 font-medium text-sm transition-colors ${
                activeTab === "integrations"
                  ? "border-[var(--primary)] text-[var(--primary)]"
                  : "border-transparent text-[var(--muted-foreground)] hover:text-[var(--foreground)]"
              }`}
            >
              Integrations
            </button>
            <button
              onClick={() => setActiveTab("settings")}
              className={`py-4 px-1 border-b-2 font-medium text-sm transition-colors ${
                activeTab === "settings"
                  ? "border-[var(--primary)] text-[var(--primary)]"
                  : "border-transparent text-[var(--muted-foreground)] hover:text-[var(--foreground)]"
              }`}
            >
              Settings
            </button>
            <button
              onClick={() => setActiveTab("docs")}
              className={`py-4 px-1 border-b-2 font-medium text-sm transition-colors ${
                activeTab === "docs"
                  ? "border-[var(--primary)] text-[var(--primary)]"
                  : "border-transparent text-[var(--muted-foreground)] hover:text-[var(--foreground)]"
              }`}
            >
              Docs
            </button>
          </div>
        </div>
      </div>

      {/* CONTENT AREA */}
      <div className="p-6">
        {activeTab === "automations" ? (
          <>
            {loading ? (
              <div className="flex items-center justify-center min-h-[calc(100vh-200px)]">
                <div className="text-center">
                  <div className="animate-spin w-8 h-8 border-2 border-[var(--primary)] border-t-transparent rounded-full mx-auto mb-4"></div>
                  <p className="text-[var(--muted-foreground)]">
                    Loading automations...
                  </p>
                </div>
              </div>
            ) : sortedAutomations.length === 0 ? (
              <div className="flex items-center justify-center min-h-[calc(100vh-200px)]">
                <div className="text-center">
                  <div className="w-16 h-16 mx-auto mb-4 bg-[var(--muted)] rounded-full flex items-center justify-center">
                    <Zap className="w-8 h-8 text-[var(--muted-foreground)]" />
                  </div>
                  <h3 className="text-lg font-medium text-[var(--foreground)] mb-2">
                    No automations yet
                  </h3>
                  <p className="text-[var(--muted-foreground)] mb-6">
                    Create your first automation to get started
                  </p>
                  <Link
                    href="/editor"
                    className="inline-flex items-center gap-2 px-4 py-2 bg-[var(--primary)] text-[var(--primary-foreground)] rounded-lg hover:bg-[var(--primary)]/90 transition-colors text-sm font-medium"
                  >
                    <Plus className="w-4 h-4" />
                    Create Automation
                  </Link>
                </div>
              </div>
            ) : (
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                {sortedAutomations.map((automation) => (
                  <div
                    key={automation.id}
                    className="group relative bg-[var(--card)] border border-[var(--border)] rounded-xl p-5 hover:shadow-lg hover:border-[var(--ring)] transition-all duration-200 cursor-pointer"
                  >
                    {/* Status Indicator */}
                    <div className="absolute top-4 right-4">
                      <div
                        className={`w-2 h-2 rounded-full ${
                          automation.status === "active"
                            ? "bg-green-500"
                            : automation.status === "error"
                            ? "bg-red-500"
                            : "bg-gray-400"
                        }`}
                      />
                    </div>

                    {/* Header */}
                    <div className="flex items-start gap-3 mb-4">
                      <div className="p-2.5 bg-[var(--muted)] rounded-lg flex-shrink-0">
                        {getTriggerIcon(automation.nodes)}
                      </div>
                      <div className="min-w-0 flex-1">
                        <h3 className="font-semibold text-[var(--foreground)] text-lg mb-1 truncate">
                          {automation.name}
                        </h3>
                        <p className="text-sm text-[var(--muted-foreground)] line-clamp-2 leading-relaxed">
                          {getAutomationDescription(automation.nodes)}
                        </p>
                      </div>
                    </div>

                    {/* Action Bar */}
                    <div className="flex items-center justify-between pt-3 border-t border-[var(--border)] relative z-20">
                      <div className="text-xs text-[var(--muted-foreground)]">
                        {new Date(automation.updated_at).toLocaleDateString()}
                      </div>
                      <div className="flex items-center gap-2">
                        {/* Toggle Button */}
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            handleToggleAutomation(
                              automation.id,
                              automation.status
                            );
                          }}
                          className={`relative inline-flex h-5 w-9 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-[var(--ring)] focus:ring-offset-2 ${
                            automation.status === "active"
                              ? "bg-green-500 hover:bg-green-600"
                              : "bg-[var(--muted)] hover:bg-[var(--border)]"
                          }`}
                          title={
                            automation.status === "active"
                              ? "Turn off automation"
                              : "Turn on automation"
                          }
                        >
                          <span
                            className={`inline-block h-3 w-3 transform rounded-full bg-white transition-transform ${
                              automation.status === "active"
                                ? "translate-x-5"
                                : "translate-x-1"
                            }`}
                          />
                        </button>

                        <Link
                          href={`/editor?id=${automation.id}`}
                          className="p-2 text-[var(--muted-foreground)] hover:text-[var(--foreground)] hover:bg-[var(--muted)] rounded-lg transition-colors"
                          onClick={(e) => e.stopPropagation()}
                        >
                          <Edit className="w-4 h-4" />
                        </Link>
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            handleDeleteAutomation(automation.id);
                          }}
                          className="p-2 text-[var(--muted-foreground)] hover:text-red-600 hover:bg-red-50 dark:hover:bg-red-900/20 rounded-lg transition-colors"
                        >
                          <Trash2 className="w-4 h-4" />
                        </button>
                      </div>
                    </div>

                    {/* Click Overlay */}
                    <Link
                      href={`/editor?id=${automation.id}`}
                      className="absolute inset-0 z-10"
                      aria-label={`View ${automation.name} details`}
                    />
                  </div>
                ))}
              </div>
            )}
          </>
        ) : activeTab === "integrations" ? (
          // Integrations tab content
          <div className="flex items-center justify-center min-h-[calc(100vh-200px)]">
            <div className="text-center">
              <div className="w-16 h-16 mx-auto mb-4 bg-[var(--muted)] rounded-full flex items-center justify-center">
                <Globe className="w-8 h-8 text-[var(--muted-foreground)]" />
              </div>
              <h3 className="text-lg font-medium text-[var(--foreground)] mb-2">
                Integrations coming soon
              </h3>
              <p className="text-[var(--muted-foreground)]">
                Manage your third-party integrations and API connections here.
              </p>
            </div>
          </div>
        ) : activeTab === "settings" ? (
          // Settings tab content
          <div className="flex items-center justify-center min-h-[calc(100vh-200px)]">
            <div className="text-center">
              <div className="w-16 h-16 mx-auto mb-4 bg-[var(--muted)] rounded-full flex items-center justify-center">
                <svg
                  className="w-8 h-8 text-[var(--muted-foreground)]"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"
                  />
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"
                  />
                </svg>
              </div>
              <h3 className="text-lg font-medium text-[var(--foreground)] mb-2">
                Settings coming soon
              </h3>
              <p className="text-[var(--muted-foreground)]">
                Configure your account preferences and application settings
                here.
              </p>
            </div>
          </div>
        ) : (
          // Docs tab content
          <div className="flex items-center justify-center min-h-[calc(100vh-200px)]">
            <div className="text-center">
              <div className="w-16 h-16 mx-auto mb-4 bg-[var(--muted)] rounded-full flex items-center justify-center">
                <svg
                  className="w-8 h-8 text-[var(--muted-foreground)]"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"
                  />
                </svg>
              </div>
              <h3 className="text-lg font-medium text-[var(--foreground)] mb-2">
                Documentation coming soon
              </h3>
              <p className="text-[var(--muted-foreground)]">
                Access guides, tutorials, and API documentation here.
              </p>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

----- Content End -----

===== File: app/globals.css =====
Type: .css
----- Content Start -----
@import "tailwindcss";

/* Font utilities */
.font-poppins {
  font-family: var(--font-poppins);
}

/* Set JetBrains Mono as default font for the entire website */
body {
  font-family: var(--font-jetbrains-mono);
}

/* Alternative fonts for easy switching */
.font-inter {
  font-family: var(--font-inter);
}

.font-geist {
  font-family: var(--font-geist-sans);
}

.font-roboto {
  font-family: var(--font-roboto);
}

.font-open-sans {
  font-family: var(--font-open-sans);
}

.font-montserrat {
  font-family: var(--font-montserrat);
}

/* Unique and distinctive fonts */
.font-outfit {
  font-family: var(--font-outfit);
}

.font-albert-sans {
  font-family: var(--font-albert-sans);
}

.font-plus-jakarta-sans {
  font-family: var(--font-plus-jakarta-sans);
}

.font-dm-sans {
  font-family: var(--font-dm-sans);
}

.font-manrope {
  font-family: var(--font-manrope);
}

.font-space-grotesk {
  font-family: var(--font-space-grotesk);
}

.font-jetbrains-mono {
  font-family: var(--font-jetbrains-mono);
}

/* CSS Variables for Light and Dark Themes */
:root {
  /* Light theme variables */
  --background: #ffffff;
  --foreground: #171717;
  --card: #ffffff;
  --card-foreground: #171717;
  --popover: #ffffff;
  --popover-foreground: #171717;
  --primary: #0f172a;
  --primary-foreground: #f8fafc;
  --secondary: #f1f5f9;
  --secondary-foreground: #0f172a;
  --muted: #f1f5f9;
  --muted-foreground: #64748b;
  --accent: #f1f5f9;
  --accent-foreground: #0f172a;
  --destructive: #ef4444;
  --destructive-foreground: #f8fafc;
  --border: #e2e8f0;
  --input: #e2e8f0;
  --ring: #0f172a;
  --radius: 0.5rem;
  --top-bar-height: 72px;
  --scrollbar-thumb: #d1d5db;
  --scrollbar-thumb-hover: #9ca3af;
  --scrollbar-thumb-active: #6b7280;
}

.dark {
  /* Dark theme variables */
  --background: #0a0a0a;
  --foreground: #ededed;
  --card: #171717;
  --card-foreground: #ededed;
  --popover: #171717;
  --popover-foreground: #ededed;
  --primary: #f8fafc;
  --primary-foreground: #0f172a;
  --secondary: #262626;
  --secondary-foreground: #f8fafc;
  --muted: #262626;
  --muted-foreground: #a1a1aa;
  --accent: #262626;
  --accent-foreground: #f8fafc;
  --destructive: #7f1d1d;
  --destructive-foreground: #f8fafc;
  --border: #262626;
  --input: #262626;
  --ring: #f8fafc;
  --top-bar-height: 72px;
  --scrollbar-thumb: #404040;
  --scrollbar-thumb-hover: #525252;
  --scrollbar-thumb-active: #737373;
}

/* Apply theme colors to body */
body {
  background-color: var(--background);
  color: var(--foreground);
  transition: background-color 0.3s ease, color 0.3s ease;
}

/* Custom Scrollbar Styles */
.custom-scrollbar::-webkit-scrollbar {
  width: 6px;
}

.custom-scrollbar::-webkit-scrollbar-track {
  background: transparent;
}

.custom-scrollbar::-webkit-scrollbar-thumb {
  background: var(--scrollbar-thumb);
  border-radius: 3px;
  transition: background 0.2s ease;
}

.custom-scrollbar::-webkit-scrollbar-thumb:hover {
  background: var(--scrollbar-thumb-hover);
}

.custom-scrollbar::-webkit-scrollbar-thumb:active {
  background: var(--scrollbar-thumb-active);
}

/* Firefox scrollbar styles */
.custom-scrollbar {
  scrollbar-width: thin;
  scrollbar-color: var(--scrollbar-thumb) transparent;
}

/* Modern Dropdown/Select Styles */
select {
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
  background-position: right 12px center;
  background-repeat: no-repeat;
  background-size: 16px;
  padding-right: 40px;
  cursor: pointer;
  transition: all 0.2s ease;
}

select:hover {
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%239ca3af' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
}

select:focus {
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%230f172a' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
}

.dark select {
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23a1a1aa' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
}

.dark select:hover {
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23d1d5db' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
}

.dark select:focus {
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23f8fafc' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
}

/* Option styling for better readability */
select option {
  background-color: var(--background);
  color: var(--foreground);
  padding: 8px 12px;
  font-size: 14px;
}

select option:hover {
  background-color: var(--accent);
}

select option:checked {
  background-color: var(--primary);
  color: var(--primary-foreground);
}

/* Firefox specific select styling */
@-moz-document url-prefix() {
  select {
    background-image: none;
    padding-right: 12px;
  }

  select::-moz-focus-inner {
    border: 0;
  }

  select:-moz-focusring {
    color: transparent;
    text-shadow: 0 0 0 var(--foreground);
  }
}

/* Enhanced focus states for better accessibility */
select:focus-visible {
  outline: 2px solid var(--ring);
  outline-offset: 2px;
}

/* Disabled state styling */
select:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%239ca3af' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
}

.dark select:disabled {
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23525252' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
}

----- Content End -----

===== File: app/api/init/route.ts =====
Type: .ts
----- Content Start -----
import { NextResponse } from "next/server";
import { initializeDatabase } from "@/lib/db";
import { QueueProcessor } from "@/lib/execution-engine";

export async function POST() {
  try {
    // Initialize database schema
    await initializeDatabase();

    // Then start background processes
    startBackgroundProcesses();

    return NextResponse.json({
      status: "Database initialized and background processes started",
    });
  } catch (error) {
    console.error("Failed to initialize:", error);
    return NextResponse.json(
      {
        error: "Failed to initialize database and background processes",
      },
      { status: 500 }
    );
  }
}

let queueProcessor: QueueProcessor | null = null;

function startBackgroundProcesses() {
  if (queueProcessor) return; // Already started

  queueProcessor = new QueueProcessor();
  queueProcessor.start();

  // Graceful shutdown
  process.on("SIGINT", () => {
    console.log("Shutting down background processes...");
    queueProcessor?.stop();
    process.exit(0);
  });

  process.on("SIGTERM", () => {
    console.log("Shutting down background processes...");
    queueProcessor?.stop();
    process.exit(0);
  });
}

----- Content End -----

===== File: app/api/automations/route.ts =====
Type: .ts
----- Content Start -----
import { NextRequest, NextResponse } from "next/server";
import {
  getAllAutomations,
  createAutomation,
  updateAutomation,
  updateAutomationStatus,
  deleteAutomation,
} from "@/lib/db";

export async function GET() {
  try {
    const automations = await getAllAutomations();
    return NextResponse.json(automations);
  } catch (error) {
    console.error("Database error:", error);
    return NextResponse.json(
      { error: "Failed to fetch automations" },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const { name, nodes, edges } = await request.json();

    const automation = await createAutomation(name, nodes, edges);
    return NextResponse.json(automation);
  } catch (error) {
    console.error("Database error:", error);
    return NextResponse.json(
      { error: "Failed to save automation" },
      { status: 500 }
    );
  }
}

export async function PUT(request: NextRequest) {
  try {
    const { id, name, nodes, edges } = await request.json();

    const automation = await updateAutomation(id, name, nodes, edges);
    return NextResponse.json(automation);
  } catch (error) {
    console.error("Database error:", error);
    if (error instanceof Error && error.message === "Automation not found") {
      return NextResponse.json(
        { error: "Automation not found" },
        { status: 404 }
      );
    }
    return NextResponse.json(
      { error: "Failed to update automation" },
      { status: 500 }
    );
  }
}

export async function PATCH(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const id = searchParams.get("id");
    const { status } = await request.json();

    if (!id) {
      return NextResponse.json(
        { error: "Automation ID is required" },
        { status: 400 }
      );
    }

    if (!status || !["active", "inactive"].includes(status)) {
      return NextResponse.json(
        { error: "Valid status is required" },
        { status: 400 }
      );
    }

    const automation = await updateAutomationStatus(id, status);
    return NextResponse.json(automation);
  } catch (error) {
    console.error("Database error:", error);
    if (error instanceof Error && error.message === "Automation not found") {
      return NextResponse.json(
        { error: "Automation not found" },
        { status: 404 }
      );
    }
    return NextResponse.json(
      { error: "Failed to update automation status" },
      { status: 500 }
    );
  }
}

export async function DELETE(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const id = searchParams.get("id");

    if (!id) {
      return NextResponse.json(
        { error: "Automation ID is required" },
        { status: 400 }
      );
    }

    await deleteAutomation(id);
    return NextResponse.json({ message: "Automation deleted successfully" });
  } catch (error) {
    console.error("Database error:", error);
    if (error instanceof Error && error.message === "Automation not found") {
      return NextResponse.json(
        { error: "Automation not found" },
        { status: 404 }
      );
    }
    return NextResponse.json(
      { error: "Failed to delete automation" },
      { status: 500 }
    );
  }
}

----- Content End -----

===== File: app/api/execute/route.ts =====
Type: .ts
----- Content Start -----
import { NextRequest, NextResponse } from "next/server";
import {
  createExecution,
  getExecutionWithSteps,
  getLatestExecution,
} from "@/lib/db";

export async function POST(request: NextRequest) {
  try {
    const { workflowId } = await request.json();

    if (!workflowId) {
      return NextResponse.json(
        { error: "Automation ID is required" },
        { status: 400 }
      );
    }

    // Create execution record
    const execution = await createExecution(workflowId);

    return NextResponse.json({
      executionId: execution.id,
      status: "queued",
    });
  } catch (error) {
    console.error("Database error:", error);
    return NextResponse.json(
      { error: "Failed to start execution" },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const executionId = searchParams.get("executionId");
    const workflowId = searchParams.get("workflowId");
    const latest = searchParams.get("latest");

    if (executionId) {
      // Get specific execution status
      const execution = await getExecutionWithSteps(executionId);

      if (!execution) {
        return NextResponse.json(
          { error: "Execution not found" },
          { status: 404 }
        );
      }

      return NextResponse.json({
        id: execution.id,
        status: execution.status,
        started_at: execution.started_at,
        completed_at: execution.completed_at,
        error_message: execution.error_message,
        steps: execution.steps,
      });
    } else if (workflowId && latest) {
      // Get latest execution for an automation
      const execution = await getLatestExecution(workflowId);

      if (!execution) {
        return NextResponse.json(null);
      }

      return NextResponse.json(execution);
    } else {
      return NextResponse.json(
        {
          error:
            "Either executionId or workflowId with latest=true is required",
        },
        { status: 400 }
      );
    }
  } catch (error) {
    console.error("Database error:", error);
    return NextResponse.json(
      { error: "Failed to get execution status" },
      { status: 500 }
    );
  }
}

----- Content End -----

===== File: app/editor/page.tsx =====
Type: .tsx
----- Content Start -----
"use client";

import { useCallback, useEffect, DragEvent, Suspense } from "react";
import { useThemeToggle } from "../../hooks/useThemeToggle";
import { getIcon } from "../../hooks/useIcons";
import { useSearchParams } from "next/navigation";
import type { WorkflowTemplate } from "../../lib/integrations/templates";

import {
  ReactFlow,
  ReactFlowProvider,
  applyNodeChanges,
  applyEdgeChanges,
  addEdge,
  NodeChange,
  EdgeChange,
  Connection,
  Node,
  Edge,
  NodeTypes,
  Background,
  BackgroundVariant,
  Handle,
  Position,
  useReactFlow,
} from "@xyflow/react";
import "@xyflow/react/dist/style.css";

// Import extracted components
import TopBar from "./components/TopBar";
import NodeLibraryPanel from "./components/NodeLibraryPanel";
import ConfigurationPanel from "./components/ConfigurationPanel";
import ExecutionPanel from "./components/ExecutionPanel";
import ChatButton from "./components/ChatButton";
import ChatPanel from "./components/ChatPanel";
import {
  AutomationProvider,
  useAutomationContext,
} from "./context/AutomationContext";

// ============================================
// TYPE DEFINITIONS
// ============================================

interface NodeData {
  label: string;
  subtype?: string;
  icon?: string;
  description?: string;
  config?: Record<string, unknown>;
  status?: "idle" | "running" | "success" | "error";
  lastRun?: string;
  executionResult?: Record<string, unknown>;
  colorClass?: string;
  borderClass?: string;
  selectedBorderClass?: string;
}

// ------------------------------------------------
// NODE-ID UTIL
// ------------------------------------------------
const nextNodeId = (existing: Node[], base: string) => {
  // base = webhook_trigger   ‚Üí  webhook_trigger-1, -2, ‚Ä¶
  const re = new RegExp(`^${base}-(\\d+)$`);
  const max = existing.reduce((highest, n) => {
    const m = n.id.match(re);
    return m ? Math.max(highest, Number(m[1])) : highest;
  }, 0);
  return `${base}-${max + 1}`;
};

// ============================================
// CUSTOM NODE COMPONENTS
// ============================================

const BaseNode = ({
  data,
  selected,
  icon,
}: {
  data: NodeData;
  selected: boolean;
  icon: string;
}) => {
  const getStatusIndicator = () => {
    switch (data.status) {
      case "running":
        return <div className="w-2 h-2 bg-black rounded-full animate-pulse" />;
      case "success":
        return <div className="w-2 h-2 bg-green-500 rounded-full" />;
      case "error":
        return <div className="w-2 h-2 bg-red-500 rounded-full" />;
      default:
        return <div className="w-2 h-2 bg-gray-300 rounded-full" />;
    }
  };

  const getIconComponent = () => {
    const colorClass = data.colorClass || "text-[var(--foreground)]";
    return getIcon(icon, "w-5 h-5", colorClass);
  };

  const getBorderClasses = () => {
    if (selected) {
      return (
        data.selectedBorderClass ||
        "border-2 border-blue-500 dark:border-blue-400 shadow-xl ring-2 ring-blue-500/30 dark:ring-blue-400/30 bg-blue-50/50 dark:bg-blue-950/20"
      );
    } else {
      return (
        data.borderClass ||
        "border border-gray-200 dark:border-gray-700 hover:border-gray-300 dark:hover:border-gray-600"
      );
    }
  };

  return (
    <div
      className={`
        relative bg-[var(--card)] rounded-xl shadow-sm border transition-all duration-200
        min-w-[180px] px-5 py-4 group hover:shadow-md
        ${getBorderClasses()}
        ${data.status === "running" ? "animate-pulse" : ""}
      `}
    >
      {/* Only show left handle for non-trigger nodes or triggers that support input */}
      {data.subtype !== "manual_trigger" &&
        data.subtype !== "webhook_trigger" &&
        data.subtype !== "schedule_trigger" && (
          <Handle
            type="target"
            position={Position.Left}
            style={{
              background: "#6b7280",
              width: 12,
              height: 12,
              border: "2px solid white",
              boxShadow: "0 2px 4px rgba(0,0,0,0.1)",
            }}
            className="hover:bg-gray-600 transition-colors"
          />
        )}
      <Handle
        type="source"
        position={Position.Right}
        style={{
          background: "#6b7280",
          width: 12,
          height: 12,
          border: "2px solid white",
          boxShadow: "0 2px 4px rgba(0,0,0,0.1)",
        }}
        className="hover:bg-gray-600 transition-colors"
      />
      {/* Status indicator */}
      <div className="absolute top-3 right-3">{getStatusIndicator()}</div>

      {/* Content */}
      <div className="pr-6">
        <div className="flex items-center gap-3 mb-2">
          {getIconComponent()}
          <h3 className="font-medium text-[var(--foreground)] leading-tight">
            {data.label}
          </h3>
        </div>

        <p className="text-sm text-[var(--muted-foreground)] leading-relaxed max-w-[200px] break-words">
          {data.description || "Not configured"}
        </p>

        {data.lastRun && (
          <p className="text-xs text-[var(--muted-foreground)] mt-2">
            {data.lastRun}
          </p>
        )}
      </div>
    </div>
  );
};

const TriggerNode = ({
  data,
  selected,
}: {
  data: NodeData;
  selected: boolean;
}) => <BaseNode data={data} selected={selected} icon={data.icon || "zap"} />;

const ActionNode = ({
  data,
  selected,
}: {
  data: NodeData;
  selected: boolean;
}) => <BaseNode data={data} selected={selected} icon={data.icon || "circle"} />;

const ConditionNode = ({
  data,
  selected,
}: {
  data: NodeData;
  selected: boolean;
}) => (
  <BaseNode data={data} selected={selected} icon={data.icon || "diamond"} />
);

const BranchNode = ({
  data,
  selected,
}: {
  data: NodeData;
  selected: boolean;
}) => {
  const getStatusIndicator = () => {
    switch (data.status) {
      case "running":
        return <div className="w-2 h-2 bg-black rounded-full animate-pulse" />;
      case "success":
        return <div className="w-2 h-2 bg-green-500 rounded-full" />;
      case "error":
        return <div className="w-2 h-2 bg-red-500 rounded-full" />;
      default:
        return <div className="w-2 h-2 bg-gray-300 rounded-full" />;
    }
  };

  const getIconComponent = () => {
    const colorClass = data.colorClass || "text-[var(--foreground)]";
    return getIcon(data.icon || "diamond", "w-5 h-5", colorClass);
  };

  const getBorderClasses = () => {
    if (selected) {
      return (
        data.selectedBorderClass ||
        "border-2 border-blue-500 dark:border-blue-400 shadow-xl ring-2 ring-blue-500/30 dark:ring-blue-400/30 bg-blue-50/50 dark:bg-blue-950/20"
      );
    } else {
      return (
        data.borderClass ||
        "border border-gray-200 dark:border-gray-700 hover:border-gray-300 dark:hover:border-gray-600"
      );
    }
  };

  return (
    <div
      className={`
        relative bg-[var(--card)] rounded-xl shadow-sm border transition-all duration-200
        min-w-[180px] px-5 py-4 group hover:shadow-md
        ${getBorderClasses()}
        ${data.status === "running" ? "animate-pulse" : ""}
      `}
    >
      {/* Input handle */}
      <Handle
        type="target"
        position={Position.Left}
        style={{
          background: "#6b7280",
          width: 12,
          height: 12,
          border: "2px solid white",
          boxShadow: "0 2px 4px rgba(0,0,0,0.1)",
        }}
        className="hover:bg-gray-600 transition-colors"
      />

      {/* True output handle */}
      <Handle
        type="source"
        position={Position.Right}
        id="true"
        style={{
          background: "#22c55e",
          width: 12,
          height: 12,
          border: "2px solid white",
          boxShadow: "0 2px 4px rgba(0,0,0,0.1)",
          top: "40%",
        }}
        className="hover:bg-green-600 transition-colors"
      />
      {/* False output handle */}
      <Handle
        type="source"
        position={Position.Right}
        id="false"
        style={{
          background: "#ef4444",
          width: 12,
          height: 12,
          border: "2px solid white",
          boxShadow: "0 2px 4px rgba(0,0,0,0.1)",
          top: "60%",
        }}
        className="hover:bg-red-600 transition-colors"
      />

      {/* Status indicator */}
      <div className="absolute top-3 right-3">{getStatusIndicator()}</div>

      {/* Content */}
      <div className="pr-6">
        <div className="flex items-center gap-3 mb-2">
          {getIconComponent()}
          <h3 className="font-medium text-[var(--foreground)] leading-tight">
            {data.label}
          </h3>
        </div>

        <p className="text-sm text-[var(--muted-foreground)] leading-relaxed max-w-[200px] break-words">
          {data.description || "Not configured"}
        </p>

        {data.lastRun && (
          <p className="text-xs text-[var(--muted-foreground)] mt-2">
            {data.lastRun}
          </p>
        )}
      </div>
    </div>
  );
};

// Register custom node types
const nodeTypes: NodeTypes = {
  trigger: TriggerNode,
  action: ActionNode,
  condition: ConditionNode,
  logic: (props) => {
    if (props.data.subtype === "branch_condition") {
      return <BranchNode {...props} />;
    }
    return <ConditionNode {...props} />;
  },
};

// ============================================
// MAIN APP COMPONENT
// ============================================

function WorkflowEditorContent() {
  const { theme } = useThemeToggle();
  const { screenToFlowPosition } = useReactFlow();
  const connectionLineStyle = { stroke: "#d1d5db", strokeWidth: 2 };
  const searchParams = useSearchParams();
  const automationId = searchParams.get("id");

  // Get state from context
  const {
    nodes,
    edges,
    selectedNode,
    sidebarOpen,
    showExecutionPanel,
    showChatPanel,
    setNodes,
    setEdges,
    setSelectedNode,
    setShowExecutionPanel,
    setShowChatPanel,
    setWorkflowName,
    setCurrentWorkflowId,
    restoreLatestExecution,
    restoreExecutionState,
    openSidebar,
    openChatPanel,
  } = useAutomationContext();

  // Load automation from URL parameter
  useEffect(() => {
    const loadAutomationFromUrl = async () => {
      if (automationId) {
        try {
          const response = await fetch("/api/automations");
          if (response.ok) {
            const automations = await response.json();
            const automation = automations.find(
              (a: { id: string }) => a.id === automationId
            );
            if (automation) {
              setNodes(automation.nodes || []);
              setEdges(automation.edges || []);
              setWorkflowName(automation.name);
              setCurrentWorkflowId(automation.id);

              try {
                const restoredExecution = await restoreLatestExecution(
                  automation.id
                );

                if (restoredExecution) {
                  console.log("‚úÖ Execution state restored from database");

                  // Restore visual node states
                  if (restoredExecution.steps) {
                    restoreExecutionState(
                      automation.nodes || [],
                      restoredExecution.steps,
                      (
                        nodeId: string,
                        status: "idle" | "running" | "success" | "error",
                        lastRun?: string,
                        executionResult?: Record<string, unknown>
                      ) => {
                        // Update node visual states
                        setNodes((currentNodes) =>
                          currentNodes.map((node) =>
                            node.id === nodeId
                              ? {
                                  ...node,
                                  data: {
                                    ...node.data,
                                    status,
                                    lastRun,
                                    executionResult,
                                  },
                                }
                              : node
                          )
                        );
                      }
                    );
                  }
                } else {
                  console.log(
                    "‚ÑπÔ∏è No previous execution found for this workflow"
                  );
                }
              } catch (error) {
                console.error("Failed to restore execution state:", error);
              }
            }
          }
        } catch (error) {
          console.error("Failed to load automation:", error);
        }
      } else {
        // Clear everything for new automation
        setNodes([]);
        setEdges([]);
        setWorkflowName("Untitled Workflow");
        setCurrentWorkflowId(null);
      }
    };

    loadAutomationFromUrl();
  }, [
    automationId,
    setNodes,
    setEdges,
    setWorkflowName,
    setCurrentWorkflowId,
    restoreLatestExecution,
    restoreExecutionState,
  ]);

  // ============================================
  // REACTFLOW EVENT HANDLERS
  // ============================================

  const onNodesChange = useCallback(
    (changes: NodeChange[]) => {
      setNodes((nds: Node[]) => applyNodeChanges(changes, nds));
    },
    [setNodes]
  );

  const onEdgesChange = useCallback(
    (changes: EdgeChange[]) => {
      setEdges((eds: Edge[]) => applyEdgeChanges(changes, eds));
    },
    [setEdges]
  );

  const onConnect = useCallback(
    (params: Connection) => {
      setEdges((eds: Edge[]) =>
        addEdge(
          {
            ...params,
            id: `${params.source}-${params.sourceHandle || "default"}-${
              params.target
            }`,
            style: {
              stroke:
                params.sourceHandle === "true"
                  ? "#22c55e"
                  : params.sourceHandle === "false"
                  ? "#ef4444"
                  : "#d1d5db",
              strokeWidth: 2,
            },
            animated: false,
          } as Edge,
          eds
        )
      );
    },
    [setEdges]
  );

  const onNodeClick = useCallback(
    (_event: React.MouseEvent, node: Node) => {
      setSelectedNode(node);
      // Close execution panel when a node is clicked
      setShowExecutionPanel(false);
    },
    [setSelectedNode, setShowExecutionPanel]
  );

  const onSelectionChange = useCallback(
    ({ nodes }: { nodes: Node[] }) => {
      // If no nodes are selected, clear the selectedNode
      if (nodes.length === 0) {
        setSelectedNode(null);
      }
    },
    [setSelectedNode]
  );

  // ============================================
  // DRAG & DROP FUNCTIONALITY
  // ============================================

  const onDragOver = useCallback((event: DragEvent) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = "move";
  }, []);

  const onDrop = useCallback(
    (event: DragEvent) => {
      event.preventDefault();

      // Check if it's a template first
      const templateData = event.dataTransfer.getData(
        "application/reactflow/template"
      );
      if (templateData) {
        const template: WorkflowTemplate = JSON.parse(templateData);

        // Convert screen coordinates to flow coordinates
        const position = screenToFlowPosition({
          x: event.clientX,
          y: event.clientY,
        });

        /* ---------- keep ids from the template ----------- */
        const idMap = new Map<string, string>();
        template.nodes.forEach((n) => {
          // only change the id if it already exists on the canvas
          const clash = nodes.find((x) => x.id === n.id);
          if (clash) {
            idMap.set(n.id, nextNodeId(nodes, n.data.subtype || n.type));
          } else {
            idMap.set(n.id, n.id);
          }
        });

        /* ---------- offset positions so the group lands where the user dropped it --------- */
        const templateBounds = template.nodes.reduce(
          (b, n) => ({
            minX: Math.min(b.minX, n.position.x),
            minY: Math.min(b.minY, n.position.y),
          }),
          { minX: Infinity, minY: Infinity }
        );

        const newNodes = template.nodes.map((n) => ({
          id: idMap.get(n.id)!,
          type: n.type,
          position: {
            x: position.x + (n.position.x - templateBounds.minX),
            y: position.y + (n.position.y - templateBounds.minY),
          },
          data: { ...n.data },
        }));

        const newEdges = template.edges.map((e) => ({
          id: `${idMap.get(e.source)}-${
            e.sourceHandle || "default"
          }-${idMap.get(e.target)}`,
          source: idMap.get(e.source)!,
          target: idMap.get(e.target)!,
          sourceHandle: e.sourceHandle,
          style: {
            stroke:
              e.sourceHandle === "true"
                ? "#22c55e"
                : e.sourceHandle === "false"
                ? "#ef4444"
                : "#d1d5db",
            strokeWidth: 2,
          },
          animated: false,
        }));

        // Add template nodes and edges to existing workflow
        setNodes((nds: Node[]) => [...nds, ...newNodes]);
        setEdges((eds: Edge[]) => [...eds, ...newEdges]);

        return;
      }

      // Original single node drop logic
      const nodeData = event.dataTransfer.getData("application/reactflow");
      if (!nodeData) return;

      const {
        type,
        label,
        subtype,
        icon,
        description,
        colorClass,
        borderClass,
        selectedBorderClass,
      } = JSON.parse(nodeData);

      // Convert screen coordinates to flow coordinates (accounts for zoom and pan)
      const position = screenToFlowPosition({
        x: event.clientX,
        y: event.clientY,
      });

      const newNode: Node = {
        id: nextNodeId(nodes, subtype || type),
        type,
        position,
        data: {
          label,
          subtype, // This is now the integration ID
          icon,
          description,
          status: "idle",
          colorClass,
          borderClass,
          selectedBorderClass,
          config: { integrationId: subtype }, // Add this line
        },
      };

      setNodes((nds: Node[]) => [...nds, newNode]);
    },
    [screenToFlowPosition, setNodes, setEdges, nodes]
  );

  // ============================================
  // RENDER
  // ============================================

  return (
    <div className="flex flex-col h-screen bg-[var(--background)]">
      <TopBar />

      <div className="flex-1 flex overflow-hidden">
        <NodeLibraryPanel />

        {/* MAIN CONTENT AREA */}
        <div className="flex-1 relative">
          {!sidebarOpen && (
            <button
              onClick={openSidebar}
              className="absolute top-6 left-6 z-10 p-3 bg-[var(--primary)] rounded-xl shadow-lg hover:bg-[var(--primary)]/90 transition-colors"
            >
              {getIcon("plus", "w-6 h-6", "text-[var(--primary-foreground)]")}
            </button>
          )}
          <div className="relative w-full h-full">
            <ReactFlow
              nodes={nodes}
              edges={edges}
              onNodesChange={onNodesChange}
              onEdgesChange={onEdgesChange}
              onConnect={onConnect}
              onNodeClick={onNodeClick}
              onSelectionChange={onSelectionChange}
              onDrop={onDrop}
              onDragOver={onDragOver}
              nodeTypes={nodeTypes}
              defaultViewport={{ x: 0, y: 0, zoom: 0.8 }}
              className="bg-[var(--background)]"
              connectionLineStyle={connectionLineStyle}
              defaultEdgeOptions={{
                style: { stroke: "#d1d5db", strokeWidth: 2 },
                animated: false,
              }}
              panOnDrag
              elementsSelectable
              nodesConnectable
              nodesDraggable
              proOptions={{ hideAttribution: true }}
            >
              <Background
                color={theme === "dark" ? "#6b7280" : "#d1d5db"}
                gap={20}
                size={theme === "dark" ? 1.5 : 2}
                variant={BackgroundVariant.Dots}
              />
            </ReactFlow>
          </div>
        </div>

        {/* RIGHT SIDEBAR - Configuration or Execution Panel */}
        {(selectedNode || showExecutionPanel) && (
          <div className="w-80 bg-[var(--card)] border-l border-[var(--border)] overflow-y-auto z-[60]">
            <div className="p-6">
              {showExecutionPanel ? (
                <ExecutionPanel />
              ) : (
                selectedNode && <ConfigurationPanel />
              )}
            </div>
          </div>
        )}

        {/* Chat Panel */}
        <ChatPanel
          isOpen={showChatPanel}
          onClose={() => setShowChatPanel(false)}
        />
      </div>

      {/* Chat Button */}
      <ChatButton onClick={openChatPanel} />
    </div>
  );
}

function WorkflowEditor() {
  return (
    <AutomationProvider>
      <WorkflowEditorContent />
    </AutomationProvider>
  );
}

export default function App() {
  useEffect(() => {
    fetch("/api/init", { method: "POST" }).catch(console.error);
  }, []);

  return (
    <ReactFlowProvider>
      <Suspense fallback={<div>Loading...</div>}>
        <WorkflowEditor />
      </Suspense>
    </ReactFlowProvider>
  );
}

----- Content End -----

===== File: app/editor/context/AutomationContext.tsx =====
Type: .tsx
----- Content Start -----
"use client";

import React, {
  createContext,
  useContext,
  ReactNode,
  useState,
  useCallback,
  useEffect,
} from "react";
import { Node, Edge } from "@xyflow/react";
import { integrationRegistry } from "../../../lib/integrations/registry";
import type { Integration } from "../../../lib/integrations/types";
import {
  workflowTemplates,
  type WorkflowTemplate,
} from "../../../lib/integrations/templates";
import { useEditor } from "../hooks/useEditor";

// ------------------------------------------------
// NODE-ID UTIL
// ------------------------------------------------
const nextNodeId = (existing: Node[], base: string) => {
  // base = webhook_trigger   ‚Üí  webhook_trigger-1, -2, ‚Ä¶
  const re = new RegExp(`^${base}-(\\d+)$`);
  const max = existing.reduce((highest, n) => {
    const m = n.id.match(re);
    return m ? Math.max(highest, Number(m[1])) : highest;
  }, 0);
  return `${base}-${max + 1}`;
};

interface ExecutionStep {
  node_id: string;
  status: string;
  completed_at?: string;
  result?: {
    success: boolean;
    data?: Record<string, unknown>;
    metadata?: {
      nodeType: string;
      subtype: string;
      [key: string]: unknown;
    };
    [key: string]: unknown;
  };
}

interface ExecutionState {
  status: "idle" | "running" | "completed" | "failed";
  context: {
    variables: Record<string, unknown>;
    nodeOutputs: Record<string, unknown>;
  };
  currentNode: string | null;
}

interface AutomationContextType {
  // Workflow state
  nodes: Node[];
  edges: Edge[];
  selectedNode: Node | null;
  workflowName: string;
  isEditingTitle: boolean;
  sidebarOpen: boolean;
  showExecutionPanel: boolean;
  showChatPanel: boolean;
  copiedField: string | null;
  currentWorkflowId: string | null;
  setNodes: (updater: Node[] | ((prev: Node[]) => Node[])) => void;
  setEdges: (updater: Edge[] | ((prev: Edge[]) => Edge[])) => void;
  setSelectedNode: (node: Node | null) => void;
  setWorkflowName: (name: string) => void;
  setIsEditingTitle: (editing: boolean) => void;
  setSidebarOpen: (open: boolean) => void;
  setShowExecutionPanel: (show: boolean) => void;
  setShowChatPanel: (show: boolean) => void;
  setCopiedField: (field: string | null) => void;
  setCurrentWorkflowId: (id: string | null) => void;

  // Panel management
  openSidebar: () => void;
  openChatPanel: () => void;
  closeAllPanels: () => void;

  // Operations
  getIntegration: (id: string) => Integration | undefined;
  getTriggerIntegrations: () => Integration[];
  getActionIntegrations: () => Integration[];
  getLogicIntegrations: () => Integration[];
  updateNodeConfig: (nodeId: string, config: Record<string, unknown>) => void;
  deleteSelectedNode: () => void;
  copyExpression: (expression: string) => void;
  copyDataFieldExpressionWithFeedback: (
    nodeId: string,
    fieldKey: string
  ) => void;
  handleTitleEdit: () => void;
  handleTitleSave: () => void;
  handleTitleKeyDown: (e: React.KeyboardEvent) => void;

  // Templates
  getTemplates: () => WorkflowTemplate[];
  applyTemplate: (templateId: string) => void;

  // Execution
  executionState: ExecutionState;
  isExecuting: boolean;
  executeWorkflow: (
    nodes: Node[],
    edges: Edge[],
    onNodeStatusChange: (
      nodeId: string,
      status: "idle" | "running" | "success" | "error",
      lastRun?: string,
      executionResult?: Record<string, unknown>
    ) => void
  ) => Promise<void>;
  saveWorkflow: (
    nodes: Node[],
    edges: Edge[],
    name: string
  ) => Promise<unknown>;
  loadWorkflow: () => Promise<unknown>;
  restoreExecutionState: (
    nodes: Node[],
    steps: ExecutionStep[],
    onNodeStatusChange: (
      nodeId: string,
      status: "idle" | "running" | "success" | "error",
      lastRun?: string,
      executionResult?: Record<string, unknown>
    ) => void
  ) => void;
  restoreLatestExecution: (
    workflowId: string
  ) => Promise<{ execution: unknown; steps: ExecutionStep[] } | null>;

  // Auto-save state
  isSaving: boolean;
  lastSaveError: string | null;
}

const AutomationContext = createContext<AutomationContextType | undefined>(
  undefined
);

export const useAutomationContext = () => {
  const context = useContext(AutomationContext);
  if (context === undefined) {
    throw new Error(
      "useAutomationContext must be used within a AutomationProvider"
    );
  }
  return context;
};

interface AutomationProviderProps {
  children: ReactNode;
}

export const AutomationProvider = ({ children }: AutomationProviderProps) => {
  // Core workflow state
  const [nodes, setNodes] = useState<Node[]>([]);
  const [edges, setEdges] = useState<Edge[]>([]);
  const [selectedNode, setSelectedNode] = useState<Node | null>(null);

  // UI state
  const [workflowName, setWorkflowName] = useState("Untitled Workflow");
  const [isEditingTitle, setIsEditingTitle] = useState(false);
  const [sidebarOpen, setSidebarOpen] = useState(true);
  const [showExecutionPanel, setShowExecutionPanel] = useState(false);
  const [showChatPanel, setShowChatPanel] = useState(false);

  // Copy state
  const [copiedField, setCopiedField] = useState<string | null>(null);

  // Panel management helpers
  const openSidebar = useCallback(() => {
    setSidebarOpen(true);
    // On mobile, close other panels when sidebar opens
    if (window.innerWidth < 768) {
      setShowChatPanel(false);
      setSelectedNode(null);
      setShowExecutionPanel(false);
    }
  }, []);

  const openChatPanel = useCallback(() => {
    setShowChatPanel(true);
    // On mobile, close other panels when chat opens
    if (window.innerWidth < 768) {
      setSidebarOpen(false);
      setSelectedNode(null);
      setShowExecutionPanel(false);
    }
  }, []);

  const closeAllPanels = useCallback(() => {
    setSidebarOpen(false);
    setShowChatPanel(false);
    setSelectedNode(null);
    setShowExecutionPanel(false);
  }, []);

  // Current workflow ID
  const [currentWorkflowId, setCurrentWorkflowId] = useState<string | null>(
    null
  );

  // Auto-save state
  const [isSaving, setIsSaving] = useState(false);
  const [lastSaveError, setLastSaveError] = useState<string | null>(null);

  // Integration helpers
  const getIntegration = useCallback((id: string) => {
    return integrationRegistry.get(id);
  }, []);

  const getTriggerIntegrations = useCallback(() => {
    return integrationRegistry.getTriggers();
  }, []);

  const getActionIntegrations = useCallback(() => {
    return integrationRegistry.getActions();
  }, []);

  const getLogicIntegrations = useCallback(() => {
    return integrationRegistry.getLogic();
  }, []);

  // Node operations
  const updateNodeConfig = useCallback(
    (nodeId: string, config: Record<string, unknown>) => {
      setNodes((nds) =>
        nds.map((node) =>
          node.id === nodeId
            ? { ...node, data: { ...node.data, config } }
            : node
        )
      );

      // Also update the selectedNode state to reflect the changes immediately
      if (selectedNode && selectedNode.id === nodeId) {
        setSelectedNode({
          ...selectedNode,
          data: { ...selectedNode.data, config },
        });
      }
    },
    [selectedNode]
  );

  const deleteSelectedNode = useCallback(() => {
    if (!selectedNode) return;
    setNodes((nds) => nds.filter((n) => n.id !== selectedNode.id));
    setEdges((eds) =>
      eds.filter(
        (e) => e.source !== selectedNode.id && e.target !== selectedNode.id
      )
    );
    setSelectedNode(null);
  }, [selectedNode]);

  // Copy operations
  const copyExpression = useCallback((expression: string) => {
    navigator.clipboard.writeText(expression);
  }, []);

  const copyDataFieldExpressionWithFeedback = useCallback(
    (nodeId: string, fieldKey: string) => {
      navigator.clipboard.writeText(`{{$node.${nodeId}.data.${fieldKey}}}`);
      setCopiedField(fieldKey);
      setTimeout(() => setCopiedField(null), 1500);
    },
    []
  );

  // Title operations
  const handleTitleEdit = useCallback(() => {
    setIsEditingTitle(true);
  }, []);

  const handleTitleSave = useCallback(() => {
    setIsEditingTitle(false);
  }, []);

  const handleTitleKeyDown = useCallback(
    (e: React.KeyboardEvent) => {
      if (e.key === "Enter") {
        handleTitleSave();
      } else if (e.key === "Escape") {
        setIsEditingTitle(false);
      }
    },
    [handleTitleSave]
  );

  // Template operations
  const getTemplates = useCallback(() => {
    return workflowTemplates;
  }, []);

  const applyTemplate = useCallback(
    (templateId: string) => {
      const template = workflowTemplates.find((t) => t.id === templateId);
      if (!template) return;

      /* ---------- keep ids from the template ----------- */
      const idMap = new Map<string, string>();
      template.nodes.forEach((n) => {
        // only change the id if it already exists on the canvas
        const clash = nodes.find((x) => x.id === n.id);
        if (clash) {
          idMap.set(n.id, nextNodeId(nodes, n.data.subtype || n.type));
        } else {
          idMap.set(n.id, n.id);
        }
      });

      const newNodes = template.nodes.map((n) => ({
        id: idMap.get(n.id)!,
        type: n.type,
        position: n.position,
        data: { ...n.data },
      }));

      const newEdges = template.edges.map((e) => ({
        id: `${idMap.get(e.source)}-${idMap.get(e.target)}`,
        source: idMap.get(e.source)!,
        target: idMap.get(e.target)!,
        style: { stroke: "#d1d5db", strokeWidth: 2 },
        animated: false,
      }));

      // Replace current workflow with template
      setNodes(newNodes);
      setEdges(newEdges);
      setWorkflowName(template.name);
    },
    [setNodes, setEdges, setWorkflowName, nodes]
  );

  // Execution logic from useExecution hook
  const {
    executionState,
    isExecuting,
    saveWorkflow: saveWorkflowAPI,
    loadWorkflow: loadWorkflowAPI,
    executeWorkflow: executeWorkflowAPI,
    restoreNodeStates,
    restoreLatestExecution,
  } = useEditor(currentWorkflowId);

  // Auto-save functionality
  useEffect(() => {
    // Only auto-save if we have nodes or edges and a workflow name
    if ((nodes.length > 0 || edges.length > 0) && workflowName.trim()) {
      const timeoutId = setTimeout(async () => {
        try {
          setIsSaving(true);
          setLastSaveError(null);
          console.log("Auto-saving workflow...", {
            nodes: nodes.length,
            edges: edges.length,
          });

          const result = await saveWorkflowAPI(nodes, edges, workflowName);

          // Update currentWorkflowId if this is a new workflow
          if (
            result &&
            typeof result === "object" &&
            "id" in result &&
            !currentWorkflowId
          ) {
            setCurrentWorkflowId(result.id as string);
            // Update URL to reflect the new automation ID
            window.history.replaceState({}, "", `/editor?id=${result.id}`);
          }

          console.log("Auto-save successful");
        } catch (error) {
          console.error("Auto-save failed:", error);
          setLastSaveError(
            error instanceof Error ? error.message : "Save failed"
          );
        } finally {
          setIsSaving(false);
        }
      }, 2000); // Save 2 seconds after changes stop

      return () => clearTimeout(timeoutId);
    }
  }, [nodes, edges, workflowName, saveWorkflowAPI, currentWorkflowId]);

  const executeWorkflow = useCallback(
    async (
      nodes: Node[],
      edges: Edge[],
      onNodeStatusChange: (
        nodeId: string,
        status: "idle" | "running" | "success" | "error",
        lastRun?: string,
        executionResult?: Record<string, unknown>
      ) => void
    ) => {
      await executeWorkflowAPI(nodes, edges, onNodeStatusChange);
    },
    [executeWorkflowAPI]
  );

  const saveWorkflow = useCallback(
    async (nodes: Node[], edges: Edge[], name: string) => {
      const result = await saveWorkflowAPI(nodes, edges, name);
      if (
        result &&
        typeof result === "object" &&
        "id" in result &&
        !currentWorkflowId
      ) {
        setCurrentWorkflowId(result.id as string);
      }
      return result;
    },
    [saveWorkflowAPI, currentWorkflowId, setCurrentWorkflowId]
  );

  const loadWorkflow = useCallback(async () => {
    return await loadWorkflowAPI();
  }, [loadWorkflowAPI]);

  const restoreExecutionState = useCallback(
    (
      nodes: Node[],
      steps: ExecutionStep[],
      onNodeStatusChange: (
        nodeId: string,
        status: "idle" | "running" | "success" | "error",
        lastRun?: string,
        executionResult?: Record<string, unknown>
      ) => void
    ) => {
      restoreNodeStates(nodes, steps, onNodeStatusChange);
    },
    [restoreNodeStates]
  );

  // Create wrapper functions that handle the type conversion
  const setNodesWrapper = useCallback(
    (updater: Node[] | ((prev: Node[]) => Node[])) => {
      setNodes(updater);
    },
    []
  );

  const setEdgesWrapper = useCallback(
    (updater: Edge[] | ((prev: Edge[]) => Edge[])) => {
      setEdges(updater);
    },
    []
  );

  const value = {
    // State
    nodes,
    setNodes: setNodesWrapper,
    edges,
    setEdges: setEdgesWrapper,
    selectedNode,
    setSelectedNode,
    workflowName,
    setWorkflowName,
    isEditingTitle,
    setIsEditingTitle,
    sidebarOpen,
    setSidebarOpen,
    showExecutionPanel,
    setShowExecutionPanel,
    showChatPanel,
    setShowChatPanel,
    copiedField,
    setCopiedField,
    currentWorkflowId,
    setCurrentWorkflowId,
    isSaving,
    lastSaveError,

    // Operations
    getIntegration,
    getTriggerIntegrations,
    getActionIntegrations,
    getLogicIntegrations,
    updateNodeConfig,
    deleteSelectedNode,
    copyExpression,
    copyDataFieldExpressionWithFeedback,
    handleTitleEdit,
    handleTitleSave,
    handleTitleKeyDown,

    // Templates
    getTemplates,
    applyTemplate,

    // Execution
    executionState,
    isExecuting,
    executeWorkflow,
    saveWorkflow,
    loadWorkflow,
    restoreExecutionState,
    restoreLatestExecution,

    // Panel management
    openSidebar,
    openChatPanel,
    closeAllPanels,
  };

  return (
    <AutomationContext.Provider value={value}>
      {children}
    </AutomationContext.Provider>
  );
};

----- Content End -----

===== File: app/editor/components/ChatButton.tsx =====
Type: .tsx
----- Content Start -----
"use client";

import { Bot } from "lucide-react";

interface ChatButtonProps {
  onClick: () => void;
  hasUnread?: boolean;
}

const ChatButton = ({ onClick, hasUnread = false }: ChatButtonProps) => {
  return (
    <button
      onClick={onClick}
      className="fixed bottom-6 right-6 z-50 p-4 bg-[var(--primary)] text-[var(--primary-foreground)] rounded-full shadow-lg hover:shadow-xl transition-all duration-200 hover:scale-105"
      title="Chat with AI Assistant"
    >
      <Bot className="w-6 h-6" />
      {hasUnread && (
        <div className="absolute -top-1 -right-1 w-3 h-3 bg-red-500 rounded-full"></div>
      )}
    </button>
  );
};

export default ChatButton;

----- Content End -----

===== File: app/editor/components/TopBar.tsx =====
Type: .tsx
----- Content Start -----
"use client";

import Link from "next/link";
import { Loader2, CheckCircle, AlertCircle } from "lucide-react";
import { getIcon } from "../../../hooks/useIcons";
import { useAutomationContext } from "../context/AutomationContext";
import { useThemeToggle } from "../../../hooks/useThemeToggle";
import { useState } from "react";
import { Node } from "@xyflow/react";

const TopBar = () => {
  const {
    workflowName,
    isEditingTitle,
    nodes,
    edges,
    isExecuting,
    isSaving,
    lastSaveError,
    showExecutionPanel,
    setWorkflowName,
    setNodes,
    setShowExecutionPanel,
    handleTitleEdit,
    handleTitleSave,
    handleTitleKeyDown,
    executeWorkflow,
    saveWorkflow,
  } = useAutomationContext();

  const [showSaveSuccess, setShowSaveSuccess] = useState(false);
  const { theme, toggleTheme, mounted } = useThemeToggle();

  const handleExecuteWorkflow = async () => {
    const onNodeStatusChange = (
      nodeId: string,
      status: "idle" | "running" | "success" | "error",
      lastRun?: string,
      executionResult?: Record<string, unknown>
    ) => {
      // Update the node status in the nodes array
      setNodes((prevNodes: Node[]) =>
        prevNodes.map((node: Node) =>
          node.id === nodeId
            ? {
                ...node,
                data: {
                  ...node.data,
                  status,
                  lastRun,
                  executionResult,
                },
              }
            : node
        )
      );
    };

    setShowExecutionPanel(true);
    await executeWorkflow(nodes, edges, onNodeStatusChange);
  };

  const handleManualSave = async () => {
    try {
      await saveWorkflow(nodes, edges, workflowName);
      setShowSaveSuccess(true);
      setTimeout(() => setShowSaveSuccess(false), 2000); // Hide after 2 seconds
    } catch (error) {
      console.error("Manual save failed:", error);
    }
  };

  return (
    <div className="bg-[var(--card)] border-b border-[var(--border)] px-3 sm:px-6 py-3 sm:py-4">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2 sm:gap-4">
          {/* Home Button */}
          <Link
            href="/"
            className="p-2 hover:bg-[var(--muted)] rounded-lg transition-colors"
            aria-label="Go to home"
          >
            {getIcon("dashboard", "w-6 h-6", "text-[var(--foreground)]")}
          </Link>

          <div className="flex items-center gap-2 sm:gap-3">
            {isEditingTitle ? (
              <input
                type="text"
                value={workflowName}
                onChange={(e) => setWorkflowName(e.target.value)}
                onBlur={handleTitleSave}
                onKeyDown={handleTitleKeyDown}
                className="text-lg sm:text-xl font-semibold text-[var(--foreground)] bg-[var(--card)] border border-[var(--border)] rounded-md shadow-sm focus:border-[var(--ring)] focus:ring-1 focus:ring-[var(--ring)] focus:outline-none px-2 sm:px-3 py-1"
                autoFocus
              />
            ) : (
              <h1
                className="text-lg sm:text-xl font-semibold text-[var(--foreground)] cursor-pointer hover:text-[var(--muted-foreground)] transition-colors px-1 py-0.5 rounded"
                onClick={handleTitleEdit}
                title="Click to edit title"
              >
                {workflowName}
              </h1>
            )}

            {/* Auto-save status indicator */}
            <div className="flex items-center gap-1 sm:gap-2">
              {isSaving && (
                <div className="flex items-center gap-1 text-xs sm:text-sm text-[var(--muted-foreground)]">
                  <Loader2 className="w-3 h-3 animate-spin" />
                  <span className="hidden sm:inline">Saving...</span>
                </div>
              )}
              {lastSaveError && (
                <div
                  className="flex items-center gap-1 text-xs sm:text-sm text-red-600 dark:text-red-400"
                  title={lastSaveError}
                >
                  <AlertCircle className="w-3 h-3" />
                  <span className="hidden sm:inline">Save failed</span>
                </div>
              )}
            </div>
          </div>
        </div>

        {/* Action Buttons */}
        <div className="flex items-center gap-2 sm:gap-3">
          {mounted && (
            <button
              onClick={toggleTheme}
              className="p-2 text-[var(--foreground)] hover:bg-[var(--muted)] rounded-lg transition-colors"
              aria-label="Toggle theme"
            >
              {theme === "dark" ? (
                <svg
                  className="w-5 h-5"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"
                  />
                </svg>
              ) : (
                <svg
                  className="w-5 h-5"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"
                  />
                </svg>
              )}
            </button>
          )}

          <button
            onClick={() => setShowExecutionPanel(!showExecutionPanel)}
            className="p-2 text-[var(--foreground)] hover:bg-[var(--muted)] rounded-lg transition-colors"
            title="View execution details"
          >
            {getIcon("activity", "w-4 h-4")}
          </button>

          <button
            onClick={handleManualSave}
            disabled={isSaving}
            className={`px-2 sm:px-3 py-2 text-xs sm:text-sm font-medium rounded-lg transition-colors min-w-[60px] sm:min-w-[80px] ${
              isSaving
                ? "bg-[var(--muted)] text-[var(--muted-foreground)] cursor-not-allowed"
                : showSaveSuccess
                ? "bg-green-100 text-green-800 dark:bg-green-900/20 dark:text-green-400 cursor-not-allowed"
                : "bg-[var(--secondary)] text-[var(--secondary-foreground)] hover:bg-[var(--secondary)]/80"
            }`}
            title="Save workflow"
            aria-label="Save workflow"
          >
            {isSaving ? (
              <div className="flex items-center justify-center">
                <Loader2 className="w-4 h-4 sm:mr-2 animate-spin" />
                <span className="hidden sm:inline">Saving...</span>
              </div>
            ) : showSaveSuccess ? (
              <div className="flex items-center justify-center">
                <CheckCircle className="w-4 h-4 sm:mr-2" />
                <span className="hidden sm:inline">Saved!</span>
              </div>
            ) : (
              <div className="flex items-center justify-center">
                {getIcon("save", "w-4 h-4", "sm:mr-2")}
                <span className="hidden sm:inline">Save</span>
              </div>
            )}
          </button>
          <button
            onClick={handleExecuteWorkflow}
            disabled={isExecuting}
            className={`px-3 sm:px-4 py-2 text-xs sm:text-sm font-medium rounded-lg transition-colors ${
              isExecuting
                ? "bg-[var(--muted)] text-[var(--muted-foreground)] cursor-not-allowed"
                : "bg-[var(--primary)] text-[var(--primary-foreground)] hover:bg-[var(--primary)]/90"
            }`}
          >
            {isExecuting ? (
              <div className="flex items-center justify-center">
                <Loader2 className="w-4 h-4 sm:mr-2 animate-spin" />
                <span className="hidden sm:inline">Running...</span>
              </div>
            ) : (
              <div className="flex items-center justify-center">
                {getIcon("play", "w-4 h-4", "sm:mr-2")}
                <span className="hidden sm:inline">Run</span>
              </div>
            )}
          </button>
        </div>
      </div>
    </div>
  );
};

export default TopBar;

----- Content End -----

===== File: app/editor/components/ConfigurationPanel.tsx =====
Type: .tsx
----- Content Start -----
"use client";

import { getIcon } from "../../../hooks/useIcons";
import { Copy as CopyIcon } from "lucide-react";
import { useAutomationContext } from "../context/AutomationContext";
import type { SchemaField } from "../../../lib/integrations/types";

interface NodeData {
  label: string;
  subtype?: string;
  icon?: string;
  description?: string;
  config?: Record<string, unknown>;
  status?: "idle" | "running" | "success" | "error";
  lastRun?: string;
  executionResult?: Record<string, unknown>;
  colorClass?: string;
  borderClass?: string;
  selectedBorderClass?: string;
}

const ConfigurationPanel = () => {
  const {
    selectedNode,
    executionState,
    copiedField,
    deleteSelectedNode,
    updateNodeConfig,
    getIntegration,
    copyExpression,
    copyDataFieldExpressionWithFeedback,
  } = useAutomationContext();

  if (!selectedNode) {
    return null;
  }

  const nodeData = selectedNode.data as unknown as NodeData;
  const integrationId = nodeData.subtype;
  const integration = getIntegration(integrationId || "");

  if (!integration) {
    return (
      <div className="text-red-500 text-sm">
        Integration not found: {integrationId}
      </div>
    );
  }

  return (
    <>
      <div className="flex items-center justify-between mb-6">
        <div className="flex items-center gap-3">
          <div className="p-2 bg-[var(--muted)] rounded-lg">
            {getIcon(
              nodeData.icon || "circle",
              "w-5 h-5",
              "text-[var(--muted-foreground)]"
            )}
          </div>
          <div>
            <h2 className="text-lg font-semibold text-[var(--foreground)]">
              {nodeData.label}
            </h2>
            <p className="text-sm text-[var(--muted-foreground)] capitalize">
              {selectedNode.type} step
            </p>
          </div>
        </div>
        <button
          onClick={deleteSelectedNode}
          className="p-2 text-[var(--muted-foreground)] hover:text-red-500 hover:bg-red-500/10 rounded-lg transition-colors"
        >
          {getIcon("trash", "w-4 h-4")}
        </button>
      </div>

      {/* Output Section */}
      {nodeData.executionResult && (
        <div className="mb-6">
          <h3 className="text-sm font-semibold text-[var(--foreground)] mb-3">
            Output
          </h3>
          <div className="flex flex-wrap gap-2">
            {Object.keys(
              (nodeData.executionResult?.data as Record<string, unknown>) || {}
            ).map((fieldKey) => (
              <button
                key={fieldKey}
                onClick={() =>
                  copyDataFieldExpressionWithFeedback(selectedNode.id, fieldKey)
                }
                className={`inline-flex items-center gap-1.5 px-3 py-1.5 text-xs font-medium rounded-lg transition-all duration-200 cursor-pointer shadow-sm ${
                  copiedField === fieldKey
                    ? "bg-green-100 border-green-300 text-green-800 dark:bg-green-900/20 dark:border-green-700 dark:text-green-400"
                    : "text-[var(--foreground)] bg-[var(--card)] border border-[var(--border)] hover:bg-[var(--muted)] hover:border-[var(--ring)]"
                }`}
                title={
                  copiedField === fieldKey
                    ? "Copied!"
                    : "Click to copy reference"
                }
              >
                {copiedField === fieldKey ? (
                  <svg
                    className="w-3 h-3"
                    fill="currentColor"
                    viewBox="0 0 20 20"
                  >
                    <path
                      fillRule="evenodd"
                      d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z"
                      clipRule="evenodd"
                    />
                  </svg>
                ) : (
                  <CopyIcon className="w-3 h-3 text-[var(--muted-foreground)]" />
                )}
                {fieldKey}
              </button>
            ))}
          </div>
        </div>
      )}

      <div className="space-y-6">
        <div className="space-y-4">
          {integration.schema.fields.map((field: SchemaField) => (
            <div key={field.key} className="space-y-3">
              <div>
                <label className="block text-sm font-medium text-[var(--foreground)] select-none">
                  {field.label}
                  {field.required && (
                    <span className="text-red-500 ml-1">*</span>
                  )}
                </label>
              </div>

              {field.type === "select" ? (
                <select
                  className="w-full px-4 py-3 border border-[var(--border)] rounded-xl text-sm focus:outline-none focus:border-[var(--ring)] focus:ring-1 focus:ring-[var(--ring)]/10 transition-all bg-[var(--muted)]/50"
                  value={(nodeData.config?.[field.key] as string) || ""}
                  onChange={(e) => {
                    const currentConfig = nodeData.config || {};
                    updateNodeConfig(selectedNode.id, {
                      ...currentConfig,
                      [field.key]: e.target.value,
                    });
                  }}
                >
                  <option value="">Select {field.label}</option>
                  {Array.isArray(field.options) &&
                    field.options.map(
                      (option: { label: string; value: string }) => (
                        <option key={option.value} value={option.value}>
                          {option.label}
                        </option>
                      )
                    )}
                </select>
              ) : field.type === "textarea" ? (
                <textarea
                  className="w-full px-4 py-3 border border-[var(--border)] rounded-xl text-sm focus:outline-none focus:border-[var(--ring)] focus:ring-1 focus:ring-[var(--ring)]/10 transition-all bg-[var(--muted)]/50 resize-none"
                  rows={3}
                  placeholder={field.placeholder}
                  value={(nodeData.config?.[field.key] as string) || ""}
                  onChange={(e) => {
                    const currentConfig = nodeData.config || {};
                    updateNodeConfig(selectedNode.id, {
                      ...currentConfig,
                      [field.key]: e.target.value,
                    });
                  }}
                />
              ) : (
                <input
                  type={
                    field.type === "number"
                      ? "number"
                      : field.type === "email"
                      ? "email"
                      : field.type === "url"
                      ? "url"
                      : "text"
                  }
                  className="w-full px-4 py-3 border border-[var(--border)] rounded-xl text-sm focus:outline-none focus:border-[var(--ring)] focus:ring-1 focus:ring-[var(--ring)]/10 transition-all bg-[var(--muted)]/50"
                  placeholder={field.placeholder}
                  value={(nodeData.config?.[field.key] as string) || ""}
                  onChange={(e) => {
                    const currentConfig = nodeData.config || {};
                    updateNodeConfig(selectedNode.id, {
                      ...currentConfig,
                      [field.key]: e.target.value,
                    });
                  }}
                />
              )}

              {field.supportExpressions && (
                <p className="text-xs text-[var(--muted-foreground)] mt-1">
                  Use {"{{$node.NodeId.data.field}}"} to reference previous
                  nodes or {"{{$vars.variableName}}"} for variables
                </p>
              )}
            </div>
          ))}
        </div>

        {/* Branch Outputs Section */}
        {nodeData.subtype === "branch_condition" && (
          <div className="mt-6 p-4 bg-[var(--muted)]/50 rounded-lg">
            <h4 className="text-sm font-medium text-[var(--foreground)] mb-2">
              Branch Outputs
            </h4>
            <div className="space-y-2 text-xs text-[var(--muted-foreground)]">
              <div>
                ‚úÖ True path: Connects to nodes that execute when condition is
                true
              </div>
              <div>
                ‚ùå False path: Connects to nodes that execute when condition is
                false
              </div>
            </div>
          </div>
        )}

        {/* Available Data Section */}
        <div className="space-y-4 border-t border-[var(--border)] pt-6">
          <h3 className="text-sm font-semibold text-[var(--foreground)]">
            Available Data
          </h3>

          {/* Previous Node Outputs */}
          {Object.keys(executionState.context.nodeOutputs).length > 0 && (
            <div>
              <h4 className="text-xs font-medium text-[var(--muted-foreground)] mb-2">
                From Previous Nodes:
              </h4>
              <div className="space-y-2 max-h-32 overflow-y-auto">
                {Object.entries(executionState.context.nodeOutputs).map(
                  ([nodeId, output]) => (
                    <div
                      key={nodeId}
                      className="bg-[var(--muted)]/50 rounded p-2"
                    >
                      <button
                        onClick={() =>
                          copyExpression(`{{$node.${nodeId}.data.FIELD}}`)
                        }
                        className="text-xs font-mono text-[var(--foreground)] hover:text-[var(--primary)] cursor-pointer mb-1 block w-full text-left"
                        title="Click to copy"
                      >
                        {`{{$node.${nodeId}.data.FIELD}}`}
                      </button>
                      <div className="text-xs text-[var(--muted-foreground)]">
                        Available fields:{" "}
                        {Object.keys(
                          ((output as Record<string, unknown>)?.data as Record<
                            string,
                            unknown
                          >) || {}
                        ).join(", ") || "none"}
                      </div>
                    </div>
                  )
                )}
              </div>
            </div>
          )}

          {/* Variables */}
          {Object.keys(executionState.context.variables).length > 0 && (
            <div>
              <h4 className="text-xs font-medium text-[var(--muted-foreground)] mb-2">
                Variables:
              </h4>
              <div className="bg-[var(--muted)]/50 rounded p-2">
                {Object.keys(executionState.context.variables).map(
                  (varName) => (
                    <button
                      key={varName}
                      onClick={() => copyExpression(`{{$vars.${varName}}}`)}
                      className="text-xs font-mono text-[var(--foreground)] hover:text-[var(--primary)] cursor-pointer block w-full text-left"
                      title="Click to copy"
                    >
                      {`{{$vars.${varName}}}`}
                    </button>
                  )
                )}
              </div>
            </div>
          )}

          {/* Helpful hint when nothing is available */}
          {Object.keys(executionState.context.nodeOutputs).length === 0 &&
            Object.keys(executionState.context.variables).length === 0 && (
              <div className="text-xs text-[var(--muted-foreground)] italic">
                Run previous nodes to see available data
              </div>
            )}
        </div>
      </div>
    </>
  );
};

export default ConfigurationPanel;

----- Content End -----

===== File: app/editor/components/ExecutionPanel.tsx =====
Type: .tsx
----- Content Start -----
"use client";

import { Loader2 } from "lucide-react";
import { getIcon } from "../../../hooks/useIcons";
import { useAutomationContext } from "../context/AutomationContext";

const ExecutionPanel = () => {
  const { executionState, setShowExecutionPanel } = useAutomationContext();

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between mb-6">
        <h2 className="text-lg font-semibold text-[var(--foreground)]">
          Execution Details
        </h2>
        <button
          onClick={() => setShowExecutionPanel(false)}
          className="p-2 text-[var(--muted-foreground)] hover:bg-[var(--muted)] rounded-lg transition-colors"
        >
          {getIcon("x", "w-4 h-4")}
        </button>
      </div>

      <div
        className={`px-2 py-1 rounded text-xs font-medium mb-4 ${
          executionState.status === "running"
            ? "bg-blue-100 text-blue-800"
            : executionState.status === "completed"
            ? "bg-green-100 text-green-800"
            : executionState.status === "failed"
            ? "bg-red-100 text-red-800"
            : "bg-gray-100 text-gray-800"
        }`}
      >
        {executionState.status}
      </div>

      {/* Variables */}
      <div>
        <h3 className="text-sm font-medium text-[var(--foreground)] mb-2">
          Variables
        </h3>
        <div className="bg-[var(--muted)]/50 rounded-lg p-3 text-xs">
          <pre className="whitespace-pre-wrap text-[var(--muted-foreground)]">
            {Object.keys(executionState.context.variables).length > 0
              ? JSON.stringify(executionState.context.variables, null, 2)
              : "No variables set"}
          </pre>
        </div>
      </div>

      {/* Node Outputs */}
      <div>
        <h3 className="text-sm font-medium text-[var(--foreground)] mb-2">
          Node Outputs
        </h3>
        <div className="space-y-2 max-h-64 overflow-y-auto">
          {Object.keys(executionState.context.nodeOutputs).length === 0 ? (
            <div className="text-xs text-[var(--muted-foreground)] italic">
              No node outputs yet. Run the workflow to see results.
            </div>
          ) : (
            Object.entries(executionState.context.nodeOutputs).map(
              ([nodeId, output]) => (
                <div
                  key={nodeId}
                  className="bg-[var(--muted)]/50 rounded-lg p-3"
                >
                  <div className="flex items-center gap-2 mb-2">
                    <span className="text-xs font-medium text-[var(--foreground)]">
                      {nodeId}
                    </span>
                    {executionState.currentNode === nodeId && (
                      <Loader2 className="w-3 h-3 animate-spin text-blue-500" />
                    )}
                  </div>
                  <pre className="text-xs text-[var(--muted-foreground)] whitespace-pre-wrap">
                    {JSON.stringify(output, null, 2)}
                  </pre>
                </div>
              )
            )
          )}
        </div>
      </div>
    </div>
  );
};

export default ExecutionPanel;

----- Content End -----

===== File: app/editor/components/ChatPanel.tsx =====
Type: .tsx
----- Content Start -----
"use client";

import { useState, useRef, useEffect } from "react";
import { X, Send, Bot, User } from "lucide-react";

interface Message {
  id: string;
  text: string;
  sender: "user" | "ai";
  timestamp: Date;
}

interface ChatPanelProps {
  isOpen: boolean;
  onClose: () => void;
  onOpen?: () => void;
}

const ChatPanel = ({ isOpen, onClose }: ChatPanelProps) => {
  const [messages, setMessages] = useState<Message[]>([
    {
      id: "1",
      text: "Hi! I'm your automation assistant. I can help you build workflows, suggest integrations, and optimize your automations. What would you like to create today?",
      sender: "ai",
      timestamp: new Date(),
    },
  ]);
  const [inputValue, setInputValue] = useState("");
  const [isTyping, setIsTyping] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  const handleSend = async () => {
    if (!inputValue.trim()) return;

    const userMessage: Message = {
      id: Date.now().toString(),
      text: inputValue,
      sender: "user",
      timestamp: new Date(),
    };

    setMessages((prev) => [...prev, userMessage]);
    setInputValue("");
    setIsTyping(true);

    // Mock AI response
    setTimeout(() => {
      const aiResponse: Message = {
        id: (Date.now() + 1).toString(),
        text: getMockResponse(inputValue),
        sender: "ai",
        timestamp: new Date(),
      };
      setMessages((prev) => [...prev, aiResponse]);
      setIsTyping(false);
    }, 1500);
  };

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages, isTyping]);

  const getMockResponse = (userInput: string): string => {
    const input = userInput.toLowerCase();

    if (input.includes("slack") || input.includes("notification")) {
      return "I can help you set up Slack notifications! You'll want to start with a trigger (like Manual, Webhook, or Schedule), then add a 'Send Slack Message' action. Would you like me to create a template for you?";
    }

    if (input.includes("email") || input.includes("mail")) {
      return "Email automation is great for notifications and reports. I recommend using the 'Send Email' action with dynamic content from your triggers. What kind of email workflow are you thinking about?";
    }

    if (input.includes("api") || input.includes("webhook")) {
      return "API integrations are powerful! You can use the 'API Request' action to fetch data or the 'Webhook' trigger to receive data. The key is properly mapping the data fields between steps.";
    }

    if (
      input.includes("schedule") ||
      input.includes("timer") ||
      input.includes("daily")
    ) {
      return "Scheduled workflows are perfect for recurring tasks! Use the 'Schedule' trigger with cron expressions. For daily tasks, try '0 9 * * *' for 9 AM daily. What do you want to automate?";
    }

    return "That's an interesting automation idea! I'd recommend starting with a trigger that matches your use case, then adding the necessary actions and logic steps. Would you like me to suggest a specific workflow structure?";
  };

  return (
    <div
      className={`
        bg-[var(--card)] border-l border-[var(--border)] flex flex-col z-[60]
        ${isOpen ? "w-80 sm:w-96 md:w-[28rem]" : "w-0 overflow-hidden"}
      `}
    >
      {/* Header */}
      <div className="flex items-center justify-between p-2 sm:p-4 border-b border-[var(--border)]">
        <div className="flex items-center gap-2 sm:gap-3 min-w-0 flex-1">
          <div className="p-2 bg-[var(--primary)] rounded-lg flex-shrink-0">
            <Bot className="w-5 h-5 text-[var(--primary-foreground)]" />
          </div>
          <div className="min-w-0 flex-1">
            <h3 className="font-semibold text-[var(--foreground)] text-sm sm:text-base truncate">
              AI Assistant
            </h3>
            <p className="text-xs sm:text-sm text-[var(--muted-foreground)] truncate">
              Automation helper
            </p>
          </div>
        </div>
        <button
          onClick={onClose}
          className="p-2 hover:bg-[var(--muted)] rounded-lg transition-colors flex-shrink-0 ml-2"
        >
          <X className="w-5 h-5" />
        </button>
      </div>

      {/* Messages */}
      <div className="flex-1 overflow-y-auto p-4 space-y-4">
        {messages.map((message) => (
          <div
            key={message.id}
            className={`flex ${
              message.sender === "user" ? "justify-end" : "justify-start"
            }`}
          >
            <div
              className={`flex max-w-[80%] ${
                message.sender === "user" ? "flex-row-reverse" : "flex-row"
              }`}
            >
              <div
                className={`flex-shrink-0 ${
                  message.sender === "user" ? "ml-3" : "mr-3"
                }`}
              >
                <div
                  className={`w-8 h-8 rounded-full flex items-center justify-center ${
                    message.sender === "user"
                      ? "bg-[var(--primary)]"
                      : "bg-[var(--muted)]"
                  }`}
                >
                  {message.sender === "user" ? (
                    <User className="w-4 h-4 text-[var(--primary-foreground)]" />
                  ) : (
                    <Bot className="w-4 h-4 text-[var(--muted-foreground)]" />
                  )}
                </div>
              </div>
              <div
                className={`px-4 py-3 rounded-2xl ${
                  message.sender === "user"
                    ? "bg-[var(--primary)] text-[var(--primary-foreground)]"
                    : "bg-[var(--muted)] text-[var(--foreground)]"
                }`}
              >
                <p className="text-sm leading-relaxed whitespace-pre-wrap">
                  {message.text}
                </p>
              </div>
            </div>
          </div>
        ))}

        {isTyping && (
          <div className="flex justify-start">
            <div className="flex mr-3">
              <div className="w-8 h-8 bg-[var(--muted)] rounded-full flex items-center justify-center">
                <Bot className="w-4 h-4 text-[var(--muted-foreground)]" />
              </div>
            </div>
            <div className="bg-[var(--muted)] px-4 py-3 rounded-2xl">
              <div className="flex space-x-1">
                <div className="w-2 h-2 bg-[var(--muted-foreground)] rounded-full animate-bounce"></div>
                <div
                  className="w-2 h-2 bg-[var(--muted-foreground)] rounded-full animate-bounce"
                  style={{ animationDelay: "0.1s" }}
                ></div>
                <div
                  className="w-2 h-2 bg-[var(--muted-foreground)] rounded-full animate-bounce"
                  style={{ animationDelay: "0.2s" }}
                ></div>
              </div>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      {/* Input */}
      <div className="p-2 sm:p-4 border-t border-[var(--border)]">
        <div className="flex space-x-2">
          <input
            type="text"
            value={inputValue}
            onChange={(e) => setInputValue(e.target.value)}
            onKeyDown={(e) => e.key === "Enter" && handleSend()}
            placeholder="Ask me anything..."
            className="flex-1 min-w-0 px-3 py-2 bg-[var(--muted)] border border-[var(--border)] rounded-lg focus:outline-none focus:ring-2 focus:ring-[var(--ring)] text-[var(--foreground)] placeholder-[var(--muted-foreground)] text-sm"
          />
          <button
            onClick={handleSend}
            disabled={!inputValue.trim() || isTyping}
            className="px-2 sm:px-3 py-2 bg-[var(--primary)] text-[var(--primary-foreground)] rounded-lg hover:bg-[var(--primary)]/90 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex-shrink-0 w-10 sm:w-auto flex items-center justify-center"
          >
            <Send className="w-4 h-4" />
          </button>
        </div>
      </div>
    </div>
  );
};

export default ChatPanel;

----- Content End -----

===== File: app/editor/components/NodeLibraryPanel.tsx =====
Type: .tsx
----- Content Start -----
"use client";

import { useState } from "react";
import { getIcon } from "../../../hooks/useIcons";
import { useAutomationContext } from "../context/AutomationContext";
import type { Integration } from "../../../lib/integrations/types";
import type { WorkflowTemplate } from "../../../lib/integrations/templates";

const NodeLibraryPanel = () => {
  const {
    sidebarOpen,
    setSidebarOpen,
    getTriggerIntegrations,
    getActionIntegrations,
    getLogicIntegrations,
    getTemplates,
  } = useAutomationContext();

  const [searchTerm, setSearchTerm] = useState("");
  const [currentView, setCurrentView] = useState<
    "main" | "templates" | "triggers" | "actions" | "logic"
  >("main");
  const [viewHistory, setViewHistory] = useState<string[]>(["main"]);

  // Navigation functions
  const navigateToCategory = (
    categoryId: "templates" | "triggers" | "actions" | "logic"
  ) => {
    setCurrentView(categoryId);
    setViewHistory((prev) => [...prev, categoryId]);
    setSearchTerm(""); // Clear search when navigating
  };

  const navigateBack = () => {
    const newHistory = viewHistory.slice(0, -1);
    setViewHistory(newHistory);
    setCurrentView(
      (newHistory[newHistory.length - 1] as
        | "main"
        | "templates"
        | "triggers"
        | "actions"
        | "logic") || "main"
    );
    setSearchTerm(""); // Clear search when going back
  };

  const renderSidebarIcon = (
    iconName: string,
    nodeData: { colorClass?: string }
  ) => {
    const colorClass = nodeData.colorClass || "text-[var(--foreground)]";
    return getIcon(iconName, "w-5 h-5", colorClass);
  };

  const onDragStart = (
    event: React.DragEvent,
    nodeType: string,
    label: string,
    subtype: string,
    icon: string,
    description: string,
    colorClass: string,
    borderClass: string,
    selectedBorderClass: string
  ) => {
    event.dataTransfer.setData(
      "application/reactflow",
      JSON.stringify({
        type: nodeType,
        label,
        subtype,
        icon,
        description,
        colorClass,
        borderClass,
        selectedBorderClass,
      })
    );
    event.dataTransfer.effectAllowed = "move";
  };

  const onDragStartTemplate = (
    event: React.DragEvent,
    template: WorkflowTemplate
  ) => {
    event.dataTransfer.setData(
      "application/reactflow/template",
      JSON.stringify(template)
    );
    event.dataTransfer.effectAllowed = "move";
  };

  // Get all integrations for context-aware filtering
  const allTriggers = getTriggerIntegrations();
  const allActions = getActionIntegrations();
  const allLogic = getLogicIntegrations();
  const allTemplates = getTemplates();

  // Context-aware filtering based on current view
  const getFilteredData = () => {
    if (currentView === "main") {
      // When in main view, search across all categories
      if (!searchTerm) {
        return {
          templates: allTemplates.slice(0, 2), // Show first 2
          triggers: allTriggers, // Show all triggers
          actions: allActions.slice(0, 8), // Show first 8
          logic: allLogic, // Show all logic components
        };
      } else {
        // Search across all categories
        return {
          templates: allTemplates.filter(
            (item) =>
              item.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
              item.description.toLowerCase().includes(searchTerm.toLowerCase())
          ),
          triggers: allTriggers.filter(
            (item) =>
              item.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
              item.description.toLowerCase().includes(searchTerm.toLowerCase())
          ),
          actions: allActions.filter(
            (item) =>
              item.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
              item.description.toLowerCase().includes(searchTerm.toLowerCase())
          ),
          logic: allLogic.filter(
            (item) =>
              item.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
              item.description.toLowerCase().includes(searchTerm.toLowerCase())
          ),
        };
      }
    } else {
      // When in specific category view, only filter that category
      const filterFn = (item: Integration | WorkflowTemplate) =>
        !searchTerm ||
        item.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        item.description.toLowerCase().includes(searchTerm.toLowerCase());

      switch (currentView) {
        case "templates":
          return { [currentView]: allTemplates.filter(filterFn) };
        case "triggers":
          return { [currentView]: allTriggers.filter(filterFn) };
        case "actions":
          return { [currentView]: allActions.filter(filterFn) };
        case "logic":
          return { [currentView]: allLogic.filter(filterFn) };
        default:
          return {};
      }
    }
  };

  const filteredData = getFilteredData();

  const renderIntegrationCard = (
    integration: Integration,
    category: string,
    index: number
  ) => (
    <div
      key={`${category}-${index}`}
      className={`p-3 border rounded-lg cursor-move hover:shadow-sm transition-all group bg-[var(--card)] ${
        integration.borderClass ||
        "border-gray-200 dark:border-gray-700 hover:border-gray-300 dark:hover:border-gray-600"
      }`}
      draggable
      onDragStart={(e) =>
        onDragStart(
          e,
          integration.category,
          integration.name,
          integration.id,
          integration.icon,
          integration.description,
          integration.colorClass || "",
          integration.borderClass || "",
          integration.selectedBorderClass || ""
        )
      }
    >
      <div className="flex items-start gap-3">
        <div className="flex-shrink-0">
          {renderSidebarIcon(integration.icon, integration)}
        </div>
        <div className="min-w-0 flex-1">
          <h3 className="font-medium text-[var(--foreground)] text-sm leading-snug">
            {integration.name}
          </h3>
          <p className="text-xs text-[var(--muted-foreground)] mt-1 leading-relaxed">
            {integration.description}
          </p>
        </div>
      </div>
    </div>
  );

  const renderTemplateCard = (template: WorkflowTemplate, index: number) => (
    <div
      key={`template-${index}`}
      className="p-3 border rounded-lg cursor-move hover:shadow-sm transition-all group bg-[var(--card)] border-emerald-200 dark:border-emerald-800 hover:border-emerald-300 dark:hover:border-emerald-700"
      draggable
      onDragStart={(e) => onDragStartTemplate(e, template)}
    >
      <div className="flex items-start gap-3">
        <div className="flex-shrink-0">
          {getIcon(
            template.icon,
            "w-5 h-5",
            "text-emerald-600 dark:text-emerald-400"
          )}
        </div>
        <div className="min-w-0 flex-1">
          <h3 className="font-medium text-[var(--foreground)] text-sm leading-snug">
            {template.name}
          </h3>
          <p className="text-xs text-[var(--muted-foreground)] mt-1 leading-relaxed">
            {template.description}
          </p>
          <p className="text-xs text-emerald-600 dark:text-emerald-400 mt-1">
            {template.nodes.length} nodes
          </p>
        </div>
      </div>
    </div>
  );

  const renderCategoryPreview = (
    categoryKey: "templates" | "triggers" | "actions" | "logic",
    categoryName: string,
    items: (Integration | WorkflowTemplate)[],
    totalCount: number
  ) => {
    // Show "View all" only for templates and actions, since triggers and logic show all by default
    const showViewAll =
      (categoryKey === "templates" || categoryKey === "actions") &&
      totalCount > items.length &&
      !searchTerm;

    return (
      <div key={categoryKey}>
        <div className="flex items-center justify-between mb-3">
          <h3 className="text-sm font-semibold text-[var(--foreground)]">
            {categoryName}
          </h3>
          {showViewAll && (
            <button
              onClick={() => navigateToCategory(categoryKey)}
              className="text-xs text-[var(--muted-foreground)] hover:text-[var(--foreground)] transition-colors flex items-center gap-1"
            >
              View All ({totalCount}){" "}
              {getIcon(
                "arrow-left",
                "w-3 h-3 rotate-180",
                "text-[var(--muted-foreground)]"
              )}
            </button>
          )}
        </div>
        <div className="space-y-2">
          {items.map((item, index) =>
            categoryKey === "templates"
              ? renderTemplateCard(item as WorkflowTemplate, index)
              : renderIntegrationCard(item as Integration, categoryKey, index)
          )}
        </div>
      </div>
    );
  };

  const renderMainView = () => {
    const hasResults = Object.values(filteredData).some(
      (items: (Integration | WorkflowTemplate)[]) => items?.length > 0
    );

    if (searchTerm && !hasResults) {
      return (
        <div className="text-center py-8">
          <div className="text-[var(--muted-foreground)] text-sm">
            No components or templates found for &quot;{searchTerm}&quot;
          </div>
        </div>
      );
    }

    return (
      <div className="space-y-6">
        {filteredData.templates &&
          filteredData.templates.length > 0 &&
          renderCategoryPreview(
            "templates",
            "Templates",
            filteredData.templates,
            allTemplates.length
          )}
        {filteredData.triggers &&
          filteredData.triggers.length > 0 &&
          renderCategoryPreview(
            "triggers",
            "Triggers",
            filteredData.triggers,
            allTriggers.length
          )}
        {filteredData.actions &&
          filteredData.actions.length > 0 &&
          renderCategoryPreview(
            "actions",
            "Actions",
            filteredData.actions,
            allActions.length
          )}
        {filteredData.logic &&
          filteredData.logic.length > 0 &&
          renderCategoryPreview(
            "logic",
            "Logic",
            filteredData.logic,
            allLogic.length
          )}
      </div>
    );
  };

  const renderCategoryView = () => {
    const categoryData =
      (filteredData[currentView as keyof typeof filteredData] as (
        | Integration
        | WorkflowTemplate
      )[]) || [];
    const categoryNames = {
      templates: "Templates",
      triggers: "Triggers",
      actions: "Actions",
      logic: "Logic",
    };

    const categoryName =
      categoryNames[currentView as keyof typeof categoryNames];

    return (
      <div className="space-y-4">
        <div className="space-y-2">
          {categoryData.map(
            (item: Integration | WorkflowTemplate, index: number) =>
              currentView === "templates"
                ? renderTemplateCard(item as WorkflowTemplate, index)
                : renderIntegrationCard(item as Integration, currentView, index)
          )}
        </div>

        {searchTerm && categoryData.length === 0 && (
          <div className="text-center py-8">
            <div className="text-[var(--muted-foreground)] text-sm">
              No {categoryName.toLowerCase()} found for &quot;{searchTerm}&quot;
            </div>
          </div>
        )}

        {!searchTerm && categoryData.length === 0 && (
          <div className="text-center py-8">
            <div className="text-[var(--muted-foreground)] text-sm">
              No {categoryName.toLowerCase()} available
            </div>
          </div>
        )}
      </div>
    );
  };

  const getSearchPlaceholder = () => {
    if (currentView === "main") {
      return "Search components...";
    }
    const categoryNames = {
      templates: "templates",
      triggers: "triggers",
      actions: "actions",
      logic: "logic components",
    };
    return `Search ${
      categoryNames[currentView as keyof typeof categoryNames]
    }...`;
  };

  const getBreadcrumb = () => {
    if (currentView === "main") return null;

    const categoryNames = {
      templates: "Templates",
      triggers: "Triggers",
      actions: "Actions",
      logic: "Logic",
    };

    return (
      <div className="flex items-center gap-2 mb-4">
        <button
          onClick={navigateBack}
          className="flex items-center gap-1 text-sm text-blue-600 dark:text-blue-400 hover:text-blue-700 dark:hover:text-blue-300 transition-colors"
        >
          {getIcon("arrow-left", "w-4 h-4")}
        </button>
        <span className="text-sm font-medium text-[var(--foreground)]">
          {categoryNames[currentView as keyof typeof categoryNames]}
        </span>
      </div>
    );
  };

  return (
    <div
      className={`
        bg-[var(--card)] border-r border-[var(--border)] transition-colors duration-200 flex flex-col
        ${sidebarOpen ? "w-80" : "w-0 overflow-hidden"}
      `}
    >
      {/* Fixed Header with Search and Close */}
      <div className="sticky top-0 z-10 bg-[var(--card)] border-b border-[var(--border)] px-6 py-4">
        <div className="flex items-center gap-3">
          <div className="flex-1 relative">
            <div className="absolute inset-y-0 left-3 flex items-center pointer-events-none">
              {getIcon("search", "w-4 h-4", "text-[var(--muted-foreground)]")}
            </div>
            <input
              type="text"
              placeholder={getSearchPlaceholder()}
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="w-full pl-10 pr-3 py-2 text-sm bg-[var(--muted)] border border-[var(--border)] rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-[var(--foreground)] placeholder-[var(--muted-foreground)]"
            />
          </div>
          <button
            onClick={() => setSidebarOpen(false)}
            className="p-2 hover:bg-[var(--muted)] rounded-md transition-colors flex-shrink-0"
          >
            {getIcon("x", "w-4 h-4", "text-[var(--foreground)]")}
          </button>
        </div>
      </div>

      {/* Scrollable Content */}
      <div className="flex-1 overflow-y-auto px-6 pb-4 custom-scrollbar">
        <div className="pt-4 pb-12">
          {getBreadcrumb()}
          {currentView === "main" ? renderMainView() : renderCategoryView()}
        </div>
      </div>
    </div>
  );
};

export default NodeLibraryPanel;

----- Content End -----

===== File: app/editor/hooks/useEditor.tsx =====
Type: .tsx
----- Content Start -----
import { useState, useCallback } from "react";
import { Node, Edge } from "@xyflow/react";
import { integrationRegistry } from "../../../lib/integrations/registry";
import { parseExpression } from "../../../lib/expression";

// ============================================
// TYPE DEFINITIONS
// ============================================

interface WorkflowContext {
  variables: Record<string, unknown>;
  nodeOutputs: Record<string, unknown>;
  executionId: string;
  userId?: string;
}

interface ExecutionState {
  currentNode: string | null;
  completedNodes: Set<string>;
  context: WorkflowContext;
  status: "idle" | "running" | "completed" | "failed";
}

interface ExecutionStep {
  node_id: string;
  status: string;
  completed_at?: string;
  result?: {
    success: boolean;
    data?: Record<string, unknown>;
    metadata?: {
      nodeType: string;
      subtype: string;
      [key: string]: unknown;
    };
    [key: string]: unknown;
  };
}

interface WorkflowDefinition {
  id: string;
  name: string;
  nodes: Node[];
  edges: Edge[];
  createdAt: string;
  updatedAt: string;
}

// ============================================
// EXPRESSION PARSER
// ============================================

// Using shared parseExpression from lib/expression.ts

// ============================================
// USE EDITOR HOOK
// ============================================

export const useEditor = (currentWorkflowId: string | null = null) => {
  const registry = integrationRegistry;
  const [executionState, setExecutionState] = useState<ExecutionState>({
    currentNode: null,
    completedNodes: new Set(),
    context: {
      variables: {},
      nodeOutputs: {},
      executionId: "",
    },
    status: "idle",
  });
  const [isExecuting, setIsExecuting] = useState(false);
  const [lastLoadedExecutionId, setLastLoadedExecutionId] = useState<
    string | null
  >(null);

  // Function to restore execution state from database
  const restoreLatestExecution = useCallback(async (workflowId: string) => {
    try {
      // Get the most recent execution for this workflow
      const response = await fetch(
        `/api/execute?workflowId=${workflowId}&latest=true`
      );
      if (!response.ok) return null;

      const execution = await response.json();
      if (!execution || execution.status === "pending") return null;

      // Get detailed execution status with steps
      const statusResponse = await fetch(
        `/api/execute?executionId=${execution.id}`
      );
      if (!statusResponse.ok) return null;

      const executionDetails = await statusResponse.json();

      console.log("üîÑ Restoring execution state:", executionDetails);

      // Restore execution state
      const restoredContext: WorkflowContext = {
        variables: {},
        nodeOutputs: {},
        executionId: execution.id,
      };

      // Process each step to rebuild context
      if (executionDetails.steps) {
        executionDetails.steps.forEach((step: ExecutionStep) => {
          if (step.status === "completed" && step.result) {
            // Add to node outputs
            restoredContext.nodeOutputs[step.node_id] = step.result;

            // Handle variables from set_variable steps
            if (
              step.result?.metadata?.subtype === "set_variable" &&
              step.result.data
            ) {
              const data = step.result.data as {
                variableName: string;
                value: unknown;
              };
              restoredContext.variables[data.variableName] = data.value;
            }
          }
        });
      }

      // Update execution state
      setExecutionState({
        currentNode: null,
        completedNodes: new Set(
          executionDetails.steps
            ?.filter((s: ExecutionStep) => s.status === "completed")
            ?.map((s: ExecutionStep) => s.node_id) || []
        ),
        context: restoredContext,
        status:
          executionDetails.status === "completed"
            ? "completed"
            : executionDetails.status === "failed"
            ? "failed"
            : "idle",
      });

      setLastLoadedExecutionId(execution.id);

      return { execution, steps: executionDetails.steps };
    } catch (error) {
      console.error("Failed to restore execution state:", error);
      return null;
    }
  }, []);

  // Function to restore node visual states
  const restoreNodeStates = useCallback(
    (
      nodes: Node[],
      steps: ExecutionStep[],
      onNodeStatusChange: (
        nodeId: string,
        status: "idle" | "running" | "success" | "error",
        lastRun?: string,
        executionResult?: Record<string, unknown>
      ) => void
    ) => {
      steps?.forEach((step: ExecutionStep) => {
        if (step.result) {
          onNodeStatusChange(
            step.node_id,
            step.status === "completed" ? "success" : "error",
            step.completed_at
              ? new Date(step.completed_at).toLocaleTimeString()
              : undefined,
            step.result
          );
        }
      });
    },
    []
  );

  // Enhanced loadWorkflow to restore execution state
  const loadWorkflow = useCallback(async (): Promise<
    | (WorkflowDefinition & {
        restoredExecution?: {
          execution: unknown;
          steps: ExecutionStep[];
        } | null;
      })
    | null
  > => {
    try {
      const response = await fetch("/api/automations");
      if (!response.ok) throw new Error("Failed to load automations");

      const workflows = await response.json();
      if (workflows.length > 0) {
        const workflow = workflows[0];
        // setCurrentWorkflowId(workflow.id); // This line is removed as per the edit hint

        const result = {
          id: workflow.id,
          name: workflow.name,
          nodes: workflow.nodes,
          edges: workflow.edges,
          createdAt: workflow.createdAt || new Date().toISOString(),
          updatedAt: workflow.updatedAt || new Date().toISOString(),
        };

        // Try to restore the latest execution state
        const restoredExecution = await restoreLatestExecution(workflow.id);

        return {
          ...result,
          restoredExecution,
        };
      }
      return null;
    } catch (error) {
      console.error("Load failed:", error);
      return null;
    }
  }, [restoreLatestExecution]);

  // Save workflow to database
  const saveWorkflow = useCallback(
    async (
      nodes: Node[],
      edges: Edge[],
      name: string = "Untitled Workflow"
    ) => {
      try {
        const method = currentWorkflowId ? "PUT" : "POST";
        const body = currentWorkflowId
          ? JSON.stringify({ id: currentWorkflowId, name, nodes, edges })
          : JSON.stringify({ name, nodes, edges });

        const response = await fetch("/api/automations", {
          method,
          headers: { "Content-Type": "application/json" },
          body,
        });

        if (!response.ok) throw new Error("Failed to save workflow");

        const workflow = await response.json();

        // Update the URL to reflect the new automation ID if this is a new workflow
        if (!currentWorkflowId) {
          window.history.replaceState({}, "", `/editor?id=${workflow.id}`);
        }

        console.log("Workflow saved:", workflow);
        return { success: true, id: workflow.id };
      } catch (error) {
        console.error("Save failed:", error);
        throw error;
      }
    },
    [currentWorkflowId]
  );

  // Execute workflow in background
  const executeWorkflow = useCallback(
    async (
      nodes: Node[],
      edges: Edge[],
      onNodeStatusChange: (
        nodeId: string,
        status: "idle" | "running" | "success" | "error",
        lastRun?: string,
        executionResult?: Record<string, unknown>
      ) => void
    ) => {
      if (isExecuting || !currentWorkflowId) return;

      // Clear any previously restored state
      setLastLoadedExecutionId(null);

      // Reset execution state to fresh
      setExecutionState({
        currentNode: null,
        completedNodes: new Set(),
        context: {
          variables: {},
          nodeOutputs: {},
          executionId: "",
        },
        status: "idle",
      });

      setIsExecuting(true);

      try {
        // Start background execution
        const response = await fetch(`/api/execute`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ workflowId: currentWorkflowId }),
        });

        if (!response.ok) throw new Error("Failed to start execution");

        const { executionId } = await response.json();

        setExecutionState((prev) => ({
          ...prev,
          status: "running",
          context: { ...prev.context, executionId },
        }));

        // Poll for execution status
        const pollInterval = setInterval(async () => {
          try {
            const statusResponse = await fetch(
              `/api/execute?executionId=${executionId}`
            );
            const status = await statusResponse.json();

            if (status.status === "completed" || status.status === "failed") {
              clearInterval(pollInterval);
              setExecutionState((prev) => ({
                ...prev,
                status: status.status === "completed" ? "completed" : "failed",
              }));
              setIsExecuting(false);

              // Reset all nodes to idle first, then update completed nodes
              if (status.steps) {
                // Reset all nodes to idle first
                nodes.forEach((node) => {
                  onNodeStatusChange(node.id, "idle");
                });

                // Update completed nodes
                status.steps.forEach((step: ExecutionStep) => {
                  onNodeStatusChange(
                    step.node_id,
                    step.status === "completed" ? "success" : "error",
                    step.completed_at
                      ? new Date(step.completed_at).toLocaleTimeString()
                      : undefined,
                    step.result
                  );

                  if (step.status === "completed" && step.result) {
                    setExecutionState((prev) => ({
                      ...prev,
                      context: {
                        ...prev.context,
                        nodeOutputs: {
                          ...prev.context.nodeOutputs,
                          [step.node_id]: step.result,
                        },
                        variables:
                          step.result?.metadata?.subtype === "set_variable" &&
                          step.result.data
                            ? {
                                ...prev.context.variables,
                                [(
                                  step.result.data as {
                                    variableName: string;
                                    value: unknown;
                                  }
                                ).variableName]: (
                                  step.result.data as {
                                    variableName: string;
                                    value: unknown;
                                  }
                                ).value,
                              }
                            : prev.context.variables,
                      },
                    }));
                  }
                });
              }
            } else if (status.status === "running") {
              // Find the currently running step and update only that node
              const runningStep = status.steps?.find(
                (s: ExecutionStep) => s.status === "running"
              );
              if (runningStep) {
                // Reset all to idle first, then set current to running
                nodes.forEach((node) => {
                  const isCompleted = status.steps?.some(
                    (s: ExecutionStep) =>
                      s.node_id === node.id && s.status === "completed"
                  );
                  onNodeStatusChange(node.id, isCompleted ? "success" : "idle");
                });

                onNodeStatusChange(runningStep.node_id, "running");
              }
            }
          } catch (error) {
            console.error("Polling error:", error);
            clearInterval(pollInterval);
            setIsExecuting(false);
          }
        }, 2000); // Poll every 2 seconds
      } catch (error) {
        console.error("Execution failed:", error);
        setIsExecuting(false);
        setExecutionState((prev) => ({ ...prev, status: "failed" }));
      }
    },
    [isExecuting, currentWorkflowId]
  );

  return {
    // State
    executionState,
    isExecuting,
    registry,
    lastLoadedExecutionId,

    // Actions
    saveWorkflow,
    loadWorkflow,
    executeWorkflow,
    restoreLatestExecution,
    restoreNodeStates,

    // Utilities
    parseExpression,
  };
};

----- Content End -----

